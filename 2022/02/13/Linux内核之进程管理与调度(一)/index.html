<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="进程是任何多道程序设计的操作系统的基本概念，通常把进程定义为程序执行的示例，作为资源分配的单位。所有的现代操作系统都能够同时运行若干个进程，至少在用户看来是这样的。如果系统只有一个处理器，那么在给定时刻只能有一个程序可以运行，在多处理器系统中才能够做到真正的并行，并行进行的树木取决于处理器数量。Linux作为最流行的现代操作系统，自然是多到程序设计，那么Linux又是如何定义进程，使其能够表示一个">
<meta name="keywords" content="SourceCode,Linux,2.6.24,2.6.11">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核之进程管理与调度(一)">
<meta property="og:url" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/index.html">
<meta property="og:site_name" content="CommonGuy">
<meta property="og:description" content="进程是任何多道程序设计的操作系统的基本概念，通常把进程定义为程序执行的示例，作为资源分配的单位。所有的现代操作系统都能够同时运行若干个进程，至少在用户看来是这样的。如果系统只有一个处理器，那么在给定时刻只能有一个程序可以运行，在多处理器系统中才能够做到真正的并行，并行进行的树木取决于处理器数量。Linux作为最流行的现代操作系统，自然是多到程序设计，那么Linux又是如何定义进程，使其能够表示一个">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/1.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/2.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/3.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/4.png">
<meta property="og:updated_time" content="2022-02-25T13:36:37.464Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux内核之进程管理与调度(一)">
<meta name="twitter:description" content="进程是任何多道程序设计的操作系统的基本概念，通常把进程定义为程序执行的示例，作为资源分配的单位。所有的现代操作系统都能够同时运行若干个进程，至少在用户看来是这样的。如果系统只有一个处理器，那么在给定时刻只能有一个程序可以运行，在多处理器系统中才能够做到真正的并行，并行进行的树木取决于处理器数量。Linux作为最流行的现代操作系统，自然是多到程序设计，那么Linux又是如何定义进程，使其能够表示一个">
<meta name="twitter:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/1.png">
  <link rel="canonical" href="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Linux内核之进程管理与调度(一) | CommonGuy</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/HoA-W" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CommonGuy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://guoyuanchao1202/GolangBlog.github.io/2022/02/13/Linux内核之进程管理与调度(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭源潮">
      <meta itemprop="description" content="时间在无声的诉说着一切">
      <meta itemprop="image" content="/images/images.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CommonGuy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Linux内核之进程管理与调度(一)

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-02-13 15:22:16" itemprop="dateCreated datePublished" datetime="2022-02-13T15:22:16+08:00">2022-02-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-25 21:36:37" itemprop="dateModified" datetime="2022-02-25T21:36:37+08:00">2022-02-25</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>进程是任何多道程序设计的操作系统的基本概念，通常把进程定义为程序执行的示例，作为资源分配的单位。所有的现代操作系统都能够同时运行若干个进程，至少在用户看来是这样的。如果系统只有一个处理器，那么在给定时刻只能有一个程序可以运行，在多处理器系统中才能够做到真正的并行，并行进行的树木取决于处理器数量。Linux作为最流行的现代操作系统，自然是多到程序设计，那么Linux又是如何定义进程，使其能够表示一个程序执行的呢？又是如何对系统中多个进程进行调度，从而实现多任务呢？下面我将基于<code>Linux2.6.11</code>和<code>2.6.24</code>两个版本(x86下的32位平台)的Linux内核，对Linux内核的进程管理与调度进行剖析。(之所以选择两个版本，是因为相比于2.6.11的O(1)调度器，2.6.24中实现了大名鼎鼎的CFS调度器)</p>
<hr>
<a id="more"></a>

<h1 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h1><p>在本节中，会对进程的概念进行介绍，不涉及实际的Linux源码</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>进程</strong>，在OS教科书中的定义是这样的：<code>进程是程序执行时的一个实例</code>。它记录了程序执行时CPU时间、CPU寄存器值、占用的内存、使用的文件系统、打开的文件、处理的信号…简单的说，进程可以充分描述程序已经执行到何种程度的数据结构。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>实际上，当一个系统中有多个进程时，并非所有进程都具有相同的优先级，除了大家所熟知的进程优先级之外，根据进程实现的功能，还将进程分为不同的种类，以满足不同的需求。进程整体上分为两类：</p>
<ul>
<li>实时进程</li>
<li>非实时进程(普通进程)</li>
</ul>
<p>而实时进程又分为两种，所以我们一共有三种进程</p>
<h3 id="硬实时进程"><a href="#硬实时进程" class="headerlink" title="硬实时进程"></a>硬实时进程</h3><p>这类进程有非常严格的时间限制，进程的某些任务必须在指定实现内完成。例如：飞机的飞行控制命令通过计算机处理，那么必须在指定时限内完成，想象一下，如果飞机在着陆，飞行员想要拉起机头，而系统无法保证在指定时限内完成，那大家可以吃席了(逃…)。因此对于硬实时进程，它必须在可保证的时间范围内得到处理，然而这并不意味着所要求的时间范围特别短(即系统必须必须非常快的完成)，而是系统保证绝对不会超过任务要求的时间范围，即使在条件不利的情况下。主流<code>Linux</code>不支持硬实时处理。这是因为Linux是针对吞吐量优化，试图尽快的处理常见情形，很难实现可保证响应时间。</p>
<h3 id="软实时进程"><a href="#软实时进程" class="headerlink" title="软实时进程"></a>软实时进程</h3><p>该类进程是硬实时进程的弱化版本，尽快仍然需要快速得到结果，但稍微晚一点儿也不会造成很大的影响。例如对CD的写入操作：CD写入进程接收到的数据必须保持某一速率，因为数据是以连续流的形式写入介质的。如果系统负荷过高，数据流可能会暂时中断，这样就有可能导致写出来的CD不可用，但是也不会导致吃席的情况。不过这种系统会尽量保证这类进程的优先级要高于普通进程。</p>
<h3 id="普通进程"><a href="#普通进程" class="headerlink" title="普通进程"></a>普通进程</h3><p>实际上系统中的大多数进程都是普通进程，但是普通进程之间仍然可以根据重要性来分配优先级。一个通用的例子：编译程序和编辑程序。相比于和用户交互的编辑程序，编译程序的优先级更低，这样编辑程序能够更快的响应用户，使得用户体验更好。</p>
<h3 id="优先级划分"><a href="#优先级划分" class="headerlink" title="优先级划分"></a>优先级划分</h3><p>Linux系统将所有进程(软实时进程和普通进程)划分了140个优先级(0-139),其中</p>
<ul>
<li>0-99：表示实时进程的优先级，数值越大优先级越高(优先级为99的实时进程具有整个系统最高优先级)</li>
<li>100-139：表示普通进程的优先级，数值越小优先级越高(和上面刚好相反)</li>
</ul>
<p>可能这样的设计很奇怪，但是具体这么设计的原因已经无从考证。</p>
<h3 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h3><p>进程类似于人类，它们被产生，有或多或少有效的生命，可能产生若干个子进程、最终都会死亡。唯一的区别在于进程没有性别(hhh-_-)。</p>
<p>进程并不总是可以立即执行，有时候它必须等待来自外部信号源、不受其控制的事件。例如在文本编辑程序中等待键盘输入。在事件发生之前，进程无法执行。</p>
<p>当调度器在进程之间切换时，必须知道系统中每个进程的状态。将CPU时间分配到无事可做的进程，显然是一种浪费。进程在各个状态之间的转换也同样重要。例如：如果一个进程在等待来自键盘的数据，那么调度器的指责是一旦数据到达，则需要将进程额度状态由等待改为可运行。进程可能有以下几种状态(普通意义而言，不涉及具体操作系统)：</p>
<ul>
<li>运行：该进程此刻正在执行</li>
<li>等待：进程能够运行，但没有得到许可，因此此时CPU正在执行其他进程</li>
<li>睡眠：进程正在睡眠无法运行，因为它在等待一个外部事件。调度器无法在下一次任务切换时选择该进程</li>
<li>终止：进程生命周期结束</li>
</ul>
<p>系统将所有进程保存在一个进程链表中、无论其状态是运行、睡眠还是等待。但睡眠进程会被标注出来，调度器会知道这些进程无法立即执行。睡眠进程会分类到若干队列中(一般来说，进程因为什么睡眠，那么进程就会睡眠在相关的等待队列上)，因此进程可以在适当的时间被唤醒。</p>
<h1 id="Linux进程实现"><a href="#Linux进程实现" class="headerlink" title="Linux进程实现"></a>Linux进程实现</h1><p>前面介绍了一些进程的基本概念，不设计具体的操作系统。本节主要介绍Linux如何标识一个进程、如何创建进程、如何组织进程之间的关系、如何终止进程等。</p>
<h2 id="标识进程"><a href="#标识进程" class="headerlink" title="标识进程"></a>标识进程</h2><p>Linux使用一个被称为<code>进程表描述符</code>的结构体来标识一个进程，该结构体就是<code>task_struct</code>，位于sched.h中。子段内容如下(Linux2.6.24)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>; <span class="comment">// 进程内核栈</span></span><br><span class="line">	<span class="keyword">atomic_t</span> usage; <span class="comment">// 进程引用计数，初始化为2</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace; <span class="comment">// 记录当前进程的调试状态</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> lock_depth;		<span class="comment">/* BKL lock depth */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_WANT_UNLOCKED_CTXSW</span></span><br><span class="line">	<span class="keyword">int</span> oncpu;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> prio, static_prio, normal_prio; <span class="comment">// 动态优先级，静态优先级以及普通优先级</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span> <span class="comment">// 调度相关</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span> <span class="comment">// 进程所属的调度类，2.6.24下一般都是cfs</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span> <span class="comment">// 调度实体，2.6.24下的调度器可以调度所有的调度实体，所有包含了调度实体的结构都能被调度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="comment">/* list of struct preempt_notifier: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">preempt_notifiers</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> ioprio;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fpu_counter contains the number of consecutive context switches</span></span><br><span class="line"><span class="comment">	 * that the FPU is used. If this is over a threshold, the lazy fpu</span></span><br><span class="line"><span class="comment">	 * saving becomes unlazy to save the trap. This is an unsigned char</span></span><br><span class="line"><span class="comment">	 * so that after 256 times the counter wraps and the behavior turns</span></span><br><span class="line"><span class="comment">	 * lazy again; this to deal with bursty apps that only use FPU for</span></span><br><span class="line"><span class="comment">	 * a short time</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> fpu_counter;</span><br><span class="line">	s8 oomkilladj; <span class="comment">/* OOM kill score adjustment (bit shift). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> btrace_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line">	<span class="keyword">cpumask_t</span> cpus_allowed; </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span> <span class="title">sched_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ptrace_list/ptrace_children forms the list of my children</span></span><br><span class="line"><span class="comment">	 * that were stolen by a ptracer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_children</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_list</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* task state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line">	<span class="keyword">int</span> exit_state;</span><br><span class="line">	<span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line">	<span class="keyword">int</span> pdeath_signal;  <span class="comment">/*  The signal sent when the parent dies  */</span></span><br><span class="line">	<span class="comment">/* ??? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> personality;</span><br><span class="line">	<span class="keyword">unsigned</span> did_exec:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">pid_t</span> tgid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CC_STACKPROTECTOR</span></span><br><span class="line">	<span class="comment">/* Canary value for the -fstack-protector gcc feature */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_canary;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * pointers to (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">	 * older sibling, respectively.  (p-&gt;father can be replaced with </span></span><br><span class="line"><span class="comment">	 * p-&gt;parent-&gt;pid)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process (when being debugged) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span>	<span class="comment">/* parent process */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * children/sibling forms the list of my children plus the</span></span><br><span class="line"><span class="comment">	 * tasks I'm ptracing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>	<span class="comment">/* list of my children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>	<span class="comment">/* linkage in my parent's children list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span>	<span class="comment">/* threadgroup leader */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>		<span class="comment">/* for vfork() */</span></span><br><span class="line">	<span class="keyword">int</span> __user *set_child_tid;		<span class="comment">/* CLONE_CHILD_SETTID */</span></span><br><span class="line">	<span class="keyword">int</span> __user *clear_child_tid;		<span class="comment">/* CLONE_CHILD_CLEARTID */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line">	<span class="keyword">cputime_t</span> utime, stime, utimescaled, stimescaled;</span><br><span class="line">	<span class="keyword">cputime_t</span> gtime;</span><br><span class="line">	<span class="keyword">cputime_t</span> prev_utime, prev_stime;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> 		<span class="comment">/* monotonic time */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span>	<span class="comment">/* boot based time */</span></span><br><span class="line"><span class="comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">cputime_t</span> it_prof_expires, it_virt_expires;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> it_sched_expires;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>[3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">	<span class="keyword">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>   cap_effective, cap_inheritable, cap_permitted;</span><br><span class="line">	<span class="keyword">unsigned</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">request_key_auth</span>;</span>	<span class="comment">/* assumed request_key authority */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">thread_keyring</span>;</span>	<span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> jit_keyring;	<span class="comment">/* default keyring to attach requested keys to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">				     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">				       it with task_lock())</span></span><br><span class="line"><span class="comment">				     - initialized normally by flush_old_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="comment">/* namespaces */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line"><span class="comment">/* signal handlers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sigset_t</span> blocked, real_blocked;</span><br><span class="line">	<span class="keyword">sigset_t</span> saved_sigmask;		<span class="comment">/* To be restored with TIF_RESTORE_SIGMASK */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">	<span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line">	<span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line">	<span class="keyword">void</span> *notifier_data;</span><br><span class="line">	<span class="keyword">sigset_t</span> *notifier_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span> *<span class="title">audit_context</span>;</span></span><br><span class="line">	<span class="keyword">seccomp_t</span> seccomp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread group tracking */</span></span><br><span class="line">   	u32 parent_exec_id;</span><br><span class="line">   	u32 self_exec_id;</span><br><span class="line"><span class="comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> pi_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_MUTEXES</span></span><br><span class="line">	<span class="comment">/* PI waiters blocked on a rt_mutex held by this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">plist_head</span> <span class="title">pi_waiters</span>;</span></span><br><span class="line">	<span class="comment">/* Deadlock detection and priority inheritance handling */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_waiter</span> *<span class="title">pi_blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="comment">/* mutex deadlock detection */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> *<span class="title">blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_events;</span><br><span class="line">	<span class="keyword">int</span> hardirqs_enabled;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hardirq_enable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hardirq_enable_event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hardirq_disable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hardirq_disable_event;</span><br><span class="line">	<span class="keyword">int</span> softirqs_enabled;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> softirq_disable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_disable_event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> softirq_enable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_enable_event;</span><br><span class="line">	<span class="keyword">int</span> hardirq_context;</span><br><span class="line">	<span class="keyword">int</span> softirq_context;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_LOCK_DEPTH 30UL</span></span><br><span class="line">	u64 curr_chain_key;</span><br><span class="line">	<span class="keyword">int</span> lockdep_depth;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">held_lock</span> <span class="title">held_locks</span>[<span class="title">MAX_LOCK_DEPTH</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lockdep_recursion;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* journalling filesystem info */</span></span><br><span class="line">	<span class="keyword">void</span> *journal_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stacked block device info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio_list</span>, **<span class="title">bio_tail</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* VM state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span> *<span class="title">reclaim_state</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line">	<span class="keyword">siginfo_t</span> *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TASK_XACCT</span></span><br><span class="line"><span class="comment">/* i/o counters(bytes read/written, #syscalls */</span></span><br><span class="line">	u64 rchar, wchar, syscr, syscw;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span> <span class="title">ioac</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TASK_XACCT)</span></span><br><span class="line">	u64 acct_rss_mem1;	<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">	u64 acct_vm_mem1;	<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line">	<span class="keyword">cputime_t</span> acct_stimexpd;<span class="comment">/* stime since last update */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">mempolicy</span>;</span></span><br><span class="line">	<span class="keyword">short</span> il_next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line">	<span class="keyword">nodemask_t</span> mems_allowed;</span><br><span class="line">	<span class="keyword">int</span> cpuset_mems_generation;</span><br><span class="line">	<span class="keyword">int</span> cpuset_mem_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> *<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span> *<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pi_state_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span> *<span class="title">pi_state_cache</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">atomic_t</span> fs_excl;	<span class="comment">/* holding fs exclusive resources */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cache last used pipe for splice</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">splice_pipe</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_TASK_DELAY_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_delay_info</span> *<span class="title">delays</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAULT_INJECTION</span></span><br><span class="line">	<span class="keyword">int</span> make_it_fail;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prop_local_single</span> <span class="title">dirties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>task_struct</code>包含的字段非常之多，这些字段把进程与各个内核子系统联系起来，等使用到相应字段时，在进行介绍，这里只是简单的罗列。该结构的内容可以分为不同的部分，每个部分表示进程的一个特定方面</p>
<ul>
<li>状态和执行信息<br>如信号、程序文件使用的二进制格式、进程的PID、到父进程以及其他进程的指针、优先级以及程序执行有关的时间信息</li>
<li>分配给进程的虚拟内存信息</li>
<li>进程的身份凭据，如用户ID、组ID以及权限等。可以使用系统调用查询/修改这些数据</li>
<li>当前进程使用的文件、进程处理的所有文件的文件系统信息</li>
<li>该进程特定于CPU的运行时间数据</li>
<li>该进程使用的所有信号处理程序，用于响应到来的信号</li>
<li>……</li>
</ul>
<p><code>task_struct</code>许多成员并非简单类型变量，而是指向其他数据结构的指针，具体信息在用到时会进行介绍。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在前面一节介绍了通用操作系统的状态。在本节将对<code>Linux2.6.24</code>版本的进程状态进行介绍</p>
<h4 id="可运行状态-TASK-RUNNING"><a href="#可运行状态-TASK-RUNNING" class="headerlink" title="可运行状态(TASK_RUNNING)"></a>可运行状态(TASK_RUNNING)</h4><p>此状态的进程要么在CPU上运行，要么准备执行(可以被调度程序选中执行)</p>
<h4 id="可中断睡眠状态-TASK-INTERRUPTIBLE"><a href="#可中断睡眠状态-TASK-INTERRUPTIBLE" class="headerlink" title="可中断睡眠状态(TASK_INTERRUPTIBLE)"></a>可中断睡眠状态(TASK_INTERRUPTIBLE)</h4><p>进程被挂起，直到某个条件变为真。产生一个中断、释放进程等待的资源、或者传递一个信号都可以作为唤醒进程的条件(把进程状态修改为TASK_RUNNING)</p>
<h4 id="不可中断睡眠状态-TASK-UNINTERRUPTIBLE"><a href="#不可中断睡眠状态-TASK-UNINTERRUPTIBLE" class="headerlink" title="不可中断睡眠状态(TASK_UNINTERRUPTIBLE)"></a>不可中断睡眠状态(TASK_UNINTERRUPTIBLE)</h4><p>与可中断睡眠类似，但是此状态下不响应信号。这种状态很少用到，因为如果由于一些原因导致对此类进程的唤醒操作没有发生，那么该进程永远无法醒过来，也无法被终止(不接受任何信号，包括KILL)。</p>
<h4 id="可终止不可中断睡眠状态-TASK-KILLABLE"><a href="#可终止不可中断睡眠状态-TASK-KILLABLE" class="headerlink" title="可终止不可中断睡眠状态(TASK_KILLABLE)"></a>可终止不可中断睡眠状态(TASK_KILLABLE)</h4><p>与不可中断睡眠类似，但是该状态下可以响应致命信号，因此可以被终止。</p>
<h4 id="暂停状态-TASK-STOPPED"><a href="#暂停状态-TASK-STOPPED" class="headerlink" title="暂停状态(TASK_STOPPED)"></a>暂停状态(TASK_STOPPED)</h4><p>进程的执行被暂停，当进程接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU信号时进入此状态。</p>
<h4 id="跟踪状态-TASK-TRACED"><a href="#跟踪状态-TASK-TRACED" class="headerlink" title="跟踪状态(TASK_TRACED)"></a>跟踪状态(TASK_TRACED)</h4><p>进程的执行由debugger程序暂停。当一个进程被另一个进程监控时任何信号都可以把该进程状态置为TASK_TRACED</p>
<h4 id="僵尸状态-TASK-ZOMBIE"><a href="#僵尸状态-TASK-ZOMBIE" class="headerlink" title="僵尸状态(TASK_ZOMBIE)"></a>僵尸状态(TASK_ZOMBIE)</h4><p>进程的执行被终止、但是父进程还没有发布<code>wait</code>或<code>wait4</code>系统调用来返回有关死亡进程的信息。发布<code>wait</code>系统调用前、内核不能丢弃包含在死亡进程中的数据，因为父进程可能还需要这些信息</p>
<h4 id="死亡状态-EXIT-DEAD"><a href="#死亡状态-EXIT-DEAD" class="headerlink" title="死亡状态(EXIT_DEAD)"></a>死亡状态(EXIT_DEAD)</h4><p>最终状态：当父进程发送了<code>wait</code>或<code>wait4</code>系统调用后，进程由系统删除。为了防止其他执行线程在同一个进程上也执行<code>wait</code>类系统调用(这是一种竞争条件)，因此把进程状态修改为该状态。</p>
<p>其中<code>TASK_ZOMBIE</code>和<code>EXIT_DEAD</code>状态既可用于<code>task_struct.state</code>字段，也可以用于<code>task_struct.exit_state</code>字段</p>
<h3 id="进程资源限制"><a href="#进程资源限制" class="headerlink" title="进程资源限制"></a>进程资源限制</h3><p>Linux提供了资源限制机制，对进程使用的系统资源加以某些限制。该机制利用的<code>task_struct.signal.rlim</code>字段实现，其中signal子段是<code>signal_struct</code>类型，和进程信号相关，这里不多介绍，rlim字段是<code>resource.rlimit</code>类型，结构如下(Linux2.6.24):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rlim_cur;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rlim_max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述定义非常通用，可以用于多种不同的资源限制，实际上也确实如此，<code>task_struct.signal.rlim</code>是一个数组，述祖的每一项限制了一种资源。</p>
<ul>
<li>rlim_cur是进程当前资源限制，是一种软限制</li>
<li>rlim_max是该限制的最大容许值，是硬限制</li>
</ul>
<p>可以使用系统调用setrlimit来修改限制，但是不能超出rlim_max执行的值。具体的资源限制报错最大CPU时间、最大文件长度、最大用户栈长度、打开文件最大数目….感兴趣可以查看Linux代码</p>
<p>idle进程(注意，这里指的是0号进程，idle进程或者swagger进程)的限制在系统启动时即生效，定义在<code>include/asm/generic/resource.h</code>中的<code>INIT_RLIMITS</code>。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间为更加轻量级的虚拟化提供了支持，使得我们可以从不同的方面查看运行系统的全局属性。传统上来说，Linux中许多资源都是全局管理的。例如系统中所有进程都通过PID来标识，那么这就意味着内核必须管理一个全局PID列表，来保证PID的唯一性，并且系统中所有调用者通过uname系统调用返回的系统相关信息(系统名称、版本等信息)也是相同的。</p>
<p>全局ID使得内核可以有选择的允许或者拒绝某些特权，比如：UID为0的root用户几乎可以做任何事情，但是其他非root的用户ID则会受到限制，比如说UID为n的用户不能够杀死UID为m用户的进程，这是符合常识的。因为无论是UID还是PID都是全局唯一的，所以内核可以很轻松的做到这些事情。</p>
<p>另外，虽然内核能够阻止n用户杀死m用户的进程，但是却不能阻止他们看到彼此，也就是说：同一个系统上的用户能够看到其他用户的进程、资源等..但是却不能轻易的操作其它用户的资源，这正是我们日常见到的那样。这看起来也并没有什么问题，因为我们日常在自己的电脑上都是这么用的。</p>
<p>但是在有些情况下，这并不是我们想要的。想象一下，一个提供主机服务的供应商打算向用户提供Linux计算机的全部访问权限，也包括root权限。按照前面的来说，供应商需要为每个用户都准备一台计算机，因为传统的计算机资源都是唯一的，当然页包括root资源，一台机器上当然不能有两个root用户。并且此时用户也并不希望同意计算机上的其他用户看到自己的资源(即使其他人可能无法操作)。如果为每个用户都准备一台计算机，那代价也太高了。</p>
<p>有什么方法来解决这个事情吗？当然有，那就是使用KVM或VMWare提供的虚拟化环境，但是这种方式太重的，计算机的各个用户都需要一个独立的内核，以及一份完全安装好的配套的用户层应用，并且如果你稍微了解一个传统虚拟化的实现就可以发现，计算机相当一部分资源都消耗在虚拟化上，这就导致一台计算机实际上运行不了太多的虚拟机，并且虚拟机的资源分配做的也不是很好，这对于厂商来说也是不够满意的。</p>
<p>说到这里，就要到我们的主角登场了，Linux的命名空间提供了全新的解决方案，并且所需要的资源也比较少：这就是<code>容器</code>。和传统的虚拟化不同，命名空间只需要一个内核在一台物理计算机上运作，将前面说到的所有全局资源通过不同的命名空间抽象起来。这样就可以将一组进程放到容器中，容器之间彼此隔离，隔离可以使容器之间互不可见，每个容器都认为自己是一台真正的计算机。当然也可以允许容器进行一定的操作，来降低容器之间的分隔。例如：不同的容器之间可以共享部分文件系统，这样它们在共享部分的修改则互相可见。</p>
<p>本质上，命名空间建立了系统的不同视图，此前的全局资源都必须包装到容器数据结构中，此时只有<code>&lt;资源，包含资源的命名空间&gt;</code>构成的二元组是全局唯一的。比如用户的UID，在容器内部，用户的UID仍然是唯一的，但是在容器外部无法保证唯一，比如每个容器都有一个UID为0的root用户。</p>
<h3 id="层次化命名空间"><a href="#层次化命名空间" class="headerlink" title="层次化命名空间"></a>层次化命名空间</h3><p>命名空间可以组织为层次化，如下图所示，一个命名空间是父命名空间，衍生了两个子命名空间。我们假定要将命名空间用于支持容器化，那么每个容器必须看起来像是一台单独的计算机，因此其中每个都有自身的init进程(PID为1)，其他进程的PID递增分配。两个子命名空间都有各自PID为1的init进程，可以看到在多命名空间下PID号不是唯一的。</p>
<p>虽然子容器(子命名空间)不了解系统中的其他容器，但是父容器却知道子容器的存在，也可以看到其中执行的所有进程。如图所示，子容器的进程可以映射到父容器中，PID为4-9。因此尽管系统上有9个进程，但需要15个PID来标识(每个进程可能需要多个PID，在子容器和父容器中具有不同的PID)<br><img src="1.png" alt></p>
<h3 id="非层次化命名空间"><a href="#非层次化命名空间" class="headerlink" title="非层次化命名空间"></a>非层次化命名空间</h3><p>当然，也并非所有命名空间都是非层次化的，如果命名空间中包含比较简单的量，那么它也可以是非层次化的，比如<code>UTS</code>命名空间，在这种情况下，父子命名空间之间没有关系。UTS也就是<code>Unix Timesharing System</code>的简称，该命名空间下包含了运行内核的名称、版本、底层体系结构类型等信息。通过UTS命名空间，就实现了同一个系统下不同命名空间中可能会看到不同的内核版本等信息。</p>
<h3 id="命名空间创建"><a href="#命名空间创建" class="headerlink" title="命名空间创建"></a>命名空间创建</h3><p>Linux对简单形式的命名空间的支持已经很久了，主要是chroot系统调用。该方法可以将进程限制到文件系统的某一部分，可以看作一种简单的命名空间机制，但真正的命名空间能够控制的功能远远超过文件系统(CPU、内存、网络等..)。新的命名空间可以使用下面两种方法创建：</p>
<ul>
<li>在fork或clone系统调用创建新进程时，有特定的选项可以控制子进程是否与父进程共享命名空间，或者是建立单独的命名空间</li>
<li>unshare系统调用将进程的某些部分从父进程分离，其中也包括命名空间。</li>
</ul>
<p>在进程使用以上两种手段建立的单独的命名空间后，从该进程的角度来看，改变全局属性不会传播到父进程的命名空间，同样的父进程的修改也不会传播到子进程。但是对于文件系统，情况会比较复杂，强大的共享机制带来了大量的可能性，但这不是本文的重点，因此让我们忽略这一部分。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>想象一下，在Linux下实现一个命名空间，需要什么呢？主要有以下两个</p>
<ol>
<li>如果一个子系统需要实现命名空间，那么它需要一个特定的命名空间结构，该结构能将之前该子系统的所有全局资源包装到命名空间中</li>
<li>上面一步只是实现了命名空间，单独的命名空间是没有意义的，因此还需要有一种机制把进程关联到所属的各个命名空间中。<br>如果一个子系统实现了命名空间，那么该子系统此前的全局属性都必须封装到命名空间中，并且每个进程关联到一个选定的命名空间。Linux是如何实现的呢？Linux通过<code>nsproxy</code>结构体，将目前版本下的6个支持命名空间的子系统数据结构汇集在一起，然后将<code>nsproxy</code>作为进程结构体的一个字段。这样一来，进程就能够感知到内核目前支持命名空间的子系统了。</li>
</ol>
<p><code>nsproxy</code>结构体如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;                    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> 	     *<span class="title">net_ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>count</code>: 引用计数器，记录了引用该nsproxy的进程个数量</li>
<li><code>uts_ns</code>:UTS命名空间</li>
<li><code>ipc_ns</code>:Linux IPC命名空间(进程间通信)</li>
<li><code>mnt_ns</code>:已装载的文件系统视图</li>
<li><code>pid_ns</code>:进程ID命名空间</li>
<li><code>user_ns</code>: 用户命名空间，目前版本的内核中只是保存了用于限制用户资源使用的信息</li>
<li><code>net_ns</code>：网络相关的命名空间参数</li>
</ul>
<p>本文会对<code>UTS命名空间</code>、<code>用户命名空间</code>以及<code>PID命名空间</code>进行介绍，其他的命名空间以后介绍到相应内核子系统时再分析。</p>
<p>前面说过，使用fork或clone创建新进程时可以通过标志创建新命名空间，每个命名空间都有相应的标志，这些标志如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   CLONE_NEWUTS   0x04000000 /\* New utsname group? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   CLONE_NEWIPC   0x08000000 /\* New ipcs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   CLONE_NEWUSER   0x10000000 /\* New user namespace */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   CLONE_NEWPID   0x20000000 /\* New pid namespace */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   CLONE_NEWNET   0x40000000 /\* New network namespace */</span></span><br></pre></td></tr></table></figure>

<p>回顾前面<code>task_struct</code>结构中的<code>nsproxy</code>结构体，可以发现用到了指针，这样一来，当多个进程共享一组子命名空间时，修改了给定的命名空间，那么对所有该命名空间的进程都是可见的。</p>
<p>对Linux命名空间的支持必须在编译时启用，而且需要逐一指定需要支持的命名空间。但是如果没有启用命名空间或者没有指定某个子系统的命名空间，Linux会将进程关联到一个默认命名空间。例如：如果没有启动命名空间，那么Linux所有的进程都属于一个默认命名空间，因此此前所有的全局属性此时仍然是全局的。这样做的好处就是无论内核编译时是否支持命名空间，内核代码都不用改动。</p>
<p><code>init_nsproxy</code>定义了初始全局命名空间，位于<code>kernel/nsproxy.h</code>下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span> = <span class="title">INIT_NSPROXY</span>(<span class="title">init_nsproxy</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于include/linux/init_task.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_NSPROXY(nsproxy) &#123;						\</span></span><br><span class="line">	.pid_ns		= &amp;init_pid_ns,					\</span><br><span class="line">	.count		= ATOMIC_INIT(<span class="number">1</span>),				\</span><br><span class="line">	.uts_ns		= &amp;init_uts_ns,					\</span><br><span class="line">	.mnt_ns		= <span class="literal">NULL</span>,						\</span><br><span class="line">	INIT_NET_NS(net_ns)                                             \</span><br><span class="line">	INIT_IPC_NS(ipc_ns)						\</span><br><span class="line">	.user_ns	= &amp;init_user_ns,				\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UTS命名空间"><a href="#UTS命名空间" class="headerlink" title="UTS命名空间"></a>UTS命名空间</h3><p>UTS命名空间基本不需要什么复杂的结构来表示，因为该命名空间本身包含的信息就比较简单，也不需要层次化结构。该命名空间管理的信息如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">new_utsname</span> <span class="title">name</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>   <span class="title">new_utsname</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span>   sysname[<span class="number">65</span>]; </span><br><span class="line"> <span class="keyword">char</span>   nodename[<span class="number">65</span>];   </span><br><span class="line"> <span class="keyword">char</span>   release[<span class="number">65</span>];</span><br><span class="line"> <span class="keyword">char</span>   version[<span class="number">65</span>];</span><br><span class="line"> <span class="keyword">char</span>   machine[<span class="number">65</span>];</span><br><span class="line"> <span class="keyword">char</span>   domainname[<span class="number">65</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> <span class="title">init_uts_ns</span> = &#123;</span></span><br><span class="line">	.kref = &#123;</span><br><span class="line">		.refcount	= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	.name = &#123;</span><br><span class="line">		.sysname	= UTS_SYSNAME,</span><br><span class="line">		.nodename	= UTS_NODENAME,</span><br><span class="line">		.release	= UTS_RELEASE,</span><br><span class="line">		.version	= UTS_VERSION,</span><br><span class="line">		.machine	= UTS_MACHINE,</span><br><span class="line">		.domainname	= UTS_DOMAINNAME,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kref</code>:引用计数器，记录内核有多少地方使用了该实例</li>
<li><code>new_utsname</code>:包含了UTS命名空间管理的属性，可以使用uname获取这些信息，初始设置如上所示</li>
</ul>
<p>那么要如何创建一个新的UTS命名空间呢？该功能由copy_utsname函数实现，在fork系统调用并且传递了<code>CLONE_NEWUTS</code>标识时，则调用该函数，该函数主要作用是生成父进程uts_namespace的一个副本然后赋值给子进程，这样以来，父进程的修改就无法反映到子进程，子进程也不会影响父进程了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct uts_namespace *<span class="title">copy_utsname</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, struct uts_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">new_ns</span>;</span></span><br><span class="line"></span><br><span class="line">	BUG_ON(!old_ns);</span><br><span class="line">    <span class="comment">// 将old_ns的引用计数器+1</span></span><br><span class="line">	get_uts_ns(old_ns);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有设置CLONE_NEWUTS标志，那么父子进程共享该命名空间</span></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CLONE_NEWUTS))</span><br><span class="line">		<span class="keyword">return</span> old_ns;</span><br><span class="line">    <span class="comment">// 拷贝父进程命名空间的副本</span></span><br><span class="line">	new_ns = clone_uts_ns(old_ns);</span><br><span class="line">    <span class="comment">// old_ns的引用计数器-1</span></span><br><span class="line">	put_uts_ns(old_ns);</span><br><span class="line">	<span class="keyword">return</span> new_ns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct uts_namespace *<span class="title">clone_uts_ns</span><span class="params">(struct uts_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="comment">// 申请内存存放新的uts命名空间结构</span></span><br><span class="line">	ns = kmalloc(<span class="keyword">sizeof</span>(struct uts_namespace), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ns)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="comment">// 信号量-1，临界区</span></span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">    <span class="comment">// 拷贝符进程uts_namespace</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;ns-&gt;name, &amp;old_ns-&gt;name, <span class="keyword">sizeof</span>(ns-&gt;name));</span><br><span class="line">    <span class="comment">// 信号量+1</span></span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line">	kref_init(&amp;ns-&gt;kref);</span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户命名空间"><a href="#用户命名空间" class="headerlink" title="用户命名空间"></a>用户命名空间</h3><p>用户命名空间的管理类似于UTS，也不需要层次化，在要求创建新的用户命名空间时，生成父进程的一份拷贝，并关联到当前进程的nsproxy实例，用户命名空间结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">uidhash_table</span>[<span class="title">UIDHASH_SZ</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>	*<span class="title">root_user</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> __count;	<span class="comment">/* reference count */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> processes;	<span class="comment">/* How many processes does this user have? */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> files;		<span class="comment">/* How many open files does this user have? */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> sigpending;	<span class="comment">/* How many pending signals does this user have? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INOTIFY_USER</span></span><br><span class="line">	<span class="keyword">atomic_t</span> inotify_watches; <span class="comment">/* How many inotify watches does this user have? */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> inotify_devs;	<span class="comment">/* How many inotify devs does this user have opened? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_POSIX_MQUEUE</span></span><br><span class="line">	<span class="comment">/* protected by mq_lock	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mq_bytes;	<span class="comment">/* How many bytes can be allocated to mqueue? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> locked_shm; <span class="comment">/* How many pages of mlocked shm ? */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">uid_keyring</span>;</span>	<span class="comment">/* UID specific keyring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">session_keyring</span>;</span>	<span class="comment">/* UID's default session keyring */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hash table maintenance information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">uidhash_node</span>;</span></span><br><span class="line">	<span class="keyword">uid_t</span> uid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_USER_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_attribute</span> <span class="title">user_attr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kref</code>:引用计数器</li>
<li><code>hlist_head</code>:hash表头，可以通过hash表快速访问指定的user_struct实例，可以看到user_struct中包含了<code>hlist_node</code>字段</li>
<li><code>user_struct</code>:这里不必对该结构的内容深究，只需要知道该结构维护了一些统计信息，用于记录该用户的资源使用信息</li>
</ul>
<p>每个用户命名空间在对属于该命名空间的用户资源使用进行统计时与其他命名空间完全无关，对root用户的统计也是如此。因为在创建新用户命名空间时，为新的命名空间创建了当前用户和root用户的user_struct实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct user_namespace *<span class="title">clone_user_ns</span><span class="params">(struct user_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">new_user</span>;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">	ns = kmalloc(<span class="keyword">sizeof</span>(struct user_namespace), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ns)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="comment">// 初始化引用计数器为1</span></span><br><span class="line">	kref_init(&amp;ns-&gt;kref);</span><br><span class="line">    <span class="comment">// 初始化hash表</span></span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; UIDHASH_SZ; ++n)</span><br><span class="line">		INIT_HLIST_HEAD(ns-&gt;uidhash_table + n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新的命名空间创建新的root用户</span></span><br><span class="line">	ns-&gt;root_user = alloc_uid(ns, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ns-&gt;root_user) &#123;</span><br><span class="line">		kfree(ns);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新的命名空间创建新的当前用户</span></span><br><span class="line">	new_user = alloc_uid(ns, current-&gt;uid);</span><br><span class="line">	<span class="keyword">if</span> (!new_user) &#123;</span><br><span class="line">		free_uid(ns-&gt;root_user);</span><br><span class="line">		kfree(ns);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将task_struct.user字段指向新的当前用户实例</span></span><br><span class="line">	switch_uid(new_user);</span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc_uid</code>是一个辅助函数，给定一个用户命名空间和一个uid，判断当前命名空间内是否包含该uid，如果包含则返回该uid对应的user_struct，如果不包含则创建新的user_struct实例并插入到当前命名空间中。</p>
<p>如果内核编译时没有启用用户命名空间，那么复制用户命名空间其实是一个空操作，即整体系统只有一个命名空间，那就是默认命名空间。</p>
<h2 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h2><p>Linux进程总会分配一个ID用于在其进程命名空间中唯一的标识它们。该号码被称为进程ID号，简称PID。用fork或clone产生的每个进程都由内核自动地分配了一个新的PID。</p>
<h3 id="进程ID-1"><a href="#进程ID-1" class="headerlink" title="进程ID"></a>进程ID</h3><p>每个进程除了PID这个标识之外，还有其他的ID。</p>
<ul>
<li>处于某个线程组中的所有进程都用相同的线程组ID(TGID)，并且等于线程组领头进程的PID，对于进程而言，它的TGID等于PID。另外线程组中每个线程结构题的<code>group_leader</code>字段指向线程组的领头进程</li>
<li>若干个独立进程也可以合并成一个进程组(使用setpgrp系统调用)，一个进程组中，所有进程的pgrp属性都是相通的，就是进程组组长的PID。进程组的存在大大简化了向一个组中所有成员发送信号的操作。例如：shell脚本中管道连接的多个进程就属于同一个进程组</li>
<li>几个进程组可以合并成一个会话，会话中所有进程都具有相同的会话ID，保存在<code>task_struct</code>的<code>session</code>字段中。可以使用setsid系统调用设置sid。</li>
</ul>
<p>上面说的会话ID和进程组ID并不是直接包含在task_struct中，而是包含在<code>task_struct.signal</code>中，用于信号处理。而PID和TGID是直接保存在<code>task_struct</code>结构中的</p>
<p>在没有命名空间时，进程就有好几种不同的ID，添加了命名空间后，进程ID的管理就更加复杂了。PID命名空间按照层次组织。在建立一个新的PID命名空间时，新命名空间中所有的PID对父命名空间都是可见的，但子命名空间无法看到父命名空间的PID。这意味着一个进程可能有多个PID，因为凡是可以看到该进程的命名空间，都会给该进程分配一个PID。因此我们对这些ID进行区分</p>
<ul>
<li>全局ID: 内核本身和初始化PID命名空间中的唯一ID号，在系统启动过程中开始的init进程即属于初始命名空间。对每个ID类型，都有给定的全局ID，在整个系统内唯一</li>
<li>局部ID: 属于某个特定的命名空间，全局不唯一，但是命名空间内部唯一</li>
</ul>
<h3 id="PID管理"><a href="#PID管理" class="headerlink" title="PID管理"></a>PID管理</h3><p>除了上一节说到的task_struct中的两个字段用来管理PID、TGID之外，内核还需要找一个办法来管理所有命名空间内部的局部量，以及其他ID(TID、SID)。这需要几个互相连接的数据结构，以及一些辅助函数</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>在本节中，我将使用ID来代指提到的任何进程ID，在必要时，会明确的说明ID类型(例如TGID、PID等)。Linux有一个被称为<code>PID分配器</code>的小型子系统。该子系统用户加速新ID的分配。此外内核需要提供辅助函数，从而实现通过<code>ID</code>及<code>类型</code>查找对应进程的<code>task_struct</code>功能、以及将ID的内核表示形式和用户空间可见的数值进行转换功能。</p>
<h5 id="PID命名空间"><a href="#PID命名空间" class="headerlink" title="PID命名空间"></a>PID命名空间</h5><p>在介绍ID本身需要的数据结构之前，先介绍一下PID命名空间，结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pidmap</span> <span class="title">pidmap</span>[<span class="title">PIDMAP_ENTRIES</span>];</span></span><br><span class="line">	<span class="keyword">int</span> last_pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span></span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">proc_mnt</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kref</code>: 引用计数器</li>
<li><code>pidmap &amp; last_pid</code>: 用于生成命名空间内唯一连续PID</li>
<li><code>child_reaper</code>: 每个PID命名空间内都有一个进程，发挥的作用类似于全局的init进程(PID为1)，该进程的一个作用就是对孤儿进程调用wait4系统调用，该字段就指向命名空间内部的init进程</li>
<li><code>pid_cachep</code>: slab高速缓存，用于快速分配pid结构体(后面会说到)</li>
<li><code>level &amp; parent</code>:前面说过，PID命名空间是层次化的，因此level表明了当前命名空间的层次、parent指向当前命名空间的父命名空间。</li>
</ul>
<h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><p>PID的管理主要由一下数据结构完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_pid */</span></span><br><span class="line">	<span class="keyword">int</span> nr;                         <span class="comment">// ID的数值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span>       <span class="comment">// 指向该ID所属的命名空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span>    <span class="comment">// 所有的upid实例都保存在散列表中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;                            <span class="comment">// 引用计数器</span></span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span>      <span class="comment">// 一个数组，没个数组项都是一个散列表头，对应一种PID类型</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>                       <span class="comment">// rcu机制使用</span></span><br><span class="line">	<span class="keyword">int</span> level;                                 <span class="comment">// 该PID所属命名空间的层次</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span>                    <span class="comment">// upid实例的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span>    <span class="comment">// 数组，每个元素指向一种类型的ID的pid结构</span></span><br><span class="line">    ....    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node</span>;</span>              <span class="comment">// hash节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span>                     <span class="comment">// 指向pid结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">pid_hash</span>       // 内核变量，由<span class="title">pidhash_init</span>初始化成一个数组，从而组成一个<span class="title">hash</span>散列表</span></span><br></pre></td></tr></table></figure>

<p>上述结构设计到的结构比较多，如果用语言介绍的话，很容易就迷糊了，因此我们通过下面一张图来说明这些结构之间的关系:<br><img src="2.png" alt><br>通过图我们很容易看到进程、PID命名空间、pid结构、upid之间的关系。可以看到，一个进程对应一个pid实例，pid实例中并不包含pid数值，pid结构中包含了所有能看到该进程的命名空间对应的upid，每个upid实例保存了进程在指定PID命名空间中的PID值，并且所有的upid都保存在名为<code>pid_hash</code>的hash表中，通过hash表能够快速的找到指定的upid，从而找到pid，进而找到task。到这里你可能有疑惑，upid命名没有指向pid的指针，怎么通过upid找到pid呢？upid虽然没有指向pid的指针，但是upid包含在pid中，Linux通过container_of机制，根据upid就能够找到指定的pid实例。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>前面一小节对PID管理的各个数据结构以及它们之间的关系进行了介绍，相信它们之间的关系你已经有所理解，本节主要介绍内核提供的用来操作和扫描上述数据结构的辅助函数，实际上内核需要完成两个任务</p>
<ol>
<li>给定<code>&lt;局部数字ID，命名空间&gt;</code>，找到对应的<code>task_struct</code></li>
<li>给定<code>&lt;task_struct, ID类型, 命名空间</code>，找到对应的数字ID</li>
</ol>
<p>实际上通过上图，应该不难理解如何实现这样的功能，下面就介绍内核用来实现这两个任务的辅助函数</p>
<h5 id="任务1"><a href="#任务1" class="headerlink" title="任务1"></a>任务1</h5><p>通过上图可以很容易理解，通过给定的<code>task_struct</code>和<code>ID类型</code>, 查找task_struct指定类型的pids元素，可以找到对应的pid实例，通过pid实例和pid_namespace实例，很容易可以找到对应的upid，从而找到对应的pid数字</p>
<p>内核有以下几个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_nr_ns(struct pid *pid, struct pid_namespace *ns): 给定pid实例和ns实例，找到对应的PID数值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> pid_t <span class="title">pid_vnr</span><span class="params">(struct pid *pid)</span> </span>&#123;&#125;: 返回该pid实例所属命名空间看到的PID数值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> pid_t <span class="title">pid_nr</span><span class="params">(struct pid *pid)</span></span>&#123;&#125;: 返回从init进程所在的全局命名空间所看到的PID，这里说的init进程时系统初始化过程中启动的属于全局命名空间的init进程，并且子命名空间内的</span><br></pre></td></tr></table></figure>

<h5 id="任务2"><a href="#任务2" class="headerlink" title="任务2"></a>任务2</h5><p> 现在来看看如何根据给定的进程局部PID和所属的命名空间，确定一个pid实例。根据图可以看到，所有的upid都在一个hash表中，那么我们可以根据<code>&lt;局部PID，命名空间&gt;</code>，在散列表中找到指定的upid实例，通过upid实例，再通过内核的container_of机制，就能够轻松的找到该upid所在的pid实例了，通过pid实例，进而还能找到pid所属的进程结构体<code>task_struct</code>。</p>
<h4 id="生成唯一PID"><a href="#生成唯一PID" class="headerlink" title="生成唯一PID"></a>生成唯一PID</h4><p> 除了管理PID之外，内核还需要提供生成唯一PID的功能。此时可以忽略各种不同类别的ID之间的区别，因为按照Unix概念来说，只需要为PID生成唯一的数值，其他ID都可以派生自PID。</p>
<p> 通过上图可以发现，每个PID命名空间都有两个和PID分配相关的字段，为了跟踪指定命名空间中已经分配和仍然可用的PID，内核使用一个大的位图，其中每个PID由一个bit标识。PID的值可通过对应bit位在位图中的位置计算而来。因此，分配一个空闲的PID，本质上就是寻找位图中第一个值为0的bit，然后将该bit置1。而释放一个PID就是将对应的bit位置0。申请和释放PID函数如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定命名空间申请新的PID</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_pidmap</span><span class="params">(struct pid_namespace *pid_ns)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定命名空间的PID</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> fastcall <span class="keyword">void</span> <span class="title">free_pidmap</span><span class="params">(struct pid_namespace *pid_ns, <span class="keyword">int</span> pid)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在建立一个新进程时，进程可能在多个命名空间是可见的，因此对于每一个可以看到该进程的命名空间，都需要为该进程生成一个局部PID，该操作在alloc_pid中实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pid *<span class="title">alloc_pid</span><span class="params">(struct pid_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">	<span class="keyword">enum</span> pid_type type;</span><br><span class="line">	<span class="keyword">int</span> i, nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">upid</span> *<span class="title">upid</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从pid_namespace实例的cache中申请一个pid实例</span></span><br><span class="line">	pid = kmem_cache_alloc(ns-&gt;pid_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pid)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	tmp = ns;</span><br><span class="line">    <span class="comment">// 对于当前命名空间的上级空间，该进程都是可见的，因此都需要分配局部PID</span></span><br><span class="line">	<span class="keyword">for</span> (i = ns-&gt;level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 从PID位图中申请局部PID</span></span><br><span class="line">		nr = alloc_pidmap(tmp);</span><br><span class="line">		<span class="keyword">if</span> (nr &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成对应的upid实例保存到pid.numbers数组中</span></span><br><span class="line">		pid-&gt;numbers[i].nr = nr;</span><br><span class="line">		pid-&gt;numbers[i].ns = tmp;</span><br><span class="line">		tmp = tmp-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加当前命名空间的引用计数</span></span><br><span class="line">	get_pid_ns(ns);</span><br><span class="line">	pid-&gt;level = ns-&gt;level;</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">	atomic_set(&amp;pid-&gt;count, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化pid实例字段</span></span><br><span class="line">	<span class="keyword">for</span> (type = <span class="number">0</span>; type &lt; PIDTYPE_MAX; ++type)</span><br><span class="line">		INIT_HLIST_HEAD(&amp;pid-&gt;tasks[type]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋锁 + 关中断(多处理器下)</span></span><br><span class="line">	spin_lock_irq(&amp;pidmap_lock);</span><br><span class="line">	<span class="keyword">for</span> (i = ns-&gt;level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		upid = &amp;pid-&gt;numbers[i];</span><br><span class="line">        <span class="comment">// 将新pid实例下的每个upid实例添加到pid_hash中</span></span><br><span class="line">		hlist_add_head_rcu(&amp;upid-&gt;pid_chain,</span><br><span class="line">				&amp;pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 解锁 + 开中断</span></span><br><span class="line">	spin_unlock_irq(&amp;pidmap_lock);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line">	<span class="keyword">for</span> (i++; i &lt;= ns-&gt;level; i++)</span><br><span class="line">		free_pidmap(pid-&gt;numbers[i].ns, pid-&gt;numbers[i].nr);</span><br><span class="line"></span><br><span class="line">	kmem_cache_free(ns-&gt;pid_cachep, pid);</span><br><span class="line">	pid = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h3><p>在Linux中，进程关系有下面这样的规则</p>
<ol>
<li>如果进程A fork生成进程B，那么进程A为进程B的父进程，进程B是进程A的子进程。</li>
<li>如果进程A再次fork生成进程C，那么进程C是进程A的子进程，是进程B的兄弟进程。</li>
</ol>
<p>回顾本节开始的进程结构<code>task_struct</code>，可以发现有以下两个字段用于表示进程关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>children</code>:链表表头，该链表保存该进程所有的子进程</li>
<li><code>sibling</code>:属于同一个父进程的兄弟进程通过该链表连接，其中第一个子进程的<code>sibling.prev</code>指向父进程，最后一个子进程的<code>sibling.next</code>指向父进程。</li>
</ul>
<h2 id="进程相关系统调用"><a href="#进程相关系统调用" class="headerlink" title="进程相关系统调用"></a>进程相关系统调用</h2><p>在本节中，将着重讨论fork和exec系统调用的实现。通常这些调用不是由应用程序直接调用的，而是被标准库包装后提供给应用程序使用。Linux从用户态切换到核心态的方法在不同的硬件体系上有所区别，后面会介绍x86下的切换细节，但是这部分不是本文的重点，因此不做介绍，目前只需要知道执行系统调用时程序会进入内核态执行即可。</p>
<h3 id="进程复制"><a href="#进程复制" class="headerlink" title="进程复制"></a>进程复制</h3><p>传统Unix中用于复制进程的系统调用时fork。Linux复制进程的方式不止这一个，一共有三个，分别是</p>
<ol>
<li><code>fork</code>:建立一个父进程的完整副本，然后作为子进程执行，为了减少工作量，加快速度，Linux使用了写时复制技术，后面会简单介绍。</li>
<li><code>vfork</code>:类似于fork，但是并不创建父进程的副本，而是由父子进程共享数据。这节省了大量的CPU时间。vfork一般用于子进程形成后立刻执行execve系统调用加载程序的情形。在子进程退出或开始新程序之前，内核保证父进程处于阻塞状态。在fork采用写时复制之后，vfork相比于fork没有太多的优势，一般不使用</li>
<li><code>clone</code>:产生线程</li>
</ol>
<h4 id="写时复制-COW"><a href="#写时复制-COW" class="headerlink" title="写时复制(COW)"></a>写时复制(COW)</h4><p>内核使用了写时复制技术，以防止在fork执行时内核将父进程所有数据都拷贝一份给子进程。该技术基于以下原理：进程通常只使用了其内存页的一小部分。传统Unix在调用fork时对父进程的每个内存页，都为子进程创建一个相同的副本，这会造成很不好的后果：</p>
<ol>
<li>使用了大量内存</li>
<li>复制操作耗费很长时间</li>
</ol>
<p>并且如果子进程在产生后使用exec系统调用立即加在新程序，那么负面效应会更加严重。这就意味着fork中的复制是多余的，因为进程地址空间会重新初始化，复制的数据不再需要了。</p>
<p>内核使用技巧避免了这种问题，并不复制进程整个地址空间，而是只复制页表，这样就建立了虚拟地址和物理内存页之间的关系。在复制页表后，父子进程不允许修改彼此的页(除了明确指定共享的页之外)。内核通过将两个进程的页表标记为只读访问来实现。</p>
<p>如果两个进程只能读取其内存页，那么二者之间数据共享是可以的，因为不存在数据共享，只要一个进程试图向内存页写入，那么由于页表只读，此时硬件会产生一个页错误异常，内核会捕获到该异常，内核会进行判断，如果发现是写时复制页，那么内核会创建该页专用于当前进程的副本，这时进程就能够进行正常的写操作了。COW技术及可能的延迟了内存页的复制，由于进程执行的局部性特点，许多页其实不需要复制，这节省了大量CPU时间。</p>
<h4 id="执行系统调用"><a href="#执行系统调用" class="headerlink" title="执行系统调用"></a>执行系统调用</h4><p><code>fork</code>、<code>vfork</code>以及<code>clone</code>系统调用的入口点分别是<code>sys_fork</code>、<code>sys_vfork</code>以及<code>sys_clone</code>，具体的定义依赖硬件的不同有所不同，因为在用户空间和内核空间传递参数的方式在不同的硬件上可能有差异。上述函数的任务主要是从处理器寄存器中提取由用户空间提供的信息，然后调用硬件无关的<code>do_fork</code>函数。</p>
<p>以x86平台为例，它的sys_fork如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_fork(SIGCHLD, regs.esp, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中SIGCHLD标志意味着子进程终止后发送SIGCHLD信号</span></span><br><span class="line"><span class="comment">// 通知父进程。</span></span><br></pre></td></tr></table></figure>

<p>可以看到在x86(32)下，不需要额外的操作，可以直接调用do_fork函数。</p>
<h5 id="do-fork"><a href="#do-fork" class="headerlink" title="do_fork"></a>do_fork</h5><p><code>do_fork</code>函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">	      struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">int</span> __user *child_tidptr)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>clone_flags</code>:标识集合，用来指定复制过程的一些属性</li>
<li><code>stask_start</code>:用户状态下栈起始地址</li>
<li><code>regs</code>:指向寄存器集合指针，其中以原始形式保存了调用参数，按照系统调用执行时寄存器在内核栈上的存储顺序，保存了所有寄存器，其中也包括了切换到内核态时由硬件自动保存的寄存器信息(x86平台)</li>
<li><code>stack_size</code>:用户状态下栈大小，通常不使用，置0</li>
<li><code>parent_tidptr &amp; child_tidptr</code>:是指向用户空间中地址的两个指针，分别指向父子进程的PID</li>
</ol>
<p><code>do_fork</code>实现非常复杂，涉及到内存、信号、文件等多个子系统，因此下面在介绍实现时，对于涉及到具体子系统的部分，只是会简单介绍功能而不会深入细节，具体细节会在介绍相应子系统时重新介绍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">	      struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> nr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前进程(也就是父进程)的ptrace调试标志不为0</span></span><br><span class="line">    <span class="comment">// 说明父进程正在被跟踪调试，那么检查子进程是否需要被跟踪</span></span><br><span class="line">    <span class="comment">// 如果需要则置CLONE_PTRACE标志位</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(current-&gt;ptrace)) &#123;</span><br><span class="line">		trace = fork_traceflag (clone_flags);</span><br><span class="line">		<span class="keyword">if</span> (trace)</span><br><span class="line">			clone_flags |= CLONE_PTRACE;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心工作，后面单独介绍</span></span><br><span class="line">	p = copy_process(clone_flags, stack_start, regs, stack_size,</span><br><span class="line">			child_tidptr, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do this prior waking up the new thread - the thread pointer</span></span><br><span class="line"><span class="comment">	 * might get invalid after that point, if the thread exits quickly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * this is enough to call pid_nr_ns here, but this if</span></span><br><span class="line"><span class="comment">		 * improves optimisation of regular fork()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 获取新进程PID数值(根据是否生成了新的命名空间，获取方式有所不同)</span></span><br><span class="line">		nr = (clone_flags &amp; CLONE_NEWPID) ?</span><br><span class="line">			task_pid_nr_ns(p, current-&gt;nsproxy-&gt;pid_ns) :</span><br><span class="line">				task_pid_vnr(p);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果设置了CLONE_PARENT_SETTID，则把子进程PID放到父进程用户空间指定地址</span></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">			put_user(nr, parent_tidptr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果使用vfork，那么父进程需要阻塞直至子进程调用execve或exit</span></span><br><span class="line">        <span class="comment">// 这里设置子进程的vfork_done并初始化，后面可以看到父进程会在</span></span><br><span class="line">        <span class="comment">// vfork上睡眠，这样子进程就能在合适的时候唤醒父进程了。</span></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">			init_completion(&amp;vfork);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果处于调试状态或设置了CLONE_STOPPED，那么设置子进程SIGSTOP标志</span></span><br><span class="line">        <span class="comment">// 并设置TIF_SIGPENDING标志，这样当子进程从内核态返回时就会处理该信号</span></span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;ptrace &amp; PT_PTRACED) || (clone_flags &amp; CLONE_STOPPED)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We'll start up with an immediate SIGSTOP.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			sigaddset(&amp;p-&gt;pending.signal, SIGSTOP);</span><br><span class="line">			set_tsk_thread_flag(p, TIF_SIGPENDING);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有设置STOP标志，那么调用wake_up_new_task唤醒新进程</span></span><br><span class="line">        <span class="comment">// 该函数将新进程添加到调度器队列中，调度器可能会对新进程特殊处理</span></span><br><span class="line">        <span class="comment">// 使其尽快执行。(对子进程调度器相关信息初始化在操作在copy_process中)</span></span><br><span class="line">		<span class="keyword">if</span> (!(clone_flags &amp; CLONE_STOPPED))</span><br><span class="line">			wake_up_new_task(p, clone_flags);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果设置了STOP标志，则修改新进程状态</span></span><br><span class="line">			p-&gt;state = TASK_STOPPED;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跟踪调试相关</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely (trace)) &#123;</span><br><span class="line">			current-&gt;ptrace_message = nr;</span><br><span class="line">            <span class="comment">// 信号相关函数，使当前进程停止运行，并且向当前进程的父进程</span></span><br><span class="line">            <span class="comment">// 也就是debugger进程发送SIGTRAP, 并且可以在ptrace_message中</span></span><br><span class="line">            <span class="comment">// 找到子进程的pid</span></span><br><span class="line">			ptrace_notify ((trace &lt;&lt; <span class="number">8</span>) | SIGTRAP);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果使用了vfork，那么阻塞父进程</span></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			freezer_do_not_count();</span><br><span class="line">            <span class="comment">// 可以看到，如果使用了vfork，父进程最终会在这里睡眠</span></span><br><span class="line">            <span class="comment">// 等待子进程唤醒</span></span><br><span class="line">			wait_for_completion(&amp;vfork);</span><br><span class="line">			freezer_count();</span><br><span class="line">			<span class="keyword">if</span> (unlikely (current-&gt;ptrace &amp; PT_TRACE_VFORK_DONE)) &#123;</span><br><span class="line">                <span class="comment">// 同样的向当前进程的debugger进程发送信号</span></span><br><span class="line">				current-&gt;ptrace_message = nr;</span><br><span class="line">				ptrace_notify ((PTRACE_EVENT_VFORK_DONE &lt;&lt; <span class="number">8</span>) | SIGTRAP);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nr = PTR_ERR(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>do_fork</code>函数内部逻辑并不复杂，主要逻辑已经在代码中注释了，下面继续梳理一下</p>
<ol>
<li>判断新进程是否需要被跟踪调试</li>
<li>调用核心逻辑<code>copy_process</code>函数</li>
<li>如果设置了调试标志或停止标志，那么设置子进程的SIGSTOP信号，并设置TIF_SIGPENDING，表明子进程有挂起信号待处理，SIGSTOP信号会使得子进程被停止</li>
<li>如果子进程没有被设置STOP标志，那么调用wake_up_new_task，把新进程插入到就绪队列中，否则设置子进程标识为STOP</li>
<li>如果设置了vfork标志，那么阻塞父进程，直到子进程唤醒后父进程才能继续执行。</li>
</ol>
<p>主要的拷贝逻辑都在<code>copy_process</code>中，让我们来看一下该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cgroup_callbacks_done = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确性校验，如果即要创建新的命名空间，又要共享文件系统信息，这是不合法的</span></span><br><span class="line">	<span class="keyword">if</span> ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Thread groups must share signals as well, and detached threads</span></span><br><span class="line"><span class="comment">	 * can only be started up within the thread group.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 创建线程时必须要激活共享信号</span></span><br><span class="line">	<span class="keyword">if</span> ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Shared signal handlers imply shared VM. By way of the above,</span></span><br><span class="line"><span class="comment">	 * thread groups also imply shared VM. Blocking this case allows</span></span><br><span class="line"><span class="comment">	 * for various simplifications in other code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 只有父子进程共享了虚拟地址空间，才能够共享信号信号处理程序</span></span><br><span class="line">	<span class="keyword">if</span> ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Linux 安全模块(LSM)钩子，可以注册，如果没有注册则空操作</span></span><br><span class="line">	retval = security_task_create(clone_flags);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> fork_out;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">    <span class="comment">// 拷贝父进程</span></span><br><span class="line">	p = dup_task_struct(current);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">	rt_mutex_init_task(p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	DEBUG_LOCKS_WARN_ON(!p-&gt;hardirqs_enabled);</span><br><span class="line">	DEBUG_LOCKS_WARN_ON(!p-&gt;softirqs_enabled);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	retval = -EAGAIN;</span><br><span class="line">    <span class="comment">// 判断当前用户进程数是否超过最大限制</span></span><br><span class="line">    <span class="comment">// 如果超出则判断当前用户是否有权限增大限制，如果没有则失败</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_read(&amp;p-&gt;user-&gt;processes) &gt;=</span><br><span class="line">			p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!capable(CAP_SYS_ADMIN) &amp;&amp; !capable(CAP_SYS_RESOURCE) &amp;&amp;</span><br><span class="line">		    p-&gt;user != current-&gt;nsproxy-&gt;user_ns-&gt;root_user)</span><br><span class="line">			<span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改引用计数器和用户进程数</span></span><br><span class="line">	atomic_inc(&amp;p-&gt;user-&gt;__count);</span><br><span class="line">	atomic_inc(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">	get_group_info(p-&gt;group_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If multiple threads are within copy_process(), then this check</span></span><br><span class="line"><span class="comment">	 * triggers too late. This doesn't hurt, the check is only there</span></span><br><span class="line"><span class="comment">	 * to stop root fork bombs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// nr_threads表示系统中当前进程数(不包括idle)</span></span><br><span class="line">    <span class="comment">// max_threds表示系统最大进程数</span></span><br><span class="line">    <span class="comment">// 如果超过则报错</span></span><br><span class="line">	<span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模块相关，忽略</span></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(task_thread_info(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;binfmt &amp;&amp; !try_module_get(p-&gt;binfmt-&gt;<span class="keyword">module</span>))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_put_domain;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进程创建完没有被执行过，置0</span></span><br><span class="line">	p-&gt;did_exec = <span class="number">0</span>;</span><br><span class="line">	delayacct_tsk_init(p);	<span class="comment">/* Must remain after dup_task_struct() */</span></span><br><span class="line">	copy_flags(clone_flags, p);</span><br><span class="line">    <span class="comment">// 初始化字段</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;children);</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;sibling);</span><br><span class="line">	p-&gt;vfork_done = <span class="literal">NULL</span>;</span><br><span class="line">	spin_lock_init(&amp;p-&gt;alloc_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除父进程拷贝过来的标志位</span></span><br><span class="line">	clear_tsk_thread_flag(p, TIF_SIGPENDING);</span><br><span class="line">	init_sigpending(&amp;p-&gt;pending);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化字段</span></span><br><span class="line">	p-&gt;utime = cputime_zero;</span><br><span class="line">	p-&gt;stime = cputime_zero;</span><br><span class="line">	p-&gt;gtime = cputime_zero;</span><br><span class="line">	p-&gt;utimescaled = cputime_zero;</span><br><span class="line">	p-&gt;stimescaled = cputime_zero;</span><br><span class="line">	p-&gt;prev_utime = cputime_zero;</span><br><span class="line">	p-&gt;prev_stime = cputime_zero;</span><br><span class="line">    </span><br><span class="line">      ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大内核锁</span></span><br><span class="line">	p-&gt;lock_depth = <span class="number">-1</span>;		<span class="comment">/* -1 = no lock */</span></span><br><span class="line">    <span class="comment">// 舒适化start_time和real_start_time</span></span><br><span class="line">	do_posix_clock_monotonic_gettime(&amp;p-&gt;start_time);</span><br><span class="line">	p-&gt;real_start_time = p-&gt;start_time;</span><br><span class="line">	monotonic_to_bootbased(&amp;p-&gt;real_start_time);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Perform scheduler related setup. Assign this task to a CPU. */</span></span><br><span class="line">    <span class="comment">// 设置调度器相关信息，为进行重新设置调度器类，</span></span><br><span class="line">    <span class="comment">// 初始化调度实体等..</span></span><br><span class="line">	sched_fork(p, clone_flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LSM钩子</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = security_task_alloc(p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_policy;</span><br><span class="line">	<span class="keyword">if</span> ((retval = audit_alloc(p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_security;</span><br><span class="line">	<span class="comment">/* copy all the process information */</span></span><br><span class="line">    <span class="comment">// 拷贝信号量</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_semundo(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_audit;</span><br><span class="line">    <span class="comment">// 拷贝打开的文件</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_files(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">    <span class="comment">// 拷贝文件系统</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_fs(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">    <span class="comment">// 拷贝信号处理程序</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_sighand(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    <span class="comment">// 拷贝信号</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_signal(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">    <span class="comment">// 拷贝内存</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_mm(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_keys(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">    <span class="comment">// 拷贝命名空间</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = copy_namespaces(clone_flags, p)))</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_keys;</span><br><span class="line">    <span class="comment">// 拷贝thread_info信息</span></span><br><span class="line">	retval = copy_thread(<span class="number">0</span>, clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过do_fork调用时pid ==NULL</span></span><br><span class="line">	<span class="keyword">if</span> (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">        <span class="comment">// 申请新pid实例</span></span><br><span class="line">		pid = alloc_pid(task_active_pid_ns(p));</span><br><span class="line">		<span class="keyword">if</span> (!pid)</span><br><span class="line">			<span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID) &#123;</span><br><span class="line">			retval = pid_ns_prepare_proc(task_active_pid_ns(p));</span><br><span class="line">			<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取pid实例局部pid值</span></span><br><span class="line">	p-&gt;pid = pid_nr(pid);</span><br><span class="line">	p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    <span class="comment">// 如果是线程则设置线程组id为父进程的线程组id</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">		p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果设置了CLONE_CHILD_SETTID和CLONE_CHILD_CLEARTID标志的额外设置</span></span><br><span class="line">	p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear TID on mm_release()?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * sigaltstack should be cleared when sharing the same VM</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 不理解    </span></span><br><span class="line">	<span class="keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">		p-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Syscall tracing should be turned off in the child regardless</span></span><br><span class="line"><span class="comment">	 * of CLONE_PTRACE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Our parent execution domain becomes current domain</span></span><br><span class="line"><span class="comment">	   These must match for thread signalling to apply */</span></span><br><span class="line">	p-&gt;parent_exec_id = p-&gt;self_exec_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    <span class="comment">// 初始化字段</span></span><br><span class="line">	p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="number">-1</span> : (clone_flags &amp; CSIGNAL);</span><br><span class="line">	p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">	p-&gt;exit_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, make it visible to the rest of the system.</span></span><br><span class="line"><span class="comment">	 * We dont wake it up yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 初始化字段</span></span><br><span class="line">	p-&gt;group_leader = p;</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;ptrace_children);</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;ptrace_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now that the task is set up, run cgroup callbacks if</span></span><br><span class="line"><span class="comment">	 * necessary. We need to run them before the task is visible</span></span><br><span class="line"><span class="comment">	 * on the tasklist. */</span></span><br><span class="line">	cgroup_fork_callbacks(p);</span><br><span class="line">	cgroup_callbacks_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Need tasklist lock for parent etc handling! */</span></span><br><span class="line">	write_lock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for sys_ioprio_set(IOPRIO_WHO_PGRP) */</span></span><br><span class="line">	p-&gt;ioprio = current-&gt;ioprio;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The task hasn't been attached yet, so its cpus_allowed mask will</span></span><br><span class="line"><span class="comment">	 * not be changed, nor will its assigned CPU.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The cpus_allowed mask of the parent may have changed after it was</span></span><br><span class="line"><span class="comment">	 * copied first time - so re-copy it here, then check the child's CPU</span></span><br><span class="line"><span class="comment">	 * to ensure it is on a valid CPU (and if not, just force it back to</span></span><br><span class="line"><span class="comment">	 * parent's CPU). This avoids alot of nasty races.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!cpu_isset(task_cpu(p), p-&gt;cpus_allowed) ||</span><br><span class="line">			!cpu_online(task_cpu(p))))</span><br><span class="line">		set_task_cpu(p, smp_processor_id());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLONE_PARENT re-uses the old parent */</span></span><br><span class="line">    <span class="comment">// 如果设置了CLONE_PARENT或者CLONE_THREAD，则</span></span><br><span class="line">    <span class="comment">// 新进程的real_parent不等于parent</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))</span><br><span class="line">		p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		p-&gt;real_parent = current;</span><br><span class="line">	p-&gt;parent = p-&gt;real_parent;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Process group and session signals need to be delivered to just the</span></span><br><span class="line"><span class="comment">	 * parent before the fork or both the parent and the child after the</span></span><br><span class="line"><span class="comment">	 * fork. Restart if a signal comes in before we add the new process to</span></span><br><span class="line"><span class="comment">	 * it's process group.</span></span><br><span class="line"><span class="comment">	 * A fatal signal pending means that current will exit, so the new</span></span><br><span class="line"><span class="comment">	 * thread can't slip out of an OOM kill (or normal SIGKILL).</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">    <span class="comment">// 信号相关</span></span><br><span class="line">	recalc_sigpending();</span><br><span class="line">	<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">		spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">		write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">		retval = -ERESTARTNOINTR;</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果创建线程</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">		p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">		list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!cputime_eq(current-&gt;signal-&gt;it_virt_expires,</span><br><span class="line">				cputime_zero) ||</span><br><span class="line">		    !cputime_eq(current-&gt;signal-&gt;it_prof_expires,</span><br><span class="line">				cputime_zero) ||</span><br><span class="line">		    current-&gt;signal-&gt;rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||</span><br><span class="line">		    !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">0</span>]) ||</span><br><span class="line">		    !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">1</span>]) ||</span><br><span class="line">		    !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">2</span>])) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Have child wake up on its first tick to check</span></span><br><span class="line"><span class="comment">			 * for process CPU timers.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			p-&gt;it_prof_expires = jiffies_to_cputime(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 处理PID相关工作</span></span><br><span class="line">	<span class="keyword">if</span> (likely(p-&gt;pid)) &#123;</span><br><span class="line">        <span class="comment">// 将新进程添加到父进程的子进程链表中</span></span><br><span class="line">		add_parent(p);</span><br><span class="line">        <span class="comment">// 如果新进程指定了PT_PTRACED标志</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(p-&gt;ptrace &amp; PT_PTRACED))</span><br><span class="line">            <span class="comment">// 将新进程的parent指向调试进程，并且</span></span><br><span class="line">            <span class="comment">// 将新进程从原来父进程链表中移除</span></span><br><span class="line">            <span class="comment">// 添加到调试进程的链表中</span></span><br><span class="line">			__ptrace_link(p, current-&gt;parent);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (thread_group_leader(p)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID)</span><br><span class="line">				p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;</span><br><span class="line"></span><br><span class="line">			p-&gt;signal-&gt;tty = current-&gt;signal-&gt;tty;</span><br><span class="line">			set_task_pgrp(p, task_pgrp_nr(current));</span><br><span class="line">			set_task_session(p, task_session_nr(current));</span><br><span class="line">			attach_pid(p, PIDTYPE_PGID, task_pgrp(current));</span><br><span class="line">			attach_pid(p, PIDTYPE_SID, task_session(current));</span><br><span class="line">			list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">			__get_cpu_var(process_counts)++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 将前面申请的pid关联到新进程</span></span><br><span class="line">		attach_pid(p, PIDTYPE_PID, pid);</span><br><span class="line">        <span class="comment">// 增加全局进程数</span></span><br><span class="line">		nr_threads++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	total_forks++;</span><br><span class="line">	spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">	write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">	proc_fork_connector(p);</span><br><span class="line">	cgroup_post_fork(p);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误返回    </span></span><br><span class="line">bad_fork_free_pid:</span><br><span class="line">	<span class="keyword">if</span> (pid != &amp;init_struct_pid)</span><br><span class="line">		free_pid(pid);</span><br><span class="line">bad_fork_cleanup_namespaces:</span><br><span class="line">	exit_task_namespaces(p);</span><br><span class="line">bad_fork_cleanup_keys:</span><br><span class="line">	exit_keys(p);</span><br><span class="line">bad_fork_cleanup_mm:</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;mm)</span><br><span class="line">		mmput(p-&gt;mm);</span><br><span class="line">bad_fork_cleanup_signal:</span><br><span class="line">	cleanup_signal(p);</span><br><span class="line">bad_fork_cleanup_sighand:</span><br><span class="line">	__cleanup_sighand(p-&gt;sighand);</span><br><span class="line">bad_fork_cleanup_fs:</span><br><span class="line">	exit_fs(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_files:</span><br><span class="line">	exit_files(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_semundo:</span><br><span class="line">	exit_sem(p);</span><br><span class="line">bad_fork_cleanup_audit:</span><br><span class="line">	audit_free(p);</span><br><span class="line">bad_fork_cleanup_security:</span><br><span class="line">	security_task_free(p);</span><br><span class="line">bad_fork_cleanup_policy:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	mpol_free(p-&gt;mempolicy);</span><br><span class="line">bad_fork_cleanup_cgroup:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	cgroup_exit(p, cgroup_callbacks_done);</span><br><span class="line">	delayacct_tsk_free(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;binfmt)</span><br><span class="line">		module_put(p-&gt;binfmt-&gt;<span class="keyword">module</span>);</span><br><span class="line">bad_fork_cleanup_put_domain:</span><br><span class="line">	module_put(task_thread_info(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>);</span><br><span class="line">bad_fork_cleanup_count:</span><br><span class="line">	put_group_info(p-&gt;group_info);</span><br><span class="line">	atomic_dec(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">	free_uid(p-&gt;user);</span><br><span class="line">bad_fork_free:</span><br><span class="line">	free_task(p);</span><br><span class="line">fork_out:</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>copy_process</code>主要做了一下几件事情</p>
<ol>
<li>参数合法性校验</li>
<li><code>dup_task_struct</code>获取新进程的<code>task_struct</code>以及<code>thread_info</code>，并且利用父进程的信息为其初始化</li>
<li>校验当前用户资源是否已经达到上限，并进一步校验系统资源是否已经达到上限，然后初始化<code>task_struct</code>一些字段</li>
<li>调用<code>sched_fork</code>设置新进程调度相关信息，如设置进程调度类，在此过程中需要确认没有将父进程提高的优先级泄漏到子进程。</li>
<li>拷贝父进程IPC、信号、信号处理程序、打开的文件、文件系统、内存、命名空间、thread_info等信息。</li>
<li>为新进程创建pid实例，将相关upid插入到pid_hash数组中，并且在后面把pid和新进程关联</li>
<li>继续初始化一些字段…</li>
</ol>
<p>以上就是创建一个新进程的全部工作，诚然有些细节部分没有介绍到(没弄明白..)，但是对于我们理解进程的创建来说，以上已经足够了。下面将继续深入<code>copy_process</code>内部的函数进一步的介绍：</p>
<p>首先看一下第一个重要逻辑<code>dup_task_struct</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">dup_task_struct</span><span class="params">(struct task_struct *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">// 拷贝前的准备，主要是采用惰性fpu操作</span></span><br><span class="line">    <span class="comment">// 保存父进程的fpu信息但是并不加载新进程的pfu信息</span></span><br><span class="line">    <span class="comment">// 只有当新进程真正使用到fpu时，硬件会产生一个异常</span></span><br><span class="line">    <span class="comment">// 此时内核才会真正的加载新进程的fpu</span></span><br><span class="line">	prepare_to_copy(orig);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从slab缓存中申请task_struct对象</span></span><br><span class="line">	tsk = alloc_task_struct();</span><br><span class="line">	<span class="keyword">if</span> (!tsk)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为新的task_struct申请thread_info</span></span><br><span class="line">    <span class="comment">// 同样从slab中申请</span></span><br><span class="line">	ti = alloc_thread_info(tsk);</span><br><span class="line">	<span class="keyword">if</span> (!ti) &#123;</span><br><span class="line">		free_task_struct(tsk);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝父进程并将其中的thread_info修改为子进程的thread_info</span></span><br><span class="line">	*tsk = *orig;</span><br><span class="line">	tsk-&gt;<span class="built_in">stack</span> = ti;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 初始化一些信息</span></span><br><span class="line">	err = prop_local_init_single(&amp;tsk-&gt;dirties);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		free_thread_info(ti);</span><br><span class="line">		free_task_struct(tsk);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 拷贝父进程的thread_info信息并将</span></span><br><span class="line">    <span class="comment">// 子进程的thread_info指向子进程</span></span><br><span class="line">	setup_thread_stack(tsk, orig);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CC_STACKPROTECTOR</span></span><br><span class="line">	tsk-&gt;stack_canary = get_random_int();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* One for us, one for whoever does the "release_task()" (usually parent) */</span></span><br><span class="line">    <span class="comment">// 设置新进程引用信息</span></span><br><span class="line">	atomic_set(&amp;tsk-&gt;usage,<span class="number">2</span>);</span><br><span class="line">	atomic_set(&amp;tsk-&gt;fs_excl, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	tsk-&gt;btrace_seq = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	tsk-&gt;splice_pipe = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> tsk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>dup_task_struct</code>函数其实主要做了一件事：初始化新进程的<code>task_struct</code>和<code>thread_info</code>，完全拷贝父进程对应信息。</p>
<p>接下来我们进一步查看调度相关初始化函数<code>sched_fork</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_fork</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 禁用内核抢占并且获取当前cpu，如果不禁用抢占的话</span></span><br><span class="line">    <span class="comment">// 那么当前进程如果被抢占，那么下次执行的时候就不一定是在</span></span><br><span class="line">    <span class="comment">// 当前cpu了，但是cpu变量的值还是之前的cpu，这是错误行为</span></span><br><span class="line">	<span class="keyword">int</span> cpu = get_cpu();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是初始化task_struct调度实体各个字段，</span></span><br><span class="line">    <span class="comment">// 并且把新进程状态设置为RUNNING</span></span><br><span class="line">	__sched_fork(p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">// 多处理器下的负载均衡，找到一个合适的处理器</span></span><br><span class="line">	cpu = sched_balance_self(cpu, SD_BALANCE_FORK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 将新进程赋给该cpu，这里面做的事情比较多</span></span><br><span class="line">    <span class="comment">// 简单的一点就是将子进程thread_info的cpu字段</span></span><br><span class="line">    <span class="comment">// 设置为该cpu, 并且把当前进程调度尸体的cfs_rq</span></span><br><span class="line">    <span class="comment">// 队列指向该处理器的队列</span></span><br><span class="line">	set_task_cpu(p, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we do not leak PI boosting priority to the child:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 根据父进程的普通优先级，决定新进程是由</span></span><br><span class="line">    <span class="comment">// cfs调度器调度还是保持父进程一样，因为父进程此时可能</span></span><br><span class="line">    <span class="comment">// 由于某种操作，暂时使用了实时调度器，但是本质上</span></span><br><span class="line">    <span class="comment">// 父进程仍然是一个普通进程，因此为了防止子进程在这种情况下</span></span><br><span class="line">    <span class="comment">// 变成实时进程，要通过父进程的普通优先级进行判断</span></span><br><span class="line">	p-&gt;prio = current-&gt;normal_prio;</span><br><span class="line">	<span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span></span><br><span class="line">	<span class="keyword">if</span> (likely(sched_info_on()))</span><br><span class="line">		<span class="built_in">memset</span>(&amp;p-&gt;sched_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;sched_info));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP) &amp;&amp; defined(__ARCH_WANT_UNLOCKED_CTXSW)</span></span><br><span class="line">	p-&gt;oncpu = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">	<span class="comment">/* Want to start with kernel preemption disabled. */</span></span><br><span class="line">    <span class="comment">// 如果编译内核时禁止内核抢占，那么直接设置禁止抢占标志</span></span><br><span class="line">    <span class="comment">// 这样该进程无论何时在内核态执行时都不能被其他进程抢占</span></span><br><span class="line">	task_thread_info(p)-&gt;preempt_count = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	put_cpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sched_fork</code>主要工作是初始化新进程调度相关信息，设置正确的调度类，为子进程选择合适的cpu，如果内核编译时禁止内核抢占，那么在初始化时会直接设置禁止抢占标志。对于cfs队列等信息在后面介绍调度器时再深入探讨，这里忽略即可。</p>
<p>下面就是一系列cpoy_xxx函数，我们一个一个来，首先是ipc拷贝函数<code>copy_semundo</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_semundo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo_list</span> *<span class="title">undo_list</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果拷贝时设置了共享ipc标志，那么子进程直接共享父进程的ipc</span></span><br><span class="line">    <span class="comment">// 并且增加父进程ipc结构的引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_SYSVSEM) &#123;</span><br><span class="line">		error = get_undo_list(&amp;undo_list);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line">		atomic_inc(&amp;undo_list-&gt;refcnt);</span><br><span class="line">		tsk-&gt;sysvsem.undo_list = undo_list;</span><br><span class="line">	&#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// 否则直接将子进程的ipc队列置null</span></span><br><span class="line">		tsk-&gt;sysvsem.undo_list = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该函数逻辑非常简单，至于undo_list结构的含义，等后面介绍ipc时再行介绍</p>
<p>紧接着是<code>copy_files</code>函数，拷贝打开的文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_files</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct * tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">oldf</span>, *<span class="title">newf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A background process may not have any files ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果父进程没有打开任何文件，那么子进程什么也不做</span></span><br><span class="line">	oldf = current-&gt;files;</span><br><span class="line">	<span class="keyword">if</span> (!oldf)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果设置了共享文件标志，那么子进程直接引用父进程</span></span><br><span class="line">    <span class="comment">// 文件结构，并增加引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">		atomic_inc(&amp;oldf-&gt;count);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: we may be using current for both targets (See exec.c)</span></span><br><span class="line"><span class="comment">	 * This works because we cache current-&gt;files (old) as oldf. Don't</span></span><br><span class="line"><span class="comment">	 * break this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 走到这里说明父子进程并不共享打开的文件</span></span><br><span class="line">    <span class="comment">// 那么就需要拷贝父进程的文件结构并且复制给子进程</span></span><br><span class="line">    <span class="comment">// 具体的拷贝逻辑涉及到文件系统，不是本文重点</span></span><br><span class="line">    <span class="comment">// 可在文件系统相关知识介绍完后再回来查看</span></span><br><span class="line">	tsk-&gt;files = <span class="literal">NULL</span>;</span><br><span class="line">	newf = dup_fd(oldf, &amp;error);</span><br><span class="line">	<span class="keyword">if</span> (!newf)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;files = newf;</span><br><span class="line">	error = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>copy_fs</code>，拷贝父进程文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_fs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了共享文件系统，那么简单的增加父进程文件系统</span></span><br><span class="line">    <span class="comment">// 结构的引用计数即可</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_FS) &#123;</span><br><span class="line">		atomic_inc(&amp;current-&gt;fs-&gt;count);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 否则拷贝父进程文件系统结构，拷贝的逻辑也比较简单</span></span><br><span class="line">    <span class="comment">// 就是利用slab新申请一个fs结构，然后将父进程的</span></span><br><span class="line">    <span class="comment">// 各项字段复制给新的</span></span><br><span class="line">	tsk-&gt;fs = __copy_fs_struct(current-&gt;fs);</span><br><span class="line">	<span class="keyword">if</span> (!tsk-&gt;fs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后调用<code>copy_sighand</code>拷贝信号处理程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_sighand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果可以共享，则增加父进程sighand引用计数即可</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; (CLONE_SIGHAND | CLONE_THREAD)) &#123;</span><br><span class="line">		atomic_inc(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从slab申请一个sighand实例</span></span><br><span class="line">	sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);</span><br><span class="line">    <span class="comment">// rcu机制(内核同步手段，不是本节重点)</span></span><br><span class="line">    <span class="comment">// 将新的sighand实例赋值给新进程</span></span><br><span class="line">	rcu_assign_pointer(tsk-&gt;sighand, sig);</span><br><span class="line">	<span class="keyword">if</span> (!sig)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">// 设置引用计数，然后暴力拷贝即可</span></span><br><span class="line">	atomic_set(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="keyword">sizeof</span>(sig-&gt;action));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号处理程序之后紧接着拷贝信号，该工作由<code>copy_signal</code>完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_signal</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// 如果可以共享，增加相应引用计数即可</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">		atomic_inc(&amp;current-&gt;signal-&gt;count);</span><br><span class="line">		atomic_inc(&amp;current-&gt;signal-&gt;live);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// slab申请新实例并赋值给新进程</span></span><br><span class="line">	sig = kmem_cache_alloc(signal_cachep, GFP_KERNEL);</span><br><span class="line">	tsk-&gt;signal = sig;</span><br><span class="line">	<span class="keyword">if</span> (!sig)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">// 如果编译内核时设置了CONFIG_KEYS，那么拷贝同一个线程组的密钥环(自行搜索)</span></span><br><span class="line">    <span class="comment">// 否则这一步其实什么也没做</span></span><br><span class="line">	ret = copy_thread_group_keys(tsk);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kmem_cache_free(signal_cachep, sig);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化signal结构一系列字段，具体是什么含义可以忽略</span></span><br><span class="line">    <span class="comment">// 涉及到信号相关知识，后面介绍完信号再回来看就能理解了</span></span><br><span class="line">	atomic_set(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line">	atomic_set(&amp;sig-&gt;live, <span class="number">1</span>);</span><br><span class="line">	init_waitqueue_head(&amp;sig-&gt;wait_chldexit);</span><br><span class="line">	sig-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;group_exit_code = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;group_exit_task = <span class="literal">NULL</span>;</span><br><span class="line">	sig-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;curr_target = <span class="literal">NULL</span>;</span><br><span class="line">	init_sigpending(&amp;sig-&gt;shared_pending);</span><br><span class="line">	INIT_LIST_HEAD(&amp;sig-&gt;posix_timers);</span><br><span class="line"></span><br><span class="line">	hrtimer_init(&amp;sig-&gt;real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">	sig-&gt;it_real_incr.tv64 = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;real_timer.function = it_real_fn;</span><br><span class="line">	sig-&gt;tsk = tsk;</span><br><span class="line"></span><br><span class="line">	sig-&gt;it_virt_expires = cputime_zero;</span><br><span class="line">	sig-&gt;it_virt_incr = cputime_zero;</span><br><span class="line">	sig-&gt;it_prof_expires = cputime_zero;</span><br><span class="line">	sig-&gt;it_prof_incr = cputime_zero;</span><br><span class="line"></span><br><span class="line">	sig-&gt;leader = <span class="number">0</span>;	<span class="comment">/* session leadership doesn't inherit */</span></span><br><span class="line">	sig-&gt;tty_old_pgrp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	sig-&gt;utime = sig-&gt;stime = sig-&gt;cutime = sig-&gt;cstime = cputime_zero;</span><br><span class="line">	sig-&gt;gtime = cputime_zero;</span><br><span class="line">	sig-&gt;cgtime = cputime_zero;</span><br><span class="line">	sig-&gt;nvcsw = sig-&gt;nivcsw = sig-&gt;cnvcsw = sig-&gt;cnivcsw = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;min_flt = sig-&gt;maj_flt = sig-&gt;cmin_flt = sig-&gt;cmaj_flt = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;inblock = sig-&gt;oublock = sig-&gt;cinblock = sig-&gt;coublock = <span class="number">0</span>;</span><br><span class="line">	sig-&gt;sum_sched_runtime = <span class="number">0</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;sig-&gt;cpu_timers[<span class="number">0</span>]);</span><br><span class="line">	INIT_LIST_HEAD(&amp;sig-&gt;cpu_timers[<span class="number">1</span>]);</span><br><span class="line">	INIT_LIST_HEAD(&amp;sig-&gt;cpu_timers[<span class="number">2</span>]);</span><br><span class="line">	taskstats_tgid_init(sig);</span><br><span class="line"></span><br><span class="line">	task_lock(current-&gt;group_leader);</span><br><span class="line">	<span class="built_in">memcpy</span>(sig-&gt;rlim, current-&gt;signal-&gt;rlim, <span class="keyword">sizeof</span> sig-&gt;rlim);</span><br><span class="line">	task_unlock(current-&gt;group_leader);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sig-&gt;rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * New sole thread in the process gets an expiry time</span></span><br><span class="line"><span class="comment">		 * of the whole CPU time limit.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tsk-&gt;it_prof_expires =</span><br><span class="line">			secs_to_cputime(sig-&gt;rlim[RLIMIT_CPU].rlim_cur);</span><br><span class="line">	&#125;</span><br><span class="line">	acct_init_pacct(&amp;sig-&gt;pacct);</span><br><span class="line"></span><br><span class="line">	tty_audit_fork(sig);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是拷贝mm，写时复制的秘密就在这里，调用<code>copy_mm</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct * tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">    <span class="comment">// 初始化缺页统计信息</span></span><br><span class="line">    <span class="comment">// min_flt表示页在内存中产生的缺页，但是由于还没有和</span></span><br><span class="line">    <span class="comment">// 进程地址建立映射关系</span></span><br><span class="line">    <span class="comment">// maj_flt表示由于页不在内存中产生的缺页</span></span><br><span class="line">	tsk-&gt;min_flt = tsk-&gt;maj_flt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化资源/非资源进程上下文切换计数</span></span><br><span class="line">	tsk-&gt;nvcsw = tsk-&gt;nivcsw = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 置空mm和active_mm，active_mm主要是给内核</span></span><br><span class="line">    <span class="comment">// 线程使用的，因为内核线程没有mm结构体</span></span><br><span class="line">    <span class="comment">// 因此只能使用当前进程的mm</span></span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Are we cloning a kernel thread?</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We need to steal a active VM for that..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	oldmm = current-&gt;mm;</span><br><span class="line">    <span class="comment">// 第一个内核线程是由idle创建的，并且通过查看</span></span><br><span class="line">    <span class="comment">// idle进程的task_struct(include/linux/init_task.h)发现</span></span><br><span class="line">    <span class="comment">// idle进程并没有mm结构体，因此内核线程也就没有mm结构体</span></span><br><span class="line">	<span class="keyword">if</span> (!oldmm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果共享mm，那么增加引用计数即可</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">		atomic_inc(&amp;oldmm-&gt;mm_users);</span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">    <span class="comment">// 否则拷贝mm结构体</span></span><br><span class="line">	mm = dup_mm(tsk);</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">	<span class="comment">/* Initializing for Swap token stuff */</span></span><br><span class="line">	mm-&gt;token_priority = <span class="number">0</span>;</span><br><span class="line">	mm-&gt;last_interval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;mm = mm;</span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_nomem:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>copy_mm</code>主要是初始化一些统计信息，并且根据是否需要共享mm来决定是共享父进程的mm还是拷贝父进程的mm，如果父子进程共享mm，那么就不存在写时复制这一说了，我们主要分析不共享的情况，也就是<code>dup_mm</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mm_struct *<span class="title">dup_mm</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!oldmm)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 千篇一律，使用slab获取mm对象</span></span><br><span class="line">	mm = allocate_mm();</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暴力拷贝父进程的mm</span></span><br><span class="line">	<span class="built_in">memcpy</span>(mm, oldmm, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initializing for Swap token stuff */</span></span><br><span class="line">    <span class="comment">// 页面交换相关</span></span><br><span class="line">	mm-&gt;token_priority = <span class="number">0</span>;</span><br><span class="line">	mm-&gt;last_interval = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化新申请的mm</span></span><br><span class="line">	<span class="keyword">if</span> (!mm_init(mm))</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化上下文</span></span><br><span class="line">	<span class="keyword">if</span> (init_new_context(tsk, mm))</span><br><span class="line">		<span class="keyword">goto</span> fail_nocontext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始拷贝</span></span><br><span class="line">	err = dup_mmap(mm, oldmm);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_pt;</span><br><span class="line">    <span class="comment">// 初始化进程拥有的最大页框数和进程线性区中最大页数</span></span><br><span class="line">    <span class="comment">// 页框指的是物理页，页指的是虚拟地址</span></span><br><span class="line">	mm-&gt;hiwater_rss = get_mm_rss(mm);</span><br><span class="line">	mm-&gt;hiwater_vm = mm-&gt;total_vm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mm;</span><br><span class="line"></span><br><span class="line">free_pt:</span><br><span class="line">	mmput(mm);</span><br><span class="line"></span><br><span class="line">fail_nomem:</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">fail_nocontext:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If init_new_context() failed, we cannot use mmput() to free the mm</span></span><br><span class="line"><span class="comment">	 * because it calls destroy_context()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mm_free_pgd(mm);</span><br><span class="line">	free_mm(mm);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>dup_mm</code>函数的主要逻辑也不难，主要是从slab申请新的<code>mm_struct</code>结构，然后暴力拷贝父进程的mm，不过对其中一些统计信息进行初始化，然后依次调用三个函数，分别是<code>mm_init</code>、<code>init_new_context</code>以及<code>dup_mmap</code>，我们一个一个说</p>
<p>首先是<code>mm_init</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mm_struct * <span class="title">mm_init</span><span class="params">(struct mm_struct * mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以看到只是简单的初始化mm_struct各项字段罢了</span></span><br><span class="line">    <span class="comment">// 具体字段的含义涉及到内存管理，这里不展开</span></span><br><span class="line">    <span class="comment">// 在内存相关文章中会详细介绍</span></span><br><span class="line">	atomic_set(&amp;mm-&gt;mm_users, <span class="number">1</span>);</span><br><span class="line">	atomic_set(&amp;mm-&gt;mm_count, <span class="number">1</span>);</span><br><span class="line">	init_rwsem(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	INIT_LIST_HEAD(&amp;mm-&gt;mmlist);</span><br><span class="line">	mm-&gt;flags = (current-&gt;mm) ? current-&gt;mm-&gt;flags</span><br><span class="line">				  : MMF_DUMP_FILTER_DEFAULT;</span><br><span class="line">	mm-&gt;core_waiters = <span class="number">0</span>;</span><br><span class="line">	mm-&gt;nr_ptes = <span class="number">0</span>;</span><br><span class="line">	set_mm_counter(mm, file_rss, <span class="number">0</span>);</span><br><span class="line">	set_mm_counter(mm, anon_rss, <span class="number">0</span>);</span><br><span class="line">	spin_lock_init(&amp;mm-&gt;page_table_lock);</span><br><span class="line">	rwlock_init(&amp;mm-&gt;ioctx_list_lock);</span><br><span class="line">	mm-&gt;ioctx_list = <span class="literal">NULL</span>;</span><br><span class="line">	mm-&gt;free_area_cache = TASK_UNMAPPED_BASE;</span><br><span class="line">	mm-&gt;cached_hole_size = ~<span class="number">0U</span>L;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为新的mm申请pgd并且进行进一步处理</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!mm_alloc_pgd(mm))) &#123;</span><br><span class="line">		mm-&gt;def_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> mm;</span><br><span class="line">	&#125;</span><br><span class="line">	free_mm(mm);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mm_alloc_pgd</span><span class="params">(struct mm_struct * mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用pgd_alloc函数</span></span><br><span class="line">	mm-&gt;pgd = pgd_alloc(mm);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!mm-&gt;pgd))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pgd_t</span> *pgd_alloc(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// quicklist_alloc该函数主要从每cpu缓存中申请一个pgd页</span></span><br><span class="line">    <span class="comment">// 如果申请失败则从伙伴系统申请，并且调用pgd_ctor初始化</span></span><br><span class="line">    <span class="comment">// 具体就不深入研究了，涉及到内存管理，比较复杂</span></span><br><span class="line">    <span class="comment">// 会在内存管理文章中详细介绍申请过程，不过可以看一下</span></span><br><span class="line">    <span class="comment">// pgd_ctor函数，该函数初始化新进程的pgd时，</span></span><br><span class="line">    <span class="comment">// 会将swagger_pg_dir(也就是idle进程的页表)的内核页部分(最高1GB)</span></span><br><span class="line">    <span class="comment">// 拷贝给新进程的内核页部分，这样一来，所有新进程的内核页表部分</span></span><br><span class="line">    <span class="comment">// 都相同..因为它们实际上都是以swagger_pg_dir进程的模版拷贝的</span></span><br><span class="line">	<span class="keyword">pgd_t</span> *pgd = quicklist_alloc(<span class="number">0</span>, GFP_KERNEL, pgd_ctor);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PTRS_PER_PMD == <span class="number">1</span> || !pgd)</span><br><span class="line">		<span class="keyword">return</span> pgd;</span><br><span class="line">    <span class="comment">// 为每个pgd项申请pmd页，并设置对应的pgd项</span></span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; UNSHARED_PTRS_PER_PGD; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果是内核部分的pmd，那么对于申请到的pmd页</span></span><br><span class="line">        <span class="comment">// 同样适用swigger_pg_dir进行拷贝</span></span><br><span class="line">        <span class="comment">// 如果是用户部分的页，那么从slab缓存获取一个</span></span><br><span class="line">        <span class="comment">// pmd对象，该对象从pmd_cache获取，每个pmd都</span></span><br><span class="line">        <span class="comment">// 被初始化过(对于pmd初始化实际上就是全部置0)</span></span><br><span class="line">		<span class="keyword">pmd_t</span> *pmd = pmd_cache_alloc(i);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pmd)</span><br><span class="line">			<span class="keyword">goto</span> out_oom;</span><br><span class="line">        <span class="comment">// 忽略</span></span><br><span class="line">		paravirt_alloc_pd(__pa(pmd) &gt;&gt; PAGE_SHIFT);</span><br><span class="line">        <span class="comment">// 设置pgd项，至于为什么是1 + __pa(pmd)</span></span><br><span class="line">        <span class="comment">// 可以看一下x86的硬件分页规则，Linux将页的</span></span><br><span class="line">        <span class="comment">// R/W,U/S,PWT,PCD以及A标志都置0，表明该pmd页</span></span><br><span class="line">        <span class="comment">// 是不可写、系统页、启用高速缓存并且对于写</span></span><br><span class="line">        <span class="comment">// 操作总是回写(这和x86的硬件缓存有关，实际上Linux对于所有页</span></span><br><span class="line">        <span class="comment">// 都是启动缓存并且回写)</span></span><br><span class="line">		set_pgd(&amp;pgd[i], __pgd(<span class="number">1</span> + __pa(pmd)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pgd;</span><br><span class="line"></span><br><span class="line">out_oom:</span><br><span class="line">	<span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">pgd_t</span> pgdent = pgd[i];</span><br><span class="line">		<span class="keyword">void</span>* pmd = (<span class="keyword">void</span> *)__va(pgd_val(pgdent)<span class="number">-1</span>);</span><br><span class="line">		paravirt_release_pd(__pa(pmd) &gt;&gt; PAGE_SHIFT);</span><br><span class="line">		pmd_cache_free(pmd, i);</span><br><span class="line">	&#125;</span><br><span class="line">	quicklist_free(<span class="number">0</span>, pgd_dtor, pgd);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该函数主要是初始化mm结构的各个字段，其中非常值得关注的一点是对于<code>pgd</code>的初始化：每个子进程都会拷贝swagger_pg_dir的内核态pgd项和pmd项，因此这也就解释了为什么所有进程的内核页表都相同。初始化<code>pgd</code>的做法就是为每一个pgd项都申请一个pmd页，然后利用pmd页的物理地址设置pgd表项，可以看到pgd表项被设置为<code>不可读、系统页并且启用硬件高速缓存以及开启回写</code>的策略。</p>
<p>然后就是<code>init_new_context</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_new_context</span><span class="params">(struct task_struct *tsk, struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">old_mm</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">	mutex_init(&amp;mm-&gt;context.lock);</span><br><span class="line">	mm-&gt;context.size = <span class="number">0</span>;</span><br><span class="line">	old_mm = current-&gt;mm;</span><br><span class="line">    <span class="comment">// 如果父进程的mm使用了ldt，那么拷贝给子进程</span></span><br><span class="line">	<span class="keyword">if</span> (old_mm &amp;&amp; old_mm-&gt;context.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		mutex_lock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">		retval = copy_ldt(&amp;mm-&gt;context, &amp;old_mm-&gt;context);</span><br><span class="line">		mutex_unlock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也是最重要的<code>dup_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dup_mmap</span><span class="params">(struct mm_struct *mm, struct mm_struct *oldmm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mpnt</span>, *<span class="title">tmp</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> charge;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span>;</span></span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">	down_write(&amp;oldmm-&gt;mmap_sem);</span><br><span class="line">    <span class="comment">// x86平台上什么也不做</span></span><br><span class="line">	flush_cache_dup_mm(oldmm);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Not linked in yet - no deadlock potential:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	down_write_nested(&amp;mm-&gt;mmap_sem, SINGLE_DEPTH_NESTING);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化子进程mm的若干字段</span></span><br><span class="line">	mm-&gt;locked_vm = <span class="number">0</span>;</span><br><span class="line">	mm-&gt;mmap = <span class="literal">NULL</span>;</span><br><span class="line">	mm-&gt;mmap_cache = <span class="literal">NULL</span>;</span><br><span class="line">	mm-&gt;free_area_cache = oldmm-&gt;mmap_base;</span><br><span class="line">	mm-&gt;cached_hole_size = ~<span class="number">0U</span>L;</span><br><span class="line">	mm-&gt;map_count = <span class="number">0</span>;</span><br><span class="line">	cpus_clear(mm-&gt;cpu_vm_mask);</span><br><span class="line">	mm-&gt;mm_rb = RB_ROOT;</span><br><span class="line">	rb_link = &amp;mm-&gt;mm_rb.rb_node;</span><br><span class="line">	rb_parent = <span class="literal">NULL</span>;</span><br><span class="line">	pprev = &amp;mm-&gt;mmap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的线性区然后拷贝</span></span><br><span class="line">	<span class="keyword">for</span> (mpnt = oldmm-&gt;mmap; mpnt; mpnt = mpnt-&gt;vm_next) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mpnt-&gt;vm_flags &amp; VM_DONTCOPY) &#123;</span><br><span class="line">			<span class="keyword">long</span> pages = vma_pages(mpnt);</span><br><span class="line">			mm-&gt;total_vm -= pages;</span><br><span class="line">			vm_stat_account(mm, mpnt-&gt;vm_flags, mpnt-&gt;vm_file,</span><br><span class="line">								-pages);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		charge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (mpnt-&gt;vm_flags &amp; VM_ACCOUNT) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> len = (mpnt-&gt;vm_end - mpnt-&gt;vm_start) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">			<span class="keyword">if</span> (security_vm_enough_memory(len))</span><br><span class="line">				<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">			charge = len;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!tmp)</span><br><span class="line">			<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">		*tmp = *mpnt;</span><br><span class="line">		pol = mpol_copy(vma_policy(mpnt));</span><br><span class="line">		retval = PTR_ERR(pol);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(pol))</span><br><span class="line">			<span class="keyword">goto</span> fail_nomem_policy;</span><br><span class="line">		vma_set_policy(tmp, pol);</span><br><span class="line">		tmp-&gt;vm_flags &amp;= ~VM_LOCKED;</span><br><span class="line">		tmp-&gt;vm_mm = mm;</span><br><span class="line">		tmp-&gt;vm_next = <span class="literal">NULL</span>;</span><br><span class="line">		anon_vma_link(tmp);</span><br><span class="line">		file = tmp-&gt;vm_file;</span><br><span class="line">		<span class="keyword">if</span> (file) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">file</span>-&gt;<span class="title">f_path</span>.<span class="title">dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line">			get_file(file);</span><br><span class="line">			<span class="keyword">if</span> (tmp-&gt;vm_flags &amp; VM_DENYWRITE)</span><br><span class="line">				atomic_dec(&amp;inode-&gt;i_writecount);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* insert tmp into the share list, just after mpnt */</span></span><br><span class="line">			spin_lock(&amp;file-&gt;f_mapping-&gt;i_mmap_lock);</span><br><span class="line">			tmp-&gt;vm_truncate_count = mpnt-&gt;vm_truncate_count;</span><br><span class="line">			flush_dcache_mmap_lock(file-&gt;f_mapping);</span><br><span class="line">			vma_prio_tree_add(tmp, mpnt);</span><br><span class="line">			flush_dcache_mmap_unlock(file-&gt;f_mapping);</span><br><span class="line">			spin_unlock(&amp;file-&gt;f_mapping-&gt;i_mmap_lock);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Link in the new vma and copy the page table entries.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*pprev = tmp;</span><br><span class="line">		pprev = &amp;tmp-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">		__vma_link_rb(mm, tmp, rb_link, rb_parent);</span><br><span class="line">		rb_link = &amp;tmp-&gt;vm_rb.rb_right;</span><br><span class="line">		rb_parent = &amp;tmp-&gt;vm_rb;</span><br><span class="line"></span><br><span class="line">		mm-&gt;map_count++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这就是核心函数</span></span><br><span class="line">		retval = copy_page_range(mm, oldmm, mpnt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;vm_ops &amp;&amp; tmp-&gt;vm_ops-&gt;open)</span><br><span class="line">			tmp-&gt;vm_ops-&gt;open(tmp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* a new mm has just been created */</span></span><br><span class="line">	arch_dup_mmap(oldmm, mm);</span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	flush_tlb_mm(oldmm);</span><br><span class="line">	up_write(&amp;oldmm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">fail_nomem_policy:</span><br><span class="line">	kmem_cache_free(vm_area_cachep, tmp);</span><br><span class="line">fail_nomem:</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	vm_unacct_memory(charge);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数很长，其他的暂时可以忽略，因为涉及到内存管理比较复杂，可以关注以下copy_page_range函数，该函数简单的说就是遍历pgd-pud-pmd-pte，然后循环拷贝父进程的项，并且在拷贝pte项时，清空父/子进程项的R/W标志，这样当父子进程试图写页面时，硬件就会产生一个页错误异常，内核捕捉到这个异常后就会进行写时复制。</p>
<p>对于把<code>copy_mm</code>的介绍到这里就告一段落，对于拷贝密钥环这里就不做介绍了，一是我对这个不熟悉，二是这个和本节的内容也不想管，感兴趣的话可以研究一下，而<code>copy_namespace</code>整体逻辑也不复杂，如果父子进程不共享命名空间，那么则拷贝一份父进程的副本给子进程，注意这里的命名空间包含了2.6支持的所有命名空间(nsproxy结构)</p>
<p>最后需要介绍的就是<code>copy_thread</code>函数，该函数也是fork过程中十分重要的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_thread</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> esp,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">long</span> unused,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct task_struct * p, struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> * <span class="title">childregs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">// 获取子进程内核态栈中的各个寄存器值</span></span><br><span class="line">    <span class="comment">// 这些值都是前面函数中从父进程拷贝过来的，目前和父进程</span></span><br><span class="line">    <span class="comment">// 一摸一样，因此这里可能需要进行修改, childregs位于</span></span><br><span class="line">    <span class="comment">// 内核栈栈底向下8个字节</span></span><br><span class="line">	childregs = task_pt_regs(p);</span><br><span class="line">	*childregs = *regs;</span><br><span class="line">    <span class="comment">// 修改fork在子进程中的返回值，我们知道fork最终返回pid</span></span><br><span class="line">    <span class="comment">// 并且通过eax传递</span></span><br><span class="line">    <span class="comment">// 父进程中的eax就是子进程的pid，而子进程的eax由于这里的</span></span><br><span class="line">    <span class="comment">// 操作会返回0，这也就是为什么子进程返回0的原因</span></span><br><span class="line">	childregs-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// childregs-&gt;esp中现在存储的是父进程用户态基地址</span></span><br><span class="line">    <span class="comment">// 如果在fork时制定了新的用户栈地址，那么修改子进程的</span></span><br><span class="line">    <span class="comment">// 用户栈地址，这样子进程返回用户态时就和父进程使用</span></span><br><span class="line">    <span class="comment">// 不同的栈了，一般在线程创建时会使用</span></span><br><span class="line">	childregs-&gt;esp = esp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这两个字段主要是设置内核栈基地址 - 9 和内核栈基地址 - 8</span></span><br><span class="line">    <span class="comment">// 具体看https://www.cnblogs.com/chaozhu/p/6283495.html</span></span><br><span class="line">    <span class="comment">// https://www.coolcou.com/linux-kernel/linux-kernel-references/linux-kernel-stack.html</span></span><br><span class="line">	p-&gt;thread.esp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) childregs;</span><br><span class="line">	p-&gt;thread.esp0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (childregs+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里修改了do_fork函数返回地址，设置为ret_from_fork</span></span><br><span class="line">    <span class="comment">// 函数的地址，因此子进程返回时会执行ret_from_fork函数</span></span><br><span class="line">	p-&gt;thread.eip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ret_from_fork;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把gs寄存器中的值保存到新进程的=threadinfo的指定位置</span></span><br><span class="line">	savesegment(gs,p-&gt;thread.gs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断父进程使用了IO权限位图，那么子进程拷贝一份</span></span><br><span class="line">    <span class="comment">// 并且同样设置TIF_IO_BITMAP位</span></span><br><span class="line">	tsk = current;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(test_tsk_thread_flag(tsk, TIF_IO_BITMAP))) &#123;</span><br><span class="line">		p-&gt;thread.io_bitmap_ptr = kmemdup(tsk-&gt;thread.io_bitmap_ptr,</span><br><span class="line">						IO_BITMAP_BYTES, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!p-&gt;thread.io_bitmap_ptr) &#123;</span><br><span class="line">			p-&gt;thread.io_bitmap_max = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line">		set_tsk_thread_flag(p, TIF_IO_BITMAP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set a new TLS for the child thread?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果fork标志中指定了CLONE_SETTLS</span></span><br><span class="line">    <span class="comment">// 那么需要为子进程创建线程本地存储</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_SETTLS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *<span class="title">desc</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">info</span>;</span></span><br><span class="line">		<span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">		err = -EFAULT;</span><br><span class="line">        <span class="comment">// 用户空间通过esi指定了子进程ldt段描述符</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;info, (<span class="keyword">void</span> __user *)childregs-&gt;esi, <span class="keyword">sizeof</span>(info)))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (LDT_empty(&amp;info))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">		idx = info.entry_number;</span><br><span class="line">		<span class="keyword">if</span> (idx &lt; GDT_ENTRY_TLS_MIN || idx &gt; GDT_ENTRY_TLS_MAX)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 读取新进程tls_array的指定项，并且根据</span></span><br><span class="line">        <span class="comment">// 用户指定的描述符内容进行填充</span></span><br><span class="line">        <span class="comment">// https://www.cnblogs.com/long123king/p/3501936.html</span></span><br><span class="line">        <span class="comment">// 具体可以参考这篇文章，Linux每个cpu一个gdt，并且</span></span><br><span class="line">        <span class="comment">// 每个gdt预留了(789)三个项给tls使用</span></span><br><span class="line">		desc = p-&gt;thread.tls_array + idx - GDT_ENTRY_TLS_MIN;</span><br><span class="line">		desc-&gt;a = LDT_entry_a(&amp;info);</span><br><span class="line">		desc-&gt;b = LDT_entry_b(&amp;info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">if</span> (err &amp;&amp; p-&gt;thread.io_bitmap_ptr) &#123;</span><br><span class="line">		kfree(p-&gt;thread.io_bitmap_ptr);</span><br><span class="line">		p-&gt;thread.io_bitmap_max = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>do_fork</code>的介绍到这里就告一段落了，由于Linux本身的复杂性，新创建一个进程需要做的任务也是非常的庞大。需要特别说明的是，上面的介绍都是基于Linux2.6.24的x86-32位处理器的代码，并且其中涉及到文件系统、信号、ipc、调度以及内存管理的部分并没有深入介绍，不过这并不影响我们理解一个进程被创建出来的过程。</p>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>上面一节介绍了一个用户进程是如何被创建出来的，这一节让我们把目光聚集在内核线程上(需要再次申明的是，Linux内部无论是线程还是进程，都使用task_struct表示，实际上Linux内部并不区分进程线程，通过上一届的进程复制过程可以发现，线程共享父进程的信号、ipc、内存、文件等信息，我们把所有共享同一组这些信息的线程统称为线程组，它们共享这些信息，因此在线程切换时不需要切换页表，刚创建时也不需要写时复制，不需要进行各种拷贝等..因此无论是创建还是切换的开销都要小于进程。回到前面来，由于内核实际上不区分进程还是线程，因此下面再介绍时可能会混用这两个概念)。内核线程是直接由内核本身启动的进程，内核线程实际上是将内核函数委托给独立的进程。内核线程也被称为守护进程，它们用于执行下列任务</p>
<ul>
<li>周期性将修改的内存页与块设备(通常是磁盘)进行同步</li>
<li>如果内存页很少使用，则写入交换区</li>
<li>管理延时动作(比如软中断)</li>
<li>实现文件系统的事务日志</li>
</ul>
<p>Linux有两种类型的内核线程</p>
<ol>
<li>线程启动后一直等待，直到内核请求线程执行某一特定操作</li>
<li>线程启动后按周期性间隔执行，检测特定资源的使用，在使用量超出或低于预置的限制时采取行动，内核使用这类线程用于连续执行检测任务。</li>
</ol>
<p>使用<code>kernel_thread</code>可启动一个内核线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> * arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">memset</span>(&amp;regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(regs));</span><br><span class="line">    <span class="comment">// ebx指向内核线程将要执行的函数，edx指向函数需要的参数</span></span><br><span class="line">	regs.ebx = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fn;</span><br><span class="line">	regs.edx = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置内核线程内核堆栈内容</span></span><br><span class="line">	regs.xds = __USER_DS;</span><br><span class="line">	regs.xes = __USER_DS;</span><br><span class="line">    <span class="comment">// linux在用户态使用fs引用tls，不使用gs</span></span><br><span class="line">    <span class="comment">// 在内核态使用gs引用没cpu变量，不使用fs</span></span><br><span class="line">    <span class="comment">// 这里的fs在内核线程返回用户态时会被加载到用户态fs</span></span><br><span class="line">    <span class="comment">// 寄存器中，作为内核线程的tls?</span></span><br><span class="line">    <span class="comment">// 2.6.24中使用每个cpu的gdt的28项(包括第0项)作为</span></span><br><span class="line">    <span class="comment">// per_cpu变量的段描述符，实际上就是指向per_cpu变量</span></span><br><span class="line">    <span class="comment">// 也就是说，内核线程的tls指向了per_cpu变量</span></span><br><span class="line">	regs.xfs = __KERNEL_PERCPU;</span><br><span class="line">	regs.orig_eax = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 设置内核进程的cs/ip，这样内核线程创建完成被调度执行时</span></span><br><span class="line">    <span class="comment">// 就会从kernel_thread_helper开始执行，这里设置内核线程的</span></span><br><span class="line">    <span class="comment">// CS为内核代码段，因为内核线程实际上执行的是内核函数</span></span><br><span class="line">	regs.eip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) kernel_thread_helper;</span><br><span class="line">	regs.xcs = __KERNEL_CS | get_kernel_rpl();</span><br><span class="line">    </span><br><span class="line">	regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | <span class="number">0x2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过do_fork可以发现新创建的内核线程最终回执行ret_from_fork函数，该函数</span></span><br><span class="line">    <span class="comment">// 返回到用户栈时会执行kernel_thread_helper函数</span></span><br><span class="line">	<span class="keyword">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, <span class="number">0</span>, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现内核线程奇怪的一点是，它的代码段是内核代码段(cpl=0)，但是数据段确实用户数据段(cpl=3)，这是因为内核线程实际上没有自己的mm，但是由需要通过mm访问内核部分内存，这怎么办呢？原来，内核线程在被调度器调度执行时，会短暂使用前一个用户进程的mm结构体，这也就是task_struct为什么有两个mm相关字段，一个是mm，一个是active_mm。对于普通进程来说，mm和active_mm相同，而对于内核线程来说，它的mm为空，active_mm为前一个进程的mm结构体。</p>
<p>并且通过代码可以发现，内核线程永远只在内核态执行(因为cs的cpl = 0)，另外内核线程只访问虚拟地址空间的内核部分，而不访问用户部分。</p>
<h4 id="懒惰tlb模式"><a href="#懒惰tlb模式" class="headerlink" title="懒惰tlb模式"></a>懒惰tlb模式</h4><p>我们知道Linux上的全部虚拟地址空间分为两部分，底部的虚拟空间由用户程序访问，不同的用户程序不一祥，上层的空间供内核使用。每当进程切换时，虚拟地址空间的用户层部分就会被切换，切换成新进程的用户空间部分。这是懒惰tlb的基础，由于内核线程不用访问用户部分的虚拟空间，因此内核从普通进程切换到内核线程时，并不会立刻刷新当前进程的tlb表项，而是往后推迟。</p>
<p>为什么这样做呢？我们考虑这样一种情况，当前进程A切换到内核线程执行，内核线程执行完毕后，再次切换到了进程A，那么我们根本就不需要刷新tlb然后重新加载。但是如果内核线程下一个执行的进程和前面的进程不同，此时就需要执行tlb刷新，将之前进程的tlb内容清空。(多说一句，使用了类似x86平台下的pcid模式，那么不同进程的tlb表项可以共存在一个tlb上，这是因为不同进程有一个专属的picd，通过pcid可以区分不同进程的tlb表项，但是这样其实也存在一个问题，在多处理器下进程可能在多个处理器上运行过，这样一来多个处理器上都有某个进程的tlb项，万一需要清除该进程在tlb中的某个项或者某几个项，还需要借助处理器间中断来实现，还是比较麻烦的..目前版本的linux好像还不支持这一特性。)</p>
<h4 id="创建内核线程方式"><a href="#创建内核线程方式" class="headerlink" title="创建内核线程方式"></a>创建内核线程方式</h4><p>内核线程有两种方式实现：</p>
<ol>
<li><p>第一种就是前面说的，调用<code>kernel_thread</code>，这种方式比较古老，并且不够优雅，为什么这么说呢？不知道你有没有发现，当非内核线程(也就是说该进程有mm结构)想要创建一个内核线程时，内核线程会继承父进程的资源，因此还需要在内核线程中调用<code>daemonize</code>函数将新创建的内核线程转换为守护进程，该函数主要干了这几件事</p>
<ul>
<li>释放心创建内核线程的父进程资源(例如内存上下文、文件描述符等)，不然内核线程会一直占用这些资源直到结束，这是不可取的，因为内核线程通常会运行到系统关机…并且内核线程不访问用户空间，所以它甚至不使用这些资源，但是却占用了资源</li>
<li>阻塞信号的接收</li>
<li>将2号进程作为内核线程的父进程(实际上所有内核线程的父进程都是2号线程)</li>
</ul>
</li>
<li><p>第二种方式则更加现代，调用<code>kthread_create</code>或<code>kthread_run</code>函数，这两个函数唯一的区别在于第二个创建后悔唤醒新创建的内核线程，而第一个不会主动唤醒。</p>
</li>
</ol>
<p>对于内核线程的创建过程这里简单说一下：在<code>start_kernel</code>的最后会执行<code>rest_init</code>函数，该函数会创建1号init进程和2号kthread_add内核线程，其中1号进程最终会演变为用户进程，并且系统中所有的孤儿进程最终都会归init管理。而2号进程则会成为所有内核线程的祖先，所有的内核线程最终都通过2号内核祖先线程去创建：大概流程就是，现将要创建的内核线程包装一下放到一个队列中，然后唤醒kthread_add线程，该线程在一个死循环中执行，唤醒后查看队列中有没有待创建的内核线程，若有则创建之，若没有则修改状态为中断睡眠状态并调用schedule()函数。</p>
<h3 id="进程执行"><a href="#进程执行" class="headerlink" title="进程执行"></a>进程执行</h3><p>当一个新进程创建完成后并且被调度器选中执行时，它会紧接着执行<code>ret_from_fork</code>函数(如果不理解可以看一下前面的copy_thread函数)，<code>ret_from_fork</code>函数主要是调用schedule_tail函数进行schedule()的收尾工作，包括允许强占、开中断、释放当前cpu就绪队列的自旋锁，并且如果判断前一个任务处于DEAD状态，说明父进程已经调用了wait4系统调用，那么回收前一个进程的剩余资源。</p>
<p>你可能有疑问，问什么一个新创建的进程要调用schedule_tail函数呢？其实可以这么理解，一个进程正常切换的流程大概是这样的：schedule() → context_switch() → switch_to() —-等待调度器分配cpu—–schedule_tail()恢复执行。那么对于一个新创建的进程，他在执行完前面的步骤时，是没有最后一步schedule_tail()的，因为它并不是之前被调度器停止执行的进程(换句话说它从来没有获得过cpu)，所以这样就存在问题：schedule前半部执行了禁止抢占、禁止中断、cpu就绪队列自旋锁，就没有办法释放。因此我们需要人为的给新进程添加上schedule_tail()，让它第一次执行时先释放这些资源，然后再回复到用户态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_from_fork)</span><br><span class="line">	CFI_STARTPROC</span><br><span class="line">	pushl %eax</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	call schedule_tail       <span class="comment">// 执行schedule()_tail收尾</span></span><br><span class="line">	GET_THREAD_INFO(%ebp)</span><br><span class="line">	popl %eax</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">-4</span></span><br><span class="line">	pushl $<span class="number">0x0202</span>			# Reset kernel eflags</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	popfl</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">-4</span></span><br><span class="line">	jmp syscall_exit       <span class="comment">// 因为是fork系统调用，所以从系统调用中返回</span></span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(ret_from_fork)</span><br></pre></td></tr></table></figure>

<p>可能上述的部分有些抽象，我们通过一个图来把它形象化：<br><img src="3.png" alt></p>
<p>如图所示，除了新创建的进程，Linux中所有进程在切换的时，被切换出去的进程(如图中的进程A)，都会在switch_to函数中停止(可以简单理解为阻塞)，然后获得CPU的进程(如图中的进程B)从switch_to中恢复执行(因为B上次被切换出去的时候也是阻塞在swtch_to中)，通过图中我们还可以发现，此时系统是禁止本地中断(根据内核配置不同，可能会有区别，不过整体上逻辑一样)并且禁止抢占的，然而在B恢复执行后，会先执行finish_task_switch，该函数会主要两件事：如果前面没有开中断，那么这里开中断，如果前一个进程已经DEAD状态，那么释放task_struct和mm(其实还会把前一个进程的on_cpu置0，表示不持有cpu，不过和我们讨论的主题无关，忽略即可)；然后进程B回到schedule()函数中继续执行，schedule()最后会允许抢占，最后进程B从schedule()退出，去执行进程B本来的逻辑。不的不感叹，schedule()简洁优美但是功能如此强大!!!</p>
<p>让我们回到主题上来，对于一些新创建的进程，它被schedule()调度后，将会恢复执行。由于新进程从来没有执行过，它该从哪里开始执行呢？根据前面的分析我们知道，此时本地cpu处于禁止抢占、关中断(可能)的，如果获取cpu的是一个老进程，那么这都不是问题，老进程会根据上面的步骤，开中断并允许抢占。但是对于新进程就不行了，因此我们很容易想到，我们需要给新进程模拟后面的步骤，让它像老进程一样，执行和老进程类似的动作就好了。</p>
<p>分析到这里，你应该知道为什么要设置新进程的ip为<code>ret_from_fork</code>了，在该函数中会调用schedule_tail函数，而schedule_tail函数做的工作正是我们上面说的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">schedule_tail</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">    <span class="comment">// 调用finish_task_switch，如果cpu仍然处于关中断状态</span></span><br><span class="line">    <span class="comment">// 则开中断</span></span><br><span class="line">	finish_task_switch(rq, prev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_WANT_UNLOCKED_CTXSW</span></span><br><span class="line">	<span class="comment">/* In this case, finish_task_switch does not reenable preemption */</span></span><br><span class="line">    <span class="comment">// 允许内核抢占</span></span><br><span class="line">	preempt_enable();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;set_child_tid)</span><br><span class="line">		put_user(task_pid_vnr(current), current-&gt;set_child_tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这里，你可能对进程切换的过程更加好奇了，进程切换是Linux非常有意思的部分，使用非常短小的一段汇编就实现了切换，很值得我们细细研究。不过本节的主题是进程执行..好像有点偏题了，让我们回到正题，把进程执行介绍完毕。我将在本文的后面详细的介绍进程切换的细节。</p>
<p>当新进程经过上面的步骤返回到用户态执行时，由于子进程的用户态ip和父进程相同，因此子进程会执行和父进程一摸一样的代码，这是没有意义的。如果想要让子进程执行不同的逻辑，我们需要借助另外一个系统调用: <code>execve</code>。该系统调用加载指定可执行文件并且执行，这样一来父子进程就完全不一样了。</p>
<p>和传统的系统调用一样，execve的系统调用入口是体系结构相关的<code>sys_execve</code>函数，紧接着<code>sys_execve</code>函数会调用体系结构无关的<code>do_execve</code>函数，因此我们下面主要研究的就是<code>do_execve</code>函数，在介绍该函数之前，需要先简单介绍一点前置知识</p>
<ul>
<li><code>linux_binprm</code>该结构在execve函数中比较重要，它包含了进程执行新文件的所有信息，进程地址空间、可执行文件名、可执行文件、环境变量、程序参数等</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> buf[BINPRM_BUF_SIZE];   <span class="comment">// 用于存储可执行文件头部128字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span>  <span class="comment">// 进程新的地址空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                            </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_ARG_PAGES	32</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>[<span class="title">MAX_ARG_PAGES</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>   <span class="comment">// 进程新的mm结构</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> p; <span class="comment">/* current top of mem */</span> <span class="comment">// 进程当前内存的最大地址</span></span><br><span class="line">	<span class="keyword">int</span> sh_bang;  <span class="comment">// 和执行sbin有关</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span> <span class="comment">// 可执行文件</span></span><br><span class="line">	<span class="keyword">int</span> e_uid, e_gid;  <span class="comment">// 权限相关</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span> cap_inheritable, cap_permitted;</span><br><span class="line">	<span class="keyword">bool</span> cap_effective;</span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="keyword">int</span> argc, envc; <span class="comment">// 程序参数和环境变量个数</span></span><br><span class="line">	<span class="keyword">char</span> * filename;	<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">	<span class="keyword">char</span> * interp;		<span class="comment">/* Name of the binary really executed. Most</span></span><br><span class="line"><span class="comment">				   of the time same as filename, but could be</span></span><br><span class="line"><span class="comment">				   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line">	<span class="keyword">unsigned</span> interp_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> interp_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> loader, exec; <span class="comment">// 分别指向loader开始的地方和可执行区域开始的地方</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> argv_len; <span class="comment">// 程序参数数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>linux_binfmt</code>结构，不同的可执行文件有不同的格式，每种可执行文件的加载执行由<code>linux_binfmt</code>负责，Linux支持多种不同的可执行文件格式，因此由多个linux_binfmt实例，这些实例通过链表链接起来，表头为内核全局变量<code>formats</code>。Linux在执行可执行文件时会遍历该链表，根据不同可执行文件的特征(通常是魔数)来找到合适的<code>linux_binfmt</code>，调用该实例的方法将可执行文件加载进进程地址空间并执行。每种可执行文件的<code>linux_binfmt</code>必须首先使用<code>register_binfmt</code>向内核注册才能被使用。该结构一般包含以下方法:<ul>
<li><code>load_binary</code>: 用于加载普通程序</li>
<li><code>load_shlib</code>:用于加载共享库，即动态库</li>
<li><code>core_dump</code>:在程序错误的情况下输出内存转储，用于调试分析。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: 可执行文件名称</span></span><br><span class="line"><span class="comment">// argv: 执行参数</span></span><br><span class="line"><span class="comment">// envp: 环境变量</span></span><br><span class="line"><span class="comment">// regs: 进程用户态寄存器内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">char</span> * filename,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> __user *__user *argv,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> __user *__user *envp,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_p;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!bprm)</span><br><span class="line">		<span class="keyword">goto</span> out_ret;</span><br><span class="line">    <span class="comment">// 打开要执行的文件</span></span><br><span class="line">	file = open_exec(filename);</span><br><span class="line">	retval = PTR_ERR(file);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">		<span class="keyword">goto</span> out_kfree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行处理器间负载均衡，选择一个合适的cpu</span></span><br><span class="line">    <span class="comment">// 并且将当前将要执行execve的进程移动到合适cpu上</span></span><br><span class="line">    <span class="comment">// 在这里移动，由于程序还没有真正开始执行，</span></span><br><span class="line">    <span class="comment">// 因此对内存和缓存影响最小</span></span><br><span class="line">	sched_exec();</span><br><span class="line"></span><br><span class="line">	bprm-&gt;file = file;</span><br><span class="line">	bprm-&gt;filename = filename;</span><br><span class="line">	bprm-&gt;interp = filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化linux_binprm结构</span></span><br><span class="line">    <span class="comment">// 该函数主要初始化了进程新的内存地址空间，目前进程的</span></span><br><span class="line">    <span class="comment">// 内存地址空间和父进程完全一样，因此需要属于自己的mm</span></span><br><span class="line">    <span class="comment">// 其中主要设置了新的栈空间，并且如果当前进程有ldt描述符</span></span><br><span class="line">    <span class="comment">// 则拷贝到新的mm中</span></span><br><span class="line">	retval = bprm_mm_init(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数个数</span></span><br><span class="line">	bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">	<span class="keyword">if</span> ((retval = bprm-&gt;argc) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_mm;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环境变量个数</span></span><br><span class="line">	bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line">	<span class="keyword">if</span> ((retval = bprm-&gt;envc) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_mm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子</span></span><br><span class="line">	retval = security_bprm_alloc(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是检查二进制文件的可执行全县，然后将二进制</span></span><br><span class="line">    <span class="comment">// 文件头部的128字节读取到bprm的buf中</span></span><br><span class="line">    <span class="comment">// 该头部用于识别二进制文件格式等其他信息，后面会使用</span></span><br><span class="line">	retval = prepare_binprm(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将filename拷贝到bprm的栈中，因为此时bprm-&gt;filename</span></span><br><span class="line">    <span class="comment">// 已经位于内核空间，因此调用copy_strings_kernel</span></span><br><span class="line">	retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于前面拷贝了可执行文件名，所以p向下移动了</span></span><br><span class="line">    <span class="comment">// 此时exec指向的地方就是程序执行的地方</span></span><br><span class="line">	bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">    <span class="comment">// 从用户空间拷贝环境变量到新的内存空间中</span></span><br><span class="line">	retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">	env_p = bprm-&gt;p;</span><br><span class="line">    <span class="comment">// 从用户空间拷贝程序参数到内存空间中</span></span><br><span class="line">	retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">// 记录参数长度</span></span><br><span class="line">	bprm-&gt;argv_len = env_p - bprm-&gt;p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载并执行可执行文件</span></span><br><span class="line">	retval = search_binary_handler(bprm,regs);</span><br><span class="line">	<span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* execve success */</span></span><br><span class="line">		free_arg_pages(bprm);</span><br><span class="line">		security_bprm_free(bprm);</span><br><span class="line">		acct_update_integrals(current);</span><br><span class="line">		kfree(bprm);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	free_arg_pages(bprm);</span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;security)</span><br><span class="line">		security_bprm_free(bprm);</span><br><span class="line"></span><br><span class="line">out_mm:</span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;mm)</span><br><span class="line">		mmput (bprm-&gt;mm);</span><br><span class="line"></span><br><span class="line">out_file:</span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;file) &#123;</span><br><span class="line">		allow_write_access(bprm-&gt;file);</span><br><span class="line">		fput(bprm-&gt;file);</span><br><span class="line">	&#125;</span><br><span class="line">out_kfree:</span><br><span class="line">	kfree(bprm);</span><br><span class="line"></span><br><span class="line">out_ret:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们进一步深入进去，看看各个子函数，首先来看<code>bprm_mm_init</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bprm_mm_init</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 申请新的mm结构，一般从slab申请</span></span><br><span class="line">	bprm-&gt;mm = mm = mm_alloc();</span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一般当前进程的mm结构是执行fork时从父进程拷贝的</span></span><br><span class="line">    <span class="comment">// 如果当前进程使用了ldt，那么同样拷贝到新的mm中</span></span><br><span class="line">	err = init_new_context(current, mm);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建进程新的地址空间</span></span><br><span class="line">	err = __bprm_mm_init(bprm);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		bprm-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">		mmdrop(mm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __bprm_mm_init(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> err = -ENOMEM;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">bprm</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vma标识了进程的虚拟地址空间区域，暂时不用深究</span></span><br><span class="line">    <span class="comment">// 这里从slab申请一个新的vma对象</span></span><br><span class="line">	bprm-&gt;vma = vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!vma)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信号量同步</span></span><br><span class="line">	down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="comment">// 指向进程新的mm结构</span></span><br><span class="line">	vma-&gt;vm_mm = mm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Place the stack at the largest stack address the architecture</span></span><br><span class="line"><span class="comment">	 * supports. Later, we'll move this to an appropriate place. We don't</span></span><br><span class="line"><span class="comment">	 * use STACK_TOP because that can depend on attributes which aren't</span></span><br><span class="line"><span class="comment">	 * configured yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 一般来说STACK_TOP_MAX的值就是用户空间的最大地址值3G - 1</span></span><br><span class="line">    <span class="comment">// 而通常PAGE_SIZE = 4K，因此进程新的栈空间为4K，从用户空间的</span></span><br><span class="line">    <span class="comment">// 最高处想下增长</span></span><br><span class="line">	vma-&gt;vm_end = STACK_TOP_MAX;</span><br><span class="line">	vma-&gt;vm_start = vma-&gt;vm_end - PAGE_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置虚拟地址空间的一些标志和属性</span></span><br><span class="line">	vma-&gt;vm_flags = VM_STACK_FLAGS;</span><br><span class="line">	vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将进程新的栈空间放到mm中</span></span><br><span class="line">	err = insert_vm_struct(mm, vma);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">	mm-&gt;stack_vm = mm-&gt;total_vm = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 出临界区</span></span><br><span class="line">	up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 之所以减去一个指针，是因为vma使用的？</span></span><br><span class="line">	bprm-&gt;p = vma-&gt;vm_end - <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (vma) &#123;</span><br><span class="line">		bprm-&gt;vma = <span class="literal">NULL</span>;</span><br><span class="line">		kmem_cache_free(vm_area_cachep, vma);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于一个执行了execve调用的进程，会拥有新的用户栈空间，从最大用户地址开始向下延伸4K。</p>
<p>我们简单看一下<code>searh_binary_handler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(struct linux_binprm *bprm,struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">try</span>,retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span></span><br><span class="line">    <span class="comment">// 钩子</span></span><br><span class="line">	retval = security_bprm_check(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* kernel module loader fixup */</span></span><br><span class="line">	<span class="comment">/* so we don't try to load run modprobe in kernel space. */</span></span><br><span class="line">	set_fs(USER_DS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 审计信息，忽略</span></span><br><span class="line">	retval = audit_bprm(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = -ENOENT;</span><br><span class="line">    <span class="comment">// 一共尝试两次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">try</span>=<span class="number">0</span>; <span class="keyword">try</span>&lt;<span class="number">2</span>; <span class="keyword">try</span>++) &#123;</span><br><span class="line">        <span class="comment">// 临界区读写锁</span></span><br><span class="line">		read_lock(&amp;binfmt_lock);</span><br><span class="line">        <span class="comment">// 遍历所有的binaryfmt，找到和可执行文件匹配的项去加载</span></span><br><span class="line">		list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">			<span class="keyword">int</span> (*fn)(struct linux_binprm *, struct pt_regs *) = fmt-&gt;load_binary;</span><br><span class="line">			<span class="keyword">if</span> (!fn)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (!try_module_get(fmt-&gt;<span class="keyword">module</span>))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			read_unlock(&amp;binfmt_lock);</span><br><span class="line">            <span class="comment">// load_binary加载可执行文件</span></span><br><span class="line">			retval = fn(bprm, regs);</span><br><span class="line">            <span class="comment">// 加载成功</span></span><br><span class="line">			<span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放fmt，可执行文件</span></span><br><span class="line">				put_binfmt(fmt);</span><br><span class="line">				allow_write_access(bprm-&gt;file);</span><br><span class="line">				<span class="keyword">if</span> (bprm-&gt;file)</span><br><span class="line">					fput(bprm-&gt;file);</span><br><span class="line">				bprm-&gt;file = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">// 当前进程已经执行过</span></span><br><span class="line">				current-&gt;did_exec = <span class="number">1</span>;</span><br><span class="line">				proc_exec_connector(current);</span><br><span class="line">				<span class="keyword">return</span> retval;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 如果加载失败，则换下一个继续试</span></span><br><span class="line">			read_lock(&amp;binfmt_lock);</span><br><span class="line">			put_binfmt(fmt);</span><br><span class="line">			<span class="keyword">if</span> (retval != -ENOEXEC || bprm-&gt;mm == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (!bprm-&gt;file) &#123;</span><br><span class="line">				read_unlock(&amp;binfmt_lock);</span><br><span class="line">				<span class="keyword">return</span> retval;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		read_unlock(&amp;binfmt_lock);</span><br><span class="line">		<span class="keyword">if</span> (retval != -ENOEXEC || bprm-&gt;mm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMOD</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">#define printable(c) (((c)==<span class="string">'\t'</span>) || ((c)==<span class="string">'\n'</span>) || (<span class="number">0x20</span>&lt;=(c) &amp;&amp; (c)&lt;=<span class="number">0x7e</span>))</span><br><span class="line">			<span class="keyword">if</span> (printable(bprm-&gt;buf[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">			    printable(bprm-&gt;buf[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">			    printable(bprm-&gt;buf[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">			    printable(bprm-&gt;buf[<span class="number">3</span>]))</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">/* -ENOEXEC */</span></span><br><span class="line">			request_module(<span class="string">"binfmt-%04x"</span>, *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)(&amp;bprm-&gt;buf[<span class="number">2</span>]));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终调用和可执行文件匹配的项去加载可执行文件，如果重试两次仍然找不到则报错返回。通过这一节，对于Linux进程的内存空间映像，你应该有一个大致印象了吧，我们通过一张图来结束本节：<br><img src="4.png" alt></p>
<h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p>前面一次介绍了创建进程、执行进程，一个进程从创建到执行最后退出，是一个完成的生命周期，那么在本节将着重介绍进程退出细节。进程退出一般来说是分为两部分的：首先是进程释放出了<code>task_struct</code>之外的其他资源，然后给父进程发送信号表明自己死亡，此时进程处于僵尸状态，永远不会被调度执行，但是其占用的资源也永远不会被释放；接着父进程调用了wait4系列系统调用，确认了子进程的死亡，才会释放子进程最后的资源。当然，如果在创建子进程时父进程设置了标志表明自己不需要确认子进程死亡情况，那么子进程退出时就不会给父进程发送信号，而是直接释放自己的所有资源，包括<code>task_struct</code>。首先看以下<code>do_exit</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fastcall NORET_TYPE <span class="keyword">void</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="keyword">int</span> group_dead;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和退出流程无关，忽略</span></span><br><span class="line">	profile_task_exit(tsk);</span><br><span class="line"></span><br><span class="line">	WARN_ON(atomic_read(&amp;tsk-&gt;fs_excl));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果处于中断上下文，或者idle进程执行该函数</span></span><br><span class="line">    <span class="comment">// 说明内核出现了问题</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_interrupt()))</span><br><span class="line">		panic(<span class="string">"Aiee, killing interrupt handler!"</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tsk-&gt;pid))</span><br><span class="line">		panic(<span class="string">"Attempted to kill the idle task!"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果退出进程被跟踪调试并且设置了PT_TRACE_EXIT</span></span><br><span class="line">    <span class="comment">// 那么通知调试者进程，PT_TRACE_EXIT标志表明调试者进程</span></span><br><span class="line">    <span class="comment">// 希望被调试进程退出时停止执行，可以看到这里把退出码</span></span><br><span class="line">    <span class="comment">// 放到了ptrace_message中，这样调试进程就能够通过PTRACE_GETEVENTMSG</span></span><br><span class="line">    <span class="comment">// 获取退出进程的信息(参见kernel/ptrace.c ptrace_request函数)</span></span><br><span class="line">    <span class="comment">// 在ptrace_notify中可能会调用schedule。</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(current-&gt;ptrace &amp; PT_TRACE_EXIT)) &#123;</span><br><span class="line">		current-&gt;ptrace_message = code;</span><br><span class="line">		ptrace_notify((PTRACE_EVENT_EXIT &lt;&lt; <span class="number">8</span>) | SIGTRAP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're taking recursive faults here in do_exit. Safest is to just</span></span><br><span class="line"><span class="comment">	 * leave this task alone and wait for reboot.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 大概率不会执行</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">		printk(KERN_ALERT</span><br><span class="line">			<span class="string">"Fixing recursive fault but reboot is needed!\n"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We can do this unlocked here. The futex code uses</span></span><br><span class="line"><span class="comment">		 * this flag just to verify whether the pi state</span></span><br><span class="line"><span class="comment">		 * cleanup has been done or not. In the worst case it</span></span><br><span class="line"><span class="comment">		 * loops once more. We pretend that the cleanup was</span></span><br><span class="line"><span class="comment">		 * done as there is no way to return. Either the</span></span><br><span class="line"><span class="comment">		 * OWNER_DIED bit is set by now or we push the blocked</span></span><br><span class="line"><span class="comment">		 * task into the wait for ever nirwana as well.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;io_context)</span><br><span class="line">			exit_io_context();</span><br><span class="line">		set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程标志为PF_EXITING，表明进程正在退出</span></span><br><span class="line">	tsk-&gt;flags |= PF_EXITING;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * tsk-&gt;flags are checked in the futex code to protect against</span></span><br><span class="line"><span class="comment">	 * an exiting task cleaning up the robust pi futexes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 指令屏障，忽略之</span></span><br><span class="line">	smp_mb();</span><br><span class="line">	spin_unlock_wait(&amp;tsk-&gt;pi_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前处于禁止抢占状态，说明有问题</span></span><br><span class="line">    <span class="comment">// 因为没有理由这里会禁止抢占，内核校验</span></span><br><span class="line">    <span class="comment">// 大概率不会执行到，忽略之</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic()))</span><br><span class="line">		printk(KERN_INFO <span class="string">"note: %s[%d] exited with preempt_count %d\n"</span>,</span><br><span class="line">				current-&gt;comm, task_pid_nr(current),</span><br><span class="line">				preempt_count());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新一些统计信息，如果编译内核时没有启动CONFIG_TASKSTATS则该函数什么也不做</span></span><br><span class="line">    <span class="comment">// 否则主要更新退出进程常驻内存使用情况，虚拟内存使用情况以及</span></span><br><span class="line">    <span class="comment">// 用户态运行时间和内核台运行时间</span></span><br><span class="line">	acct_update_integrals(tsk);</span><br><span class="line">    <span class="comment">// 如果进程mm不为空，则更新mm的最大物理页数和最大虚拟页数</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;mm) &#123;</span><br><span class="line">		update_hiwater_rss(tsk-&gt;mm);</span><br><span class="line">		update_hiwater_vm(tsk-&gt;mm);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 递减当前线程总活动线程数量，如果递减完为0则返回true</span></span><br><span class="line">	group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line">    <span class="comment">// 如果当前进程是线程组最后一个活动线程，那么</span></span><br><span class="line">    <span class="comment">// 需要做一些额外的工作</span></span><br><span class="line">	<span class="keyword">if</span> (group_dead) &#123;</span><br><span class="line">        <span class="comment">// 如果判断当前进程所在线程组的组长就是当前</span></span><br><span class="line">        <span class="comment">// pid_namespace的init进程，那么需要向当前命名空间</span></span><br><span class="line">        <span class="comment">// 所有的进程都发送SIGKiLL信号，并且由当前进程调用wait4</span></span><br><span class="line">        <span class="comment">// 系统调用负责善后</span></span><br><span class="line">		exit_child_reaper(tsk);</span><br><span class="line">        <span class="comment">// 定时器相关</span></span><br><span class="line">		hrtimer_cancel(&amp;tsk-&gt;signal-&gt;real_timer);</span><br><span class="line">		exit_itimers(tsk-&gt;signal);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 统计信息收集，用户态运行时间，内核台运行时间</span></span><br><span class="line">    <span class="comment">// 主缺页次数，次缺页次数等，忽略之</span></span><br><span class="line">	acct_collect(code, group_dead);</span><br><span class="line">    <span class="comment">// 懒得去研究这个配置了，当做没有吧，忽略之</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tsk-&gt;robust_list))</span><br><span class="line">		exit_robust_list(tsk);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tsk-&gt;compat_robust_list))</span><br><span class="line">		compat_exit_robust_list(tsk);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 审计工作，懒得研究，忽略之</span></span><br><span class="line">	<span class="keyword">if</span> (group_dead)</span><br><span class="line">		tty_audit_exit();</span><br><span class="line">	<span class="keyword">if</span> (unlikely(tsk-&gt;audit_context))</span><br><span class="line">		audit_free(tsk);</span><br><span class="line">    <span class="comment">// 设置进程的退出码</span></span><br><span class="line">	tsk-&gt;exit_code = code;</span><br><span class="line">    <span class="comment">// 又是一些统计信息，实在不想看了</span></span><br><span class="line">	taskstats_exit(tsk, group_dead);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减少mm_user使用计数</span></span><br><span class="line">    <span class="comment">// 先增加mm_count使用计数，然后在mput中</span></span><br><span class="line">    <span class="comment">// 又减少了mm_count使用计数，因此总的来说mm_count没变</span></span><br><span class="line">    <span class="comment">// 该函数有个非常有意思的细节，我们后面单独说</span></span><br><span class="line">	exit_mm(tsk);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不看！！！</span></span><br><span class="line">	<span class="keyword">if</span> (group_dead)</span><br><span class="line">		acct_process();</span><br><span class="line">    <span class="comment">// 进程信号量</span></span><br><span class="line">	exit_sem(tsk);</span><br><span class="line">    <span class="comment">// 进程打开的文件</span></span><br><span class="line">	__exit_files(tsk);</span><br><span class="line">    <span class="comment">// 进程使用的文件系统</span></span><br><span class="line">	__exit_fs(tsk);</span><br><span class="line">    <span class="comment">// hmmm,忽略</span></span><br><span class="line">	check_stack_usage();</span><br><span class="line">    <span class="comment">// 进程的thread_info</span></span><br><span class="line">	exit_thread();</span><br><span class="line">    <span class="comment">// cgroup...虚拟化命名空间相关的东西</span></span><br><span class="line">	cgroup_exit(tsk, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 可能是密钥环</span></span><br><span class="line">	exit_keys(tsk);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (group_dead &amp;&amp; tsk-&gt;signal-&gt;leader)</span><br><span class="line">		disassociate_ctty(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 忽略之</span></span><br><span class="line">	module_put(task_thread_info(tsk)-&gt;exec_domain-&gt;<span class="keyword">module</span>);</span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;binfmt)</span><br><span class="line">		module_put(tsk-&gt;binfmt-&gt;<span class="keyword">module</span>);</span><br><span class="line">    <span class="comment">// 驱动相关的一些东西貌似是，忽略之</span></span><br><span class="line">	proc_exit_connector(tsk);</span><br><span class="line">    <span class="comment">// 比较重要，实际上如果进程在退出时需要给父进程信号，那么在该函数中就会调用schedule</span></span><br><span class="line">    <span class="comment">// 也就是说，后面的部分都不会被执行。</span></span><br><span class="line">	exit_notify(tsk);</span><br><span class="line">    <span class="comment">// 对于非一致性内存生效，算了有点儿麻烦，不说了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	mpol_free(tsk-&gt;mempolicy);</span><br><span class="line">	tsk-&gt;mempolicy = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we are holding no locks:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// debug用的，忽略</span></span><br><span class="line">	debug_check_no_locks_held(tsk);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We can do this unlocked here. The futex code uses this flag</span></span><br><span class="line"><span class="comment">	 * just to verify whether the pi state cleanup has been done</span></span><br><span class="line"><span class="comment">	 * or not. In the worst case it loops once more.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 设置当前进程标志，退出成功</span></span><br><span class="line">	tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;io_context)</span><br><span class="line">		exit_io_context();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;splice_pipe)</span><br><span class="line">		__free_pipe_info(tsk-&gt;splice_pipe);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用抢占</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="comment">/* causes final put_task_struct in finish_task_switch(). */</span></span><br><span class="line">    <span class="comment">// 设置状态为DEAD并调用schedule()，正常情况下永远不会再返回了，因此schedule永远</span></span><br><span class="line">    <span class="comment">// 不会调度DEAD状态的进程执行</span></span><br><span class="line">	tsk-&gt;state = TASK_DEAD;</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">	BUG();</span><br><span class="line">	<span class="comment">/* Avoid "noreturn function does return".  */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		cpu_relax();	<span class="comment">/* For when BUG is null */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>do_exit</code>函数主要是做了以下几部分工作</p>
<ol>
<li>向调试进程发信号，调用schedule唤醒调试进程(可能)</li>
<li>向当前命名空间所有进程发送KILL信号(可能)</li>
<li>乱七八糟的统计工作，审计信息</li>
<li>然后就是一堆exit_xx，负责各个子模块：mm、ipc信号、打开的文件、文件系统、thread_info</li>
<li>然后就是exit_notify，为退出进程的子进程找到合适的父进程，然后向退出进程的父进程发送信号并且调用schedule(可能)</li>
<li>如果exit_notify没有调用schedule，那么后面就是设置状态然后调用schedule.</li>
</ol>
<p>因为进程涉及到内核的各个子系统，因此进程退出时需要执行的工作也是不少，其中有些模块还并未介绍，因此这里就不详细介绍了，这里主要介绍exit_notify和exit_mm两个函数，其他部分类似ipc、文件相关，等介绍完其他模块后，再回过头来看，就没难度了。</p>
<p>先介绍<code>exit_mm</code>，为什么介绍mm呢？因为其中一个小操作觉得非常的有趣，想分享一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit_mm</span><span class="params">(struct task_struct * tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">tsk</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">// 不要被名字误导了，该函数主要是清空缓存的寄存器状态</span></span><br><span class="line">    <span class="comment">// 然后如果当前进程创建时使用了vfork，那么此时该进程的父进程</span></span><br><span class="line">    <span class="comment">// 还阻塞的vfork_done上，该函数负责执行comeplete，唤醒父进程</span></span><br><span class="line">	mm_release(tsk, mm);</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Serialize with any possible pending coredump.</span></span><br><span class="line"><span class="comment">	 * We must hold mmap_sem around checking core_waiters</span></span><br><span class="line"><span class="comment">	 * and clearing tsk-&gt;mm.  The core-inducing thread</span></span><br><span class="line"><span class="comment">	 * will increment core_waiters for each thread in the</span></span><br><span class="line"><span class="comment">	 * group with -&gt;mm != NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 信号量</span></span><br><span class="line">	down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="comment">// core_waiters记录了正在转储进程mm映像的进程数</span></span><br><span class="line">    <span class="comment">// 如果有则等着</span></span><br><span class="line">	<span class="keyword">if</span> (mm-&gt;core_waiters) &#123;</span><br><span class="line">		up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		<span class="keyword">if</span> (!--mm-&gt;core_waiters)</span><br><span class="line">			complete(mm-&gt;core_startup_done);</span><br><span class="line">		up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">		wait_for_completion(&amp;mm-&gt;core_done);</span><br><span class="line">		down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 增加mm_count的计数</span></span><br><span class="line">    <span class="comment">// 这里你可能非常奇怪，为什么释放mm，反而要增加计数呢</span></span><br><span class="line">    <span class="comment">// 别着急，这里其实非常有趣，我后面会介绍</span></span><br><span class="line">	atomic_inc(&amp;mm-&gt;mm_count);</span><br><span class="line">	BUG_ON(mm != tsk-&gt;active_mm);</span><br><span class="line">	<span class="comment">/* more a memory barrier than a real lock */</span></span><br><span class="line">	task_lock(tsk);</span><br><span class="line">    <span class="comment">// 将进程的mm置空，注意，这里进程的</span></span><br><span class="line">    <span class="comment">// active_mm还是存在的</span></span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="comment">// 进入懒惰tlb模式，因为有可能下一个进程</span></span><br><span class="line">    <span class="comment">// 是内核线程</span></span><br><span class="line">	enter_lazy_tlb(mm, current);</span><br><span class="line">	<span class="comment">/* We don't want this task to be frozen prematurely */</span></span><br><span class="line">	clear_freeze_flag(tsk);</span><br><span class="line">	task_unlock(tsk);</span><br><span class="line">    <span class="comment">// 该函数递减mm_user，如果mm_user = 0则调用mmdrop递减</span></span><br><span class="line">    <span class="comment">// mm_count, 如果mm_count为0则将mm_struct返还给slab</span></span><br><span class="line">    <span class="comment">// mm_count和mm_user的关系见https://blog.csdn.net/wen0605/article/details/8703337</span></span><br><span class="line">	mmput(mm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们来说一说exit_mm中非常有趣的地方：为什么明明是exit_mm，但是却增加了mm_count的计数呢？其实有两个原因</p>
<ol>
<li>当前进程正在用的页表目录信息存储在mm_struct中，如果不增加mm_count，那么mmput递减后发现mm_count为0，则会释放mm_struct给slab，该操作也会释放mm中的页目录信息以及pgd。但是其实当前退出进程在此刻以及以后都不会访问用户空间了，因此实际上只需要内核空间。个人理解可以将swagger_pg_dir加载进入cr3，然后释放mm_struct，不过这样的话就会导致tlb刷新等操作，可能开销比较大。而且目前看来内核页表只是作为在fork新进程时作为模版使用，如果让用户进程直接使用内核页表，可能存在问题？</li>
<li>第二个作用就设置到进程切换了，可以说，正是由于这里增大了mm_count，在finish_task_switch中才能够仍然访问到当前退出进程的mm_struct，并且在那里该进程的mm_struct和task_struct会被彻底释放，由于进程切换暂时还没介绍，所以这里就不赘述，只是贴一篇<a href="https://blog.51cto.com/dog250/1273512" target="_blank" rel="noopener">文章</a>，等后面介绍完进程调度相关内容后再回过头来看，会更有体会。</li>
<li>顺带再说一句，这里之所以开启懒惰tlb模式，是考虑到下一个进程可能是内核线程，因此是无需刷新tlb等操作的。</li>
</ol>
<p>简单介绍了<code>exit_mm</code>，下面就着重介绍一下<code>exit_notify</code>函数，该函数主要作用是为退出进程的子进程重新找到父亲进程，如果需要的话会向退出进程的父进程发送信号并执行schedule函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit_notify</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">    <span class="comment">// 如果当前退出进程有挂起的信号并且SIGNAL_GROUP_EXIT没有置位，并且退出进程所在线程组</span></span><br><span class="line">    <span class="comment">// 不为空，说明当前进程有信号待处理并且所在线程组也没有处于退出状态</span></span><br><span class="line">    <span class="comment">// 并且线程组不为空，那么需要进行额外操作</span></span><br><span class="line">    <span class="comment">// 这种情况发生在选择了当前退出进程作为唤醒者的群体信号和退出系统调用同时发生时的竞争</span></span><br><span class="line">    <span class="comment">// 因此在退出之前，该线程应该完成最后的使命，唤醒线程组的所有线程，保证组内有的进程</span></span><br><span class="line">    <span class="comment">// 能够获取到挂起的信号</span></span><br><span class="line">	<span class="keyword">if</span> (signal_pending(tsk) &amp;&amp; !(tsk-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_EXIT)</span><br><span class="line">	    &amp;&amp; !thread_group_empty(tsk)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This occurs when there was a race between our exit</span></span><br><span class="line"><span class="comment">		 * syscall and a group signal choosing us as the one to</span></span><br><span class="line"><span class="comment">		 * wake up.  It could be that we are the only thread</span></span><br><span class="line"><span class="comment">		 * alerted to check for pending signals, but another thread</span></span><br><span class="line"><span class="comment">		 * should be woken now to take the signal since we will not.</span></span><br><span class="line"><span class="comment">		 * Now we'll wake all the threads in the group just to make</span></span><br><span class="line"><span class="comment">		 * sure someone gets all the pending signals.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		spin_lock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">        <span class="comment">// 遍历线程组</span></span><br><span class="line">		<span class="keyword">for</span> (t = next_thread(tsk); t != tsk; t = next_thread(t))</span><br><span class="line">            <span class="comment">// 如果当前进程没有设置TIF_SIGPENDING并且没有处于退出状态</span></span><br><span class="line">            <span class="comment">// 那么需要当前进程对该进程进行唤醒，而对于那些处于退出状态的进程来水</span></span><br><span class="line">            <span class="comment">// 他们本身就不需要处理信号；对于设置了TIF_SIGPENDING标志的进程来说</span></span><br><span class="line">            <span class="comment">// 它们肯定会被唤醒并且处理相应信号，不需要这里手动唤醒</span></span><br><span class="line">            <span class="comment">// TIF_SIGPENDING标志表明进程有待处理的信号</span></span><br><span class="line">			<span class="keyword">if</span> (!signal_pending(t) &amp;&amp; !(t-&gt;flags &amp; PF_EXITING))</span><br><span class="line">                <span class="comment">// 话说这个函数里面重复设置了SIGPENDING标志，然后我翻看了</span></span><br><span class="line">                <span class="comment">// 最新的Linux版本，发现还有这个问题，果断提了个patch过去</span></span><br><span class="line">                <span class="comment">// 这是后话了</span></span><br><span class="line">				recalc_sigpending_and_wake(t);</span><br><span class="line">		spin_unlock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This does two things:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">  	 * A.  Make init inherit all the child processes</span></span><br><span class="line"><span class="comment">	 * B.  Check to see if any process groups have become orphaned</span></span><br><span class="line"><span class="comment">	 *	as a result of our exiting, and if they have any stopped</span></span><br><span class="line"><span class="comment">	 *	jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 重要逻辑，后面说</span></span><br><span class="line">	forget_original_parent(tsk);</span><br><span class="line">	exit_task_namespaces(tsk);</span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check to see if any process groups have become orphaned</span></span><br><span class="line"><span class="comment">	 * as a result of our exiting, and if they have any stopped</span></span><br><span class="line"><span class="comment">	 * jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Case i: Our father is in a different pgrp than we are</span></span><br><span class="line"><span class="comment">	 * and we were the only connection outside, so our pgrp</span></span><br><span class="line"><span class="comment">	 * is about to become orphaned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 获取退出进程的real_parent，也就是fork出</span></span><br><span class="line">    <span class="comment">// 该进程的父进程</span></span><br><span class="line">	t = tsk-&gt;real_parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取退出进程所在的进程组</span></span><br><span class="line">	pgrp = task_pgrp(tsk);</span><br><span class="line">    <span class="comment">// 判断，如果当前进程是所在进程组和外界联系的唯一进程</span></span><br><span class="line">    <span class="comment">// 也就是说当前进程退出之后当前进程所在的进程组就变成孤儿进程组了</span></span><br><span class="line">    <span class="comment">// 并且进程组里面有STOP状态的进程，则向进程组中的所有进程</span></span><br><span class="line">    <span class="comment">// 发送SIGHUP和SIGCONT两次信号，SIGHUP默认会杀死进程</span></span><br><span class="line">    <span class="comment">// 除非进程自定义了处理操作</span></span><br><span class="line">	<span class="keyword">if</span> ((task_pgrp(t) != pgrp) &amp;&amp;</span><br><span class="line">	    (task_session(t) == task_session(tsk)) &amp;&amp;</span><br><span class="line">	    will_become_orphaned_pgrp(pgrp, tsk) &amp;&amp;</span><br><span class="line">	    has_stopped_jobs(pgrp)) &#123;</span><br><span class="line">		__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);</span><br><span class="line">		__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Let father know we died</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Thread signals are configurable, but you aren't going to use</span></span><br><span class="line"><span class="comment">	 * that to send signals to arbitary processes.</span></span><br><span class="line"><span class="comment">	 * That stops right now.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If the parent exec id doesn't match the exec id we saved</span></span><br><span class="line"><span class="comment">	 * when we started then we know the parent has changed security</span></span><br><span class="line"><span class="comment">	 * domain.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If our self_exec id doesn't match our parent_exec_id then</span></span><br><span class="line"><span class="comment">	 * we have changed execution domain as these two values started</span></span><br><span class="line"><span class="comment">	 * the same after a fork.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 这块不太理解原因，不过不影响</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;exit_signal != SIGCHLD &amp;&amp; tsk-&gt;exit_signal != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">	    ( tsk-&gt;parent_exec_id != t-&gt;self_exec_id  ||</span><br><span class="line">	      tsk-&gt;self_exec_id != tsk-&gt;parent_exec_id)</span><br><span class="line">	    &amp;&amp; !capable(CAP_KILL))</span><br><span class="line">		tsk-&gt;exit_signal = SIGCHLD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If something other than our normal parent is ptracing us, then</span></span><br><span class="line"><span class="comment">	 * send it a SIGCHLD instead of honoring exit_signal.  exit_signal</span></span><br><span class="line"><span class="comment">	 * only has special meaning to our real parent.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// exit_signal == -1表示父进程不关心子进程的退出</span></span><br><span class="line">    <span class="comment">// 这里不等于-1(说明父进程需要查看子进程的退出信息，也就是说子进程退出时不能释放task_struct结构)</span></span><br><span class="line">    <span class="comment">// 并且退出进程时线程组的最后一个进程</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;exit_signal != <span class="number">-1</span> &amp;&amp; thread_group_empty(tsk)) &#123;</span><br><span class="line">        <span class="comment">// 如果tsk-&gt;parent 不等于 tsk-&gt;real_parent, 说明有进程正在跟踪调试当前进程</span></span><br><span class="line">        <span class="comment">// 一次向调试进程发送SIGCHLD信号，否则向fork出当前进程的父进程发送指定的退出</span></span><br><span class="line">        <span class="comment">// 信号</span></span><br><span class="line">		<span class="keyword">int</span> signal = tsk-&gt;parent == tsk-&gt;real_parent ? tsk-&gt;exit_signal : SIGCHLD;</span><br><span class="line">		do_notify_parent(tsk, signal);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;ptrace) &#123;</span><br><span class="line">		do_notify_parent(tsk, SIGCHLD);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程状态为僵尸状态</span></span><br><span class="line">	state = EXIT_ZOMBIE;</span><br><span class="line">    <span class="comment">// 如果父进程表明不需要子进程退出后给它发信号并且也没有调试进程</span></span><br><span class="line">    <span class="comment">// 跟踪当前进程，那么当前进程就需要在退出前自己释放task_struct等资源</span></span><br><span class="line">    <span class="comment">// 因此这里直接把状态设置为死亡状态</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;exit_signal == <span class="number">-1</span> &amp;&amp; likely(!tsk-&gt;ptrace))</span><br><span class="line">		state = EXIT_DEAD;</span><br><span class="line">	tsk-&gt;exit_state = state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前进程是线程组的组长并且线程组所有的线程都</span></span><br><span class="line">    <span class="comment">// 被杀死了，那么唤醒group_exit_task</span></span><br><span class="line">    <span class="comment">// 该部分涉及到execve函数中binfmt的load_binary函数</span></span><br><span class="line">    <span class="comment">// 所以前面没有细说，参考一下这篇博客吧</span></span><br><span class="line">    <span class="comment">// http://blog.chinaunix.net/uid-30126070-id-5073809.html</span></span><br><span class="line">	<span class="keyword">if</span> (thread_group_leader(tsk) &amp;&amp;</span><br><span class="line">	    tsk-&gt;signal-&gt;notify_count &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    tsk-&gt;signal-&gt;group_exit_task)</span><br><span class="line">		wake_up_process(tsk-&gt;signal-&gt;group_exit_task);</span><br><span class="line"></span><br><span class="line">	write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the process is dead, release it - nobody will wait for it */</span></span><br><span class="line">    <span class="comment">// 走到这里说明，父进程不需要子进程的退出信号通知</span></span><br><span class="line">    <span class="comment">// 并且也没有进程在调试追踪该进程，那么该进程在退出时需要自己负责</span></span><br><span class="line">    <span class="comment">// 释放剩下的所有资源(除了mm_struct，因此随后的schedule还会使用到，并且由</span></span><br><span class="line">    <span class="comment">// schedule函数选择的下一个进程负责释放)</span></span><br><span class="line">	<span class="keyword">if</span> (state == EXIT_DEAD)</span><br><span class="line">        <span class="comment">// 单独说</span></span><br><span class="line">		release_task(tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍到这里，整个退出流程就只剩下<code>forget_original_parent</code>和<code>release_task</code>两个函数没有介绍了，接着来吧，从<code>forget_original_parent</code>开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forget_original_parent</span><span class="params">(struct task_struct *father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, *<span class="title">n</span>, *<span class="title">reaper</span> = <span class="title">father</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_dead</span>;</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;ptrace_dead);</span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为退出进程的子进程门寻找新的父进程，首先是在退出进程</span></span><br><span class="line">    <span class="comment">// 的线程组里面找，如果找不到，那么让当前进程所在命名空间的</span></span><br><span class="line">    <span class="comment">// init进程作为新的父进程</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		reaper = next_thread(reaper);</span><br><span class="line">		<span class="keyword">if</span> (reaper == father) &#123;</span><br><span class="line">			reaper = task_child_reaper(father);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (reaper-&gt;flags &amp; PF_EXITING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are only two places where our children can be:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - in our child list</span></span><br><span class="line"><span class="comment">	 * - in our ptraced child list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Search them and reparent children.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 遍历退出进程所有的子进程</span></span><br><span class="line">	list_for_each_entry_safe(p, n, &amp;father-&gt;children, sibling) &#123;</span><br><span class="line">		<span class="keyword">int</span> ptrace;</span><br><span class="line"></span><br><span class="line">		ptrace = p-&gt;ptrace;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if father isn't the real parent, then ptrace must be enabled */</span></span><br><span class="line">        <span class="comment">// 对于当前子进程p，如果他位于退出进程的子进程链表中</span></span><br><span class="line">        <span class="comment">// 那么它的parent肯定是当前进程，此时又有两种情况</span></span><br><span class="line">        <span class="comment">// 1. 退出进程是它的real_parent，即fork出它的进程</span></span><br><span class="line">        <span class="comment">// 2. 退出进程是它的parent，即跟踪调试它的进程</span></span><br><span class="line">        <span class="comment">// 如果两个都不是，那就是有bug</span></span><br><span class="line">		BUG_ON(father != p-&gt;real_parent &amp;&amp; !ptrace);</span><br><span class="line">        <span class="comment">// 如果是fork它的进程，那么为子进程重新寻找新的父进程</span></span><br><span class="line">		<span class="keyword">if</span> (father == p-&gt;real_parent) &#123;</span><br><span class="line">			<span class="comment">/* reparent with a reaper, real father it's us */</span></span><br><span class="line">			p-&gt;real_parent = reaper;</span><br><span class="line">			reparent_thread(p, father, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* reparent ptraced task to its real parent */</span></span><br><span class="line">            <span class="comment">// 到这里说明当前进程是被退出进程跟踪调试的进程</span></span><br><span class="line">            <span class="comment">// 因此该进程的parent是将要退出调试进程，并且在退出进程的链表中</span></span><br><span class="line">            <span class="comment">// 那么这里做的就是将该进程从退出进程的链表中移出</span></span><br><span class="line">            <span class="comment">// 并且重新执行该进程的parent进程为real_parent</span></span><br><span class="line">			__ptrace_unlink (p);</span><br><span class="line">            <span class="comment">// 如果当前进程处于僵尸状态，并且父进程需要该进程的退出信息</span></span><br><span class="line">            <span class="comment">// 并且该进程所在进程组已经为空，则向父进程发送退出信号唤醒之</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;exit_state == EXIT_ZOMBIE &amp;&amp; p-&gt;exit_signal != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">			    thread_group_empty(p))</span><br><span class="line">				do_notify_parent(p, p-&gt;exit_signal);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * if the ptraced child is a zombie with exit_signal == -1</span></span><br><span class="line"><span class="comment">		 * we must collect it before we exit, or it will remain</span></span><br><span class="line"><span class="comment">		 * zombie forever since we prevented it from self-reap itself</span></span><br><span class="line"><span class="comment">		 * while it was being traced by us, to be able to see it in wait4.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 如果当前进程被即将退出进程跟踪，并且处于EXIT_ZOMBIE状态并且其父进程也不关心</span></span><br><span class="line">        <span class="comment">// 它的死活，那么由退出进程负责释放该进程的剩余资源</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(ptrace &amp;&amp; p-&gt;exit_state == EXIT_ZOMBIE &amp;&amp; p-&gt;exit_signal == <span class="number">-1</span>))</span><br><span class="line">			list_add(&amp;p-&gt;ptrace_list, &amp;ptrace_dead);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前进程的调试链表，把所有被当前进程跟踪的调试进程添加</span></span><br><span class="line">    <span class="comment">// 到新的进程的ptrace_child链表中</span></span><br><span class="line">    <span class="comment">// 一般是退出进程的兄弟进程或者是当前命名空间的init进程</span></span><br><span class="line">	list_for_each_entry_safe(p, n, &amp;father-&gt;ptrace_children, ptrace_list) &#123;</span><br><span class="line">		p-&gt;real_parent = reaper;</span><br><span class="line">		reparent_thread(p, father, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">// 到这里要求没有任何进程和当前退出进程关联</span></span><br><span class="line">	BUG_ON(!list_empty(&amp;father-&gt;children));</span><br><span class="line">	BUG_ON(!list_empty(&amp;father-&gt;ptrace_children));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 就像上面说的，释放僵尸进程的剩余资源</span></span><br><span class="line">	list_for_each_entry_safe(p, n, &amp;ptrace_dead, ptrace_list) &#123;</span><br><span class="line">		list_del_init(&amp;p-&gt;ptrace_list);</span><br><span class="line">		release_task(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍完了<code>forget_original_parent</code>，可以发现函数主要是负责为所有和当前进程相关的子进程和调试子进程找到一个新的归宿，其中少不了还有一些其他操作。下面再介绍最后一个函数<code>release_task</code>。可能到这里你已经有点懵了，但是别慌，后面我会把整个退出流程完整的再捋一遍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_task</span><span class="params">(struct task_struct * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">leader</span>;</span></span><br><span class="line">	<span class="keyword">int</span> zap_leader;</span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">// 减少用户拥有的进程数</span></span><br><span class="line">	atomic_dec(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">	proc_flush_task(p);</span><br><span class="line">	write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">// 如果当前进程被跟踪调试，则将当前进程</span></span><br><span class="line">    <span class="comment">// 从调试进程的ptrac_childre中移除</span></span><br><span class="line">    <span class="comment">// 添加到当前进程real_parent所在的children链表中</span></span><br><span class="line">    <span class="comment">// 并且修改parent为real_parent</span></span><br><span class="line">	ptrace_unlink(p);</span><br><span class="line">    <span class="comment">// 按道理来说执行完do_exit的进程这两个链表应该都为空，若不为空说明有问题</span></span><br><span class="line">	BUG_ON(!list_empty(&amp;p-&gt;ptrace_list) || !list_empty(&amp;p-&gt;ptrace_children));</span><br><span class="line">    <span class="comment">// 清除信号相关结构</span></span><br><span class="line">	__exit_signal(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are the last non-leader member of the thread</span></span><br><span class="line"><span class="comment">	 * group, and the leader is zombie, then notify the</span></span><br><span class="line"><span class="comment">	 * group leader's parent process. (if it wants notification.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	zap_leader = <span class="number">0</span>;</span><br><span class="line">	leader = p-&gt;group_leader;</span><br><span class="line">	<span class="keyword">if</span> (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE) &#123;</span><br><span class="line">		BUG_ON(leader-&gt;exit_signal == <span class="number">-1</span>);</span><br><span class="line">		do_notify_parent(leader, leader-&gt;exit_signal);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we were the last child thread and the leader has</span></span><br><span class="line"><span class="comment">		 * exited already, and the leader's parent ignores SIGCHLD,</span></span><br><span class="line"><span class="comment">		 * then we are the one who should release the leader.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * do_notify_parent() will have marked it self-reaping in</span></span><br><span class="line"><span class="comment">		 * that case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		zap_leader = (leader-&gt;exit_signal == <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">// 体系结构相关，忽略</span></span><br><span class="line">	release_thread(p);</span><br><span class="line">    <span class="comment">// 释放task_struct以及和其相关的一些信息</span></span><br><span class="line">	call_rcu(&amp;p-&gt;rcu, delayed_put_task_struct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 像上面英文注释的那样，这里还需要释放组长线程的task_struct结构</span></span><br><span class="line">	p = leader;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(zap_leader))</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里进程退出的故事就结束了，通过介绍可以发现：如果父进程创建进程时表明不需要关注子进程退出信息，那么子进程就会在退出时自己负责清楚自己占用的task_struct及其相关资源；如果父进程需要关注子进程退出信息，那么子进程退出时不能直接清理task_struct、signal等信息，需要等父进程调用wait4后才能清除；但是如果父进程表明需要关注子进程的退出信息，但是却忘了调用wait4，那么就会产生僵尸进程，也就是已经退出的子进程还占用着资源。如果父进程退出了，那么僵尸进程其实会被init进程慢慢清除，但是如果父进程一直不退出，并且也不调用wait系统调用，还大量创建子进程，那么就会出现问题。其实对于现代计算机来说，占用task_struct、signal等资源所耗费的内存空间并不多，主要的一点在与一个用户创建的进程数量是有限制的、PID也是有限的，如果僵尸进程过多，那么用户可能无法创建新进程！对于wait系列的系统调用不打算在这里介绍了，一是因为这一块属于signal的范畴，二是因为到目前为止文章已经过长了。</p>
<p>好了，我们梳理一下进程退出时的整体逻辑(后面我们用当前进程来代指退出进程)</p>
<ol>
<li>判断是否在中断上下文或者退出的进程是idle(0)号进程，如果是说明有问题，直接panic。中断上下文要求及断的时间，肯定是不能执行这种操作的，而idle进程的生命周期是整个系统的生命周期，自然也是不能中途退出的，因此这种属于系统bug</li>
<li>如果当前进程被跟踪调试并且设置了<code>PT_TRACE_EXIT</code>，那么需要向调试进程发送信号，告知当前进程退出码，这里可能会调用schedule()函数，这样的话当前进程就会停在这里，PT_TRACE_EXIT标志表明调试进程希望当前进程在退出前向其发送信号并停止</li>
<li>判断当前是否处于禁止抢占状态，如果是则打印消息；按道理来说此时不应该禁止抢占。</li>
<li>更新一些统计信息，比如用户态，内核态运行时间，更新当前进程的最大物理页数和最大虚拟页数等(这些需要根据编译内核时是否配置相关项而决定是否进行统计)</li>
<li>判断当前进程是否是所在线程组中最后一个活动进程，如果是那么当前进程需要做一些额外工作：<ol>
<li>如果当前进程所在线程组的组长就是当前线程所在pid命名空间的init进程，那么此时需要向当前命名空间的所有进程发送KILL信号。</li>
<li>清除定时器相关信息</li>
</ol>
</li>
<li>设置当前进程的退出码<code>task_struct.exit_code</code></li>
<li>mm结构处理：清除当前进程对其mm_struct的引用并且进入懒惰tlb模式(其中如果有其他线程在dump mm信息则等待)</li>
<li>ipc处理：清除和当前进程有关的ipc信息</li>
<li>文件处理：清除当前进程打开的文件信息</li>
<li>文件系统处理：清除当前进程使用的文件系统信息</li>
<li>接下来就是调用<code>exit_notify</code>完成以下工作<ol>
<li>如果当前进程有挂起的信号并且当前进程所在线程组不处于退出状态，并且有其他的线程存在，那么需要唤醒线程组中每个不处于退出状态且没有挂起信号的进程，让它们进行信号处理。这样做主要是为了防止这样一种情况：当前进程作为整个线程组的唤醒者接收了发送给线程组的信号，但是同时它执行了exit系统调用将要退出，如果当前进程直接退出，那么会造成<code>不处于退出状态且没有挂起信号</code>这类进程的信号丢失，因此当前进程需要先完成最后的任务</li>
<li>调用<code>forget_original_parent</code>为当前进程的子进程和当前进程跟踪调试的子进程(下面统称子进程，除非在需要的时候会区分开来)做善后工作：<ol>
<li>为子进程们寻找新的父进程：遍历当前进程所在的线程组，如果找到一个不处于退出状态的，那么这个进程就是其子进程们的新父进程；如果一个都没找到，那么选当前进程所在命名空间的init进程作为新的父进程</li>
<li>遍历子进程链表(<code>task_struct.children</code>)：对于每一个子进程，判断该子进程是由当前进程fork创建出来的(即real_parent指向当前进程)，还是被当前进程跟踪调试的(即parent指向当前进程)<ol>
<li>如果是前者，则设置子进程的real_parent为<code>11.2.1</code>步找到的新进程，并且将<code>parent</code>也指向新进程，把子进程从当前进程的子进程链表移除，加入到新进程的子进程链表中(<code>children</code>)，并且取消子进程的跟踪状态(如果设置了的话，说明当前进程既是子进程的fork进程，也是跟踪进程)</li>
<li>如果是后者，则将子进程从当前进程的跟踪子进程链表(ptrace_children)中移除，并且将进程的parent指向real_parent，最后加入到real_parent的子进程链表中。这时候如果发现该子进程处于僵尸状态并且父进程需要关注子进程退出状态(exit_signal ≠ -1)并且子进程呢所在线程组没有别的子进程了，那么需要向parent(也就是real_parent)发送信号</li>
<li>如果子进程被当前进程跟踪并且处于僵尸状态，但是父进程不关注子进程的退出情况(也就是说不会调用wait并且回收子进程的最后资源)，那么当前进程需要负责释放这些子进程的task_struct以及signal等资源</li>
</ol>
</li>
<li>遍历调试子进程链表(ptrace_childre)，重新设置子进程的real_parent并且将该进程加入到real_parent的调试子进程链表中</li>
<li>需要注意的是，对于上面<code>2和3</code>步骤中遍历到的每个子进程，如果它们的新父进程不是和当前进程在一个进程组，并且子进程不被跟踪、处于僵尸状态、exit_signal ≠ -1，那么此时也需要向新的父进程发送signal消息告知新的父进程其已经死亡；另外，如果当前进程退出后其子进程会变成僵尸进程组，那么需要向进程组中的每个进程发送HUP和CONT信号。</li>
</ol>
</li>
<li>上面步骤判断了当前进程退出后子进程组是否是僵尸进程并且进行一些处理工作，这里则判断当前进程退出后当前进程所在进程组是否会成为僵尸进程组，如果是则和前面一样的处理</li>
<li>如果当前进程exit_signal ≠ -1，并且当前进程所在线程组为空，则需要向parent指向的进程发送信号(如果parent指向调试进程，那么只发送SIGCHLD信号，如果指向real_parent则发送exit_signal指定的信号)</li>
<li>如果当前进程exit_signal == -1并且没有被其他进程跟踪调试，那么设置进程状态为DEAD，否则设置为ZOMBIE(进程有两个状态，一个是state一个是exit_state)</li>
<li>如果当前进程时所在线程组的leader并且所有的其他进程都已经退出，并且<code>group_exit_task</code>不为空，说明进程执行execve系统调用时发现进程所在线程组还有存活的线程，因此向所有这些线程发送KILL信号，并且等待线程结束；这里说明已经结束了，因此唤醒前面执行execve的进程</li>
<li>如果进程状态为DEAD，则需要当前进程自己释放资源(task_struct以及信号等)</li>
</ol>
</li>
<li>禁止内核抢占</li>
<li>修改进程状态为DEAD(注意这里只是设置了state，exit_state还没有变)</li>
<li>调用schedule()，选择下一个可执行进程</li>
<li>下一个可执行进程切换完毕后执行<code>finish_task_switch</code>中，会调用put_task_struct函数将前一个退出进程的进程引用计数-1，但是回头看一下fork函数就可以发现，进程在初始化时，设置引用计数为2，因此如果进程的exit_state是ZOMBIE，那么此时task_struct仍然没有被释放，实际上会在do_wait中由父进程释放一次后，引用计数变为0，此时才会最终被释放</li>
</ol>
<h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1><p>本来打算把进程调度和进程切换相关的部分也在这一节介绍完毕的，但是现在看来是不行了..因此目前已经写了太多了，好了，就把进程调度和进程切换放到下一篇文章吧。总结一下，本文主要介绍了Linux的命名空间，简单了解了Linux命名空间如何实现资源隔离，以及如何支持docker等虚拟化技术，并且详细的介绍了PID命名空间；紧接着介绍了进程创建、内核线程、进程执行以及进程退出四方面内容，包含了进程的大部分知识。不过由于进程涉及到系统的各个方面，和多个子系统都有所联系，比如内存、ipc、信号、文件系统等，有关这些模块的介绍实际上只是浅尝辄止，并没有深入进入。等后面介绍了相应模块之后，再回过头来看这些吧。</p>

    </div>

    
    
    
	<div>
	
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------</div>
    
</div>

	
	</div>
	<div>
      
        
      
	</div>
        
      
        <div id="reward-container">
  <div>如果你喜欢，请我喝杯茶呗...</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="郭源潮 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/SourceCode/" rel="tag"><i class="fa fa-tag"></i>SourceCode</a>
            
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i>Linux</a>
            
              <a href="/tags/2-6-24/" rel="tag"><i class="fa fa-tag"></i>2.6.24</a>
            
              <a href="/tags/2-6-11/" rel="tag"><i class="fa fa-tag"></i>2.6.11</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2022/01/15/IA-32架构开发人员手册-3-分页/" rel="next" title="IA-32架构开发人员手册-3-分页">
                  <i class="fa fa-chevron-left"></i> IA-32架构开发人员手册-3-分页
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程介绍"><span class="nav-number">1.</span> <span class="nav-text">进程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程优先级"><span class="nav-number">1.2.</span> <span class="nav-text">进程优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#硬实时进程"><span class="nav-number">1.2.1.</span> <span class="nav-text">硬实时进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软实时进程"><span class="nav-number">1.2.2.</span> <span class="nav-text">软实时进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通进程"><span class="nav-number">1.2.3.</span> <span class="nav-text">普通进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级划分"><span class="nav-number">1.2.4.</span> <span class="nav-text">优先级划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程生命周期"><span class="nav-number">1.2.5.</span> <span class="nav-text">进程生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux进程实现"><span class="nav-number">2.</span> <span class="nav-text">Linux进程实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标识进程"><span class="nav-number">2.1.</span> <span class="nav-text">标识进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程状态"><span class="nav-number">2.1.1.</span> <span class="nav-text">进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可运行状态-TASK-RUNNING"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">可运行状态(TASK_RUNNING)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可中断睡眠状态-TASK-INTERRUPTIBLE"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">可中断睡眠状态(TASK_INTERRUPTIBLE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可中断睡眠状态-TASK-UNINTERRUPTIBLE"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">不可中断睡眠状态(TASK_UNINTERRUPTIBLE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可终止不可中断睡眠状态-TASK-KILLABLE"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">可终止不可中断睡眠状态(TASK_KILLABLE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暂停状态-TASK-STOPPED"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">暂停状态(TASK_STOPPED)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跟踪状态-TASK-TRACED"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">跟踪状态(TASK_TRACED)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#僵尸状态-TASK-ZOMBIE"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">僵尸状态(TASK_ZOMBIE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死亡状态-EXIT-DEAD"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">死亡状态(EXIT_DEAD)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程资源限制"><span class="nav-number">2.1.2.</span> <span class="nav-text">进程资源限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间"><span class="nav-number">2.2.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#层次化命名空间"><span class="nav-number">2.2.1.</span> <span class="nav-text">层次化命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非层次化命名空间"><span class="nav-number">2.2.2.</span> <span class="nav-text">非层次化命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间创建"><span class="nav-number">2.2.3.</span> <span class="nav-text">命名空间创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">2.2.4.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UTS命名空间"><span class="nav-number">2.2.5.</span> <span class="nav-text">UTS命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户命名空间"><span class="nav-number">2.2.6.</span> <span class="nav-text">用户命名空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程ID"><span class="nav-number">2.3.</span> <span class="nav-text">进程ID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程ID-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">进程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PID管理"><span class="nav-number">2.3.2.</span> <span class="nav-text">PID管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PID命名空间"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">PID命名空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构-1"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#任务1"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">任务1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#任务2"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">任务2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成唯一PID"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">生成唯一PID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程关系"><span class="nav-number">2.3.3.</span> <span class="nav-text">进程关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程相关系统调用"><span class="nav-number">2.4.</span> <span class="nav-text">进程相关系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程复制"><span class="nav-number">2.4.1.</span> <span class="nav-text">进程复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#写时复制-COW"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">写时复制(COW)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行系统调用"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">执行系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#do-fork"><span class="nav-number">2.4.1.2.1.</span> <span class="nav-text">do_fork</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核线程"><span class="nav-number">2.4.2.</span> <span class="nav-text">内核线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#懒惰tlb模式"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">懒惰tlb模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建内核线程方式"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">创建内核线程方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程执行"><span class="nav-number">2.4.3.</span> <span class="nav-text">进程执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程退出"><span class="nav-number">2.4.4.</span> <span class="nav-text">进程退出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小节"><span class="nav-number">3.</span> <span class="nav-text">小节</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/images.png"
      alt="郭源潮">
  <p class="site-author-name" itemprop="name">郭源潮</p>
  <div class="site-description" itemprop="description">时间在无声的诉说着一切</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/guoyuanchao1202" title="GitHub &rarr; https://github.com/guoyuanchao1202" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:932552424@qq.com" title="E-Mail &rarr; mailto:932552424@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/6273792268?is_all=1" title="Weibo &rarr; https://weibo.com/u/6273792268?is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.w3school.com.cn/tags/tag_ul.asp" title="https://www.w3school.com.cn/tags/tag_ul.asp" rel="noopener" target="_blank">w3school</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭源潮</span>
</div>
	<div class="powered-by">
	<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
	  本站访客数:<span id="busuanzi_value_site_uv"></span>
	  <span id="busuanzi_container_site_pv">
	  本站总访问量<span id="busuanzi_value_site_pv"></span>次
	  </span>
	</span>
	</div>
<!--

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.0</div>
-->

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='96,96,96' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

 
  <script type = "text/javascript"  src ="dist/canvas-nest.js"> </script>
 
</body>
</html>
