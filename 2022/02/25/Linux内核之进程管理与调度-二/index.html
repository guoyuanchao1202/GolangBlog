<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="上一篇文章主要介绍了x86-32位平台下Linux2.6.24版本下进程的创建、执行、内核线程、退出几部分内容，本节主要介绍进程调度相关内容，主要包括：Linux2.6.24下调度器实现、内核抢占实现、进程切换细节、调度时机等。除非特别说明，本文源码均基于x86-32 Linux2.6.24，并且默认开启内核抢占；并且对于超出本节内容的部分：比如中断、异常等，不会进行深入介绍。">
<meta name="keywords" content="SourceCode,Linux,2.6.24,2.6.11">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核之进程管理与调度(二)">
<meta property="og:url" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/index.html">
<meta property="og:site_name" content="CommonGuy">
<meta property="og:description" content="上一篇文章主要介绍了x86-32位平台下Linux2.6.24版本下进程的创建、执行、内核线程、退出几部分内容，本节主要介绍进程调度相关内容，主要包括：Linux2.6.24下调度器实现、内核抢占实现、进程切换细节、调度时机等。除非特别说明，本文源码均基于x86-32 Linux2.6.24，并且默认开启内核抢占；并且对于超出本节内容的部分：比如中断、异常等，不会进行深入介绍。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/1.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/2.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/3.png">
<meta property="og:updated_time" content="2022-03-03T14:17:32.602Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux内核之进程管理与调度(二)">
<meta name="twitter:description" content="上一篇文章主要介绍了x86-32位平台下Linux2.6.24版本下进程的创建、执行、内核线程、退出几部分内容，本节主要介绍进程调度相关内容，主要包括：Linux2.6.24下调度器实现、内核抢占实现、进程切换细节、调度时机等。除非特别说明，本文源码均基于x86-32 Linux2.6.24，并且默认开启内核抢占；并且对于超出本节内容的部分：比如中断、异常等，不会进行深入介绍。">
<meta name="twitter:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/1.png">
  <link rel="canonical" href="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Linux内核之进程管理与调度(二) | CommonGuy</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/HoA-W" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CommonGuy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://guoyuanchao1202/GolangBlog.github.io/2022/02/25/Linux内核之进程管理与调度-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭源潮">
      <meta itemprop="description" content="时间在无声的诉说着一切">
      <meta itemprop="image" content="/images/images.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CommonGuy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Linux内核之进程管理与调度(二)

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-02-25 22:35:16" itemprop="dateCreated datePublished" datetime="2022-02-25T22:35:16+08:00">2022-02-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 22:17:32" itemprop="dateModified" datetime="2022-03-03T22:17:32+08:00">2022-03-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上一篇文章主要介绍了<code>x86-32位</code>平台下<code>Linux2.6.24</code>版本下进程的创建、执行、内核线程、退出几部分内容，本节主要介绍进程调度相关内容，主要包括：Linux2.6.24下调度器实现、内核抢占实现、进程切换细节、调度时机等。除非特别说明，本文源码均基于<code>x86-32 Linux2.6.24</code>，并且默认开启内核抢占；并且对于超出本节内容的部分：比如中断、异常等，不会进行深入介绍。</p>
<hr>
<a id="more"></a>
# 概念

<p>在多道程序设计系统中，系统中可以同时运行多个程序，至少在用户看起来是这样的。但是实际上，系统上真正并行执行的进程数量最多等于系统的处理器数量(也就是我们常说的核心数量)，之所以在用户感知是大量程序并发执行，是因为操作系统负责把多个进程在处理器上轮流执行，又因为处理器的执行速度和我们人类感知速度不在一个量级上，这才给我们造成了一种多个程序并发执行的错觉。</p>
<p>在Linux内核中，内核跟踪了每个进程的描述符<code>task_struct</code>，并且通过若干结构与其他进程连接起来。调度器要做的事情就是：在程序之间共享CPU时间，创造并行执行的错觉。调度器功能主要有两个：</p>
<ol>
<li>使用具体的调度策略选择合适的进程使用CPU</li>
<li>进行进程间的上下文切换</li>
</ol>
<p>内核必须提供一种方法，在各个进程之间尽可能公平的共享CPU时间，而同时又要考虑不同任务的优先级。完成这样一种目的，有许多方法，各有利弊，这里不做争论，本文只对Linux2.6.24版本的调度策略进行介绍。</p>
<p><code>schedule()</code>函数是Linux调度的起点，即进程调度的唯一入口，定义在<code>kernel/sched.c</code>中，是内核中最常见的代码之一。<br>Linux调度器的实现受到了一下若干因素的影响：</p>
<ol>
<li>在所处理器系统上(SMP)，必须要注意几个细节，以避免调度器自相干扰</li>
<li>不仅实现了优先调度，还实现了Posix标准需要的其他两种软实时策略</li>
<li>使用goto语句以生成最优的汇编代码(对结构化程序设计的所有原理背道而驰，但是性能赞)</li>
</ol>
<p>本节后面的介绍中将暂时忽略实时进程，只考虑完全公平调度器(在介绍源码实现时会对实时调度进行介绍)，2.6.24版本的Linux调度器一个杰出特性就是：它不需要时间片的概念，至少不需要传统的时间片。如果你对Linux2.6.11的O(1)调度器有所了解的话，相信你会非常喜爱2.6.24版本的调度器实现，相比于2.6.11各种启发式规则以及各种时间片概念计算，2.6.24将会显得非常清晰易懂，等后面我介绍完源码后，相信你一定会深有体会。传统的调度器对系统中的进程分别计算时间片，使进程运行直至时间片用尽，所有进程的时间片都已经用尽时了，则需要重新计算(为了简单描述，实际上对O(1)调度器做了非常非常大的简化，简化到甚至严格上来说是错误的，不过不用纠结，这不是本文的重点，本文重点是为了突出介绍CFS)。相比之下，当前版本的调度器只考虑进程的等待时间，即进程在就绪队列中已经等待了多长时间，对CPU时间需求最严格的进程被调度执行。</p>
<p>对于严格的CFS来说，应该是保证系统中的每个进程都被公平的对待(CFS的理论概念这里就不赘述了，不影响我们理解Linux的实现，一点儿也不)，但是由于一些现实因素的影响，Linux没有采用这种思想：</p>
<ol>
<li>进程的不同优先级必须得到考虑，更加重要的进程必须比相对次要的进程获得更多的CPU时间</li>
<li>进程不能切换得太频繁，因为上下文切换(从一个进程切换到另一个进程)，是有一定开销的。在切换太频繁时，过多时间花费在进程切换过程中，而不是用于实际工作。</li>
<li>两次相邻的任务切换间，时间也不能太长，否则会积累较大的不公平(其他进程等待太久)，对于多媒体系统来说，进程运行时间太长会导致延迟增大</li>
</ol>
<p>另外，如果编译Linux内核时激活了调度器统计，那么会在运行时生成/proc/sched_debug，其中包含了调度器当前状态所有方面的信息。</p>
<h1 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h1><p>在Linux内核实现中，通常会在什么时候选择执行进程调度呢，换句话说，Linux的调度时机有哪些呢？主要有以下几种：</p>
<ol>
<li>进程状态转换时刻：进程终止、进程睡眠。例如：进程执行sleep或exit时，会显式调用schedule()</li>
<li>周期性调度器检查到当前进程运行时间超出限制(时钟中断出发)，后面会说到周期性调度器</li>
<li>设备驱动程序执行长而重复的工作时，每次循环都检查是否需要进行调度，如果需要则调用schedule()</li>
<li>从<code>中断</code>、<code>异常</code>、<code>系统调用</code>返回，检查进程标志(后面会介绍)来判断是否需要调度，如果需要则调用schedule()</li>
</ol>
<h1 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h1><p>在Linux内核中，内核跟踪了每个进程的描述符<code>task_struct</code>，并且通过若干结构与其他进程连接起来。调度器要做的事情就是：在程序之间共享CPU时间，创造并行执行的错觉。调度器功能主要有两个：</p>
<ol>
<li>使用具体的调度策略选择合适的进程使用CPU</li>
<li>进行进程间的上下文切换</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>调度器使用一系列数据结构，来排序和管理系统中的进程。调度器的工作方式与这些结构的设计密切相关。几个组件在许多方面彼此交互。如图所示：<br><img src="1.png" alt><br>可以看到，图中清晰的描述了各个组件之间的交互：</p>
<ol>
<li>无论是主调度器还是周期性调度器，都通过具体的调度器类来选择合适的进程</li>
<li>调度器选择进程后，需要执行进程间切换，此时需要借助CPU帮助</li>
<li>周期性调度器被时钟中断触发执行(实际上时钟中断会触发CPU执行特定的中断处理程序，因此还是和CPU交互)</li>
<li>系统中的进程同一时刻只能属于一个调度器类</li>
</ol>
<p>在后面的介绍中，除非特别说明，否则我将核心调度器和周期性调度器统称为通用调度器。正如上面说的，每个进程都刚好属于某个调度器类，各个调度器类负责管理所属的进程，而通用调度器自身完全不涉及进程管理，其工作完全委托给调度器类。如果你学习过一门面向对象语言，那么可以这么理解：所有的调度器类可以理解为实现了特定接口的实现类，而通用调度器只需要调用接口方法实现特定的工作，而实际上不需要知道具体是什么调度器类；另外，不同调度器类之间也不需要相互交互。</p>
<h3 id="task-struct中调度相关字段"><a href="#task-struct中调度相关字段" class="headerlink" title="task_struct中调度相关字段"></a>task_struct中调度相关字段</h3><p>进程的<code>task_struct</code>中有一些字段和调度相关，主要如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span></span><br><span class="line">    constb <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line">    <span class="keyword">cpumask_t</span> cpus_allowed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>前面就有提到过，并非系统上所有的进程都同样重要(氪金玩家当然更重要.-.)。不那么紧急的进程不需要太多的关注，而重要的工作应该尽可能快速完成。为了确定特定进程的重要性，Linux给进程增加了相对优先级属性。Linux采用了3个成员来表示进程的优先级。</p>
<ul>
<li><code>静态优先级(static_prio)</code>：进程启动时分配的优先级，可以使用<code>nice</code>和<code>sched_setscheduler</code>系统调用修改，否则在进程运行时保持不变。</li>
<li><code>普通优先级(normal_prio)</code>：基于进程静态优先级和调度策略计算出的优先级。因此如果普通进程和实时进程具有相同的静态优先级，它们的调度策略不同，所以计算而来的普通优先级也不同</li>
<li><code>动态优先级(prio)</code>：在某些情况下，内核需要暂时提高进程的优先级(内核同步的实时互斥量可能会提高动态优先级从而使得优先级较低的进程先运行，不是本文重点，忽略之)，因此需要新增一个优先级，也就是动态优先级来表示。由于此改变不是永久的，因此静态优先级和普通优先级不受影响。</li>
</ul>
<h4 id="实时优先级"><a href="#实时优先级" class="headerlink" title="实时优先级"></a>实时优先级</h4><p><code>rt_priority</code>标识实时进程的优先级。该值不会代替先前讨论的那些值。最高实时优先级为0，最低实时优先级为99。<code>值越大，优先级越低</code></p>
<h4 id="调度类"><a href="#调度类" class="headerlink" title="调度类"></a>调度类</h4><p><code>sched_class</code>表示进程所属的调度类，参考上面的图，可以发现每个进程属于且仅属于一个调度类</p>
<h4 id="调度实体"><a href="#调度实体" class="headerlink" title="调度实体"></a>调度实体</h4><p>Linux该版本开始，调度器不限于调度进程，还可以调度更大的实体。这样的特点可以方便实现组调度：可用的CPU时间可以首先在一般的进程组(比如所有进程可以简单的按照用户分组)之间分配，然后把进程组分配到的时间再在进程之间分配。</p>
<p>要实现这样的目标，就要求调度器不直接操作进程，而是处理可调度实体。一个实体由<code>sched_entity</code>表示。最简单的情况下，调度器调度各个进程，由于调度器只能调度调度实体，因此Linux在task_struct中内嵌了sched_entity结构，使得task_struct也成为了一个调度实体</p>
<h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><p><code>policy</code>保存了对该进程应用的调度策略，Linux目前支持5个可能的值</p>
<ul>
<li><code>SCHED_NORMAL</code>用于普通进程，我们后面也是主要讲述此类进程。它们通过完全公平调度器来处理。另外<code>SCHED_BATCH</code>和<code>SCHED_IDLE</code>也通过完全公平调度器来处理，不过可以用于次要的进程。</li>
<li><code>SCHED_BATCH</code>用于非交互，CPU使用密集的批处理进程。调度决策对此类进程给予<code>冷处理</code>：他们绝不会抢占CFS调度器的另一个进程，因此绝不会干扰交互式进程。如果不使用nice降低进程的静态优先级，同时又不希望该进程影响系统的交互性，此时最适合使用该调度器类。</li>
<li><code>SCHED_IDLE</code>进程重要性最低，因为其相对权重是最小的(后面介绍权重计算时会说)。<code>SCHED_IDLE</code>一般是<code>IDLE</code>进程，在系统中没有课可运行进程时，会调度IDLE进程运行</li>
<li><code>SCHED_RR</code>和<code>SCHED_FIFO</code>用于实现软实时进程。其中<code>SCHED_RR</code>实现了一种循环方法，而<code>SCHED_FIFO</code>则使用先进先出机制。这两类策略不是由完全公平调度器类处理，而是有实时调度器类处理，后面也会介绍这些调度器实现。</li>
</ul>
<h4 id="CPU控制位"><a href="#CPU控制位" class="headerlink" title="CPU控制位"></a>CPU控制位</h4><p><code>cpu_allows</code>是一个位域，在多处理器上使用，用来限制进程可以在哪些CPU上执行</p>
<h4 id="循环调度器相关"><a href="#循环调度器相关" class="headerlink" title="循环调度器相关"></a>循环调度器相关</h4><p><code>run_list</code>和<code>time_slice</code>是循环实时调度器所需要的，CFS并不需要这两个字段。其中<code>run_list</code>是一个表头，用于维护包含各进程的一个运行表，而<code>time_slice</code>则指定进程可使用CPU的剩余时间段</p>
<h3 id="辅助函数-标志"><a href="#辅助函数-标志" class="headerlink" title="辅助函数/标志"></a>辅助函数/标志</h3><h4 id="辅助标志"><a href="#辅助标志" class="headerlink" title="辅助标志"></a>辅助标志</h4><p>对于Linux调度器来说，有一个非常重要的标志就是<code>TIF_NEED_RESCHED</code>标志。如果对活动进程设置了该标志，那么调度器即知道CPU将从该进程回收并赋予新进程。</p>
<h4 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h4><ul>
<li><p><code>rt_policy()</code>：用于判断给定的调度策略是否属于实时类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rt_policy</span><span class="params">(<span class="keyword">int</span> policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是实时策略，返回true</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(policy == SCHED_FIFO) || unlikely(policy == SCHED_RR))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>task_has_rt_policy</code>：用于判断给定进程是否采用实时调度策略，只是对上面的函数做了简单的包装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">task_has_rt_policy</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rt_policy(p-&gt;policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rt_prio</code>：判断给定优先级是否属于实时优先级，这和进程的调度策略无关，只是单纯的根据优先级的数值判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAX_RT_PRIO = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> rt_prio(<span class="keyword">int</span> prio)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(prio &lt; MAX_RT_PRIO))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>真正的辅助函数远不止这些，但是没关系，后面用到具体的函数之前，我会先介绍函数的作用，必要时会附带源码介绍。</p>
<h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>调度器类提供了通用调度器和各个调度器方法之间的关联。调度器类由特定数据结构中汇集的几个函数指针表示。通用调度器请求的各个操作都可以由一个指针表示，这种面向对象的设计使得通用调度器无需了解各个调度器类的内部实现(就像前面说的那样)。</p>
<p>我们暂时不考虑针对多处理器的扩展，调度器类结构如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*enqueue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> wakeup);</span><br><span class="line">	<span class="keyword">void</span> (*dequeue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> sleep);</span><br><span class="line">	<span class="keyword">void</span> (*yield_task) (struct rq *rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*check_preempt_curr) (struct rq *rq, struct task_struct *p);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>) (<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*put_prev_task) (struct rq *rq, struct task_struct *p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP <span class="comment">// 针对多处理器系统的增强功能，其实主要是多处理器间的负载均衡</span></span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*load_balance)</span> <span class="params">(struct rq *this_rq, <span class="keyword">int</span> this_cpu,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct rq *busiest, <span class="keyword">unsigned</span> <span class="keyword">long</span> max_load_move,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct sched_domain *sd, <span class="keyword">enum</span> cpu_idle_type idle,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> *all_pinned, <span class="keyword">int</span> *this_best_prio)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*move_one_task) (struct rq *this_rq, <span class="keyword">int</span> this_cpu,</span><br><span class="line">			      struct rq *busiest, struct sched_domain *sd,</span><br><span class="line">			      <span class="keyword">enum</span> cpu_idle_type idle);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*set_curr_task) (struct rq *rq);</span><br><span class="line">	<span class="keyword">void</span> (*task_tick) (struct rq *rq, struct task_struct *p);</span><br><span class="line">	<span class="keyword">void</span> (*task_new) (struct rq *rq, struct task_struct *p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于各个调度器类，都必须提供<code>sched_class</code>的一个实。并且调度器类之间的层次结构是平坦的：实时进程最重要，完全公平进程其次，而IDLE进程只有在CPU无事可做时才会被调度执行，<code>sched_class.next</code>字段将不同的调度器类按照顺序连接起来，因此在选择合适进程执行时，会先在实时进程的队列中寻找，如果实时进程队列中没有合适的进程，然后才会去CFS就绪队列中寻找，以此类推。</p>
<p>上面这句话可能不太好理解，下面通过源码和一张图来帮助理解调度器类之间的关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sched_class_highest (&amp;rt_sched_class)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span> = &#123;</span></span><br><span class="line">	.next			= &amp;fair_sched_class, <span class="comment">// 可以看到rt调度器类后面就是cfs</span></span><br><span class="line">	.enqueue_task		= enqueue_task_rt,</span><br><span class="line">	.dequeue_task		= dequeue_task_rt,</span><br><span class="line">	.yield_task		= yield_task_rt,</span><br><span class="line"></span><br><span class="line">	.check_preempt_curr	= check_preempt_curr_rt,</span><br><span class="line"></span><br><span class="line">	.pick_next_task		= pick_next_task_rt,</span><br><span class="line">	.put_prev_task		= put_prev_task_rt,</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	.load_balance		= load_balance_rt,</span><br><span class="line">	.move_one_task		= move_one_task_rt,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	.set_curr_task          = set_curr_task_rt,</span><br><span class="line">	.task_tick		= task_tick_rt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span> = &#123;</span></span><br><span class="line">	.next			= &amp;idle_sched_class, <span class="comment">// 可以看到cfs调度器后面就是idle</span></span><br><span class="line">	.enqueue_task		= enqueue_task_fair,</span><br><span class="line">	.dequeue_task		= dequeue_task_fair,</span><br><span class="line">	.yield_task		= yield_task_fair,</span><br><span class="line"></span><br><span class="line">	.check_preempt_curr	= check_preempt_wakeup,</span><br><span class="line"></span><br><span class="line">	.pick_next_task		= pick_next_task_fair,</span><br><span class="line">	.put_prev_task		= put_prev_task_fair,</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	.load_balance		= load_balance_fair,</span><br><span class="line">	.move_one_task		= move_one_task_fair,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	.set_curr_task          = set_curr_task_fair,</span><br><span class="line">	.task_tick		= task_tick_fair,</span><br><span class="line">	.task_new		= task_new_fair,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span> = &#123;</span></span><br><span class="line">	.next			= &amp;idle_sched_class,</span><br><span class="line">	.enqueue_task		= enqueue_task_fair,</span><br><span class="line">	.dequeue_task		= dequeue_task_fair,</span><br><span class="line">	.yield_task		= yield_task_fair,</span><br><span class="line"></span><br><span class="line">	.check_preempt_curr	= check_preempt_wakeup,</span><br><span class="line"></span><br><span class="line">	.pick_next_task		= pick_next_task_fair,</span><br><span class="line">	.put_prev_task		= put_prev_task_fair,</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	.load_balance		= load_balance_fair,</span><br><span class="line">	.move_one_task		= move_one_task_fair,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	.set_curr_task          = set_curr_task_fair,</span><br><span class="line">	.task_tick		= task_tick_fair,</span><br><span class="line">	.task_new		= task_new_fair,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调度器之间的关系如图所示<br><img src="2.png" alt><br>然后schedule()函数在选择下一个占用CPU的进程时，会按照这个顺序搜寻，因此最先查看实时调度器类队列中有没有可运行进程，然后才是cfs调度器，最后才是idle调度器。</p>
<ul>
<li><code>enqueue_task</code>：向调度器队列提供一个新进程。在进程从睡眠状态变为可运行状态时，会发生该操作。</li>
<li><code>dequeue_task</code>：将进程从调度器队列中移除。进程从可运行状态变成不可运行状态时，就会发生该操作。当然，内核有可能因为其他原因将进程从调度器队列中去除，例如：进程的优先级改变，从CFS进程变成了实时进程，那么就需要把进程从CFS调度器的队列中移除，并且添加到实时调度器队列中。另外需要注意的是，这里虽然说的是调度器队列，但是调度器不一定使用队列的方式来管理进程，比如CFS调度器就是用红黑树来管理进程；因此这里说的队列是一种抽象的说法。</li>
<li><code>yield_task</code>：进程自愿放弃对处理器控制权时，可以使用<code>sched_yield</code>系统调用，此时内核将会调用进程所属调度器类的<code>yield_task</code>方法。</li>
<li><code>check_preempt_curr</code>：用一个新唤醒的进程来抢占当前进程。例如do_fork中创建新进程后会调用<code>wake_up_new_task</code>唤醒新进程，该函数那不可能会调用此函数</li>
<li><code>pick_next_task</code>用于选择下一个将要运行的进程，而<code>put_prev_task</code>则在用另外一个进程代替当前运行进程之前调用。</li>
<li><code>set_curr_task</code>在进程调度策略发生变化时调用</li>
<li><code>task_tick</code>在每次激活周期性调度器时，由周期性调度器调用</li>
<li><code>new_task</code>用于建立fork系统调用和调度器之间的关联，每次新进程建立后会调用new_task通知调度器</li>
</ul>
<p>以上各个函数后面会一一介绍其源码。</p>
<h3 id="就绪队列"><a href="#就绪队列" class="headerlink" title="就绪队列"></a>就绪队列</h3><p>通用调度器用于管理活动进程的主要数据结构之一就是<code>就绪队列</code>。注意要和上面说的调度器类队列区分开来，调度器类队列是每个调度器类各自管理的队列。而就绪队列则是属于CPU的，每个CPU都有自身的就绪队列，每个活动进程，只能出现在一个就绪队列中(言语表达比较会比较难以说清楚，稍后会通过一张图来表明两者的区别)。</p>
<p>就绪队列是通用调度器许多操作的起点，但是要注意的是：进程并不是由就绪队列成员直接管理的，进程管理是各个调度器类的职责，因此在各个就绪队列中嵌入了特定于调度器类的子就绪队列。CPU就绪队列数据结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">	 * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line">	<span class="comment">/* capture load from *all* tasks on this cpu: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>, *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	u64 clock, prev_clock_raw;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，为了简单起见，上面的rq结构省略了很多统计相关的字段和其它若干字段。</p>
<ul>
<li><code>nr_running</code>：记录了当前队列上可运行进程的数目，不考虑其优先级和调度类</li>
<li><code>load</code>：提供了就绪队列当前负荷的度量。队列负荷本质上与队列上当前活动进程数目成正比。其中各个进程又有优先级的作为权重。每个就绪队列的虚拟时钟速度就是基于这些信息。后面会详细介绍</li>
<li><code>cpu_load</code>：用于跟踪当前cpu负荷状态，多cpu间负载均衡会使用</li>
<li><code>cfs</code>：嵌入的属于cfs调度器类的调度器队列</li>
<li><code>rt</code>：嵌入的属于实时调度器类的调度器队列</li>
<li><code>curr</code>：指向当前运行进程的<code>task_struct</code>实例</li>
<li><code>idle</code>：指向idle进程的<code>task_struct</code>实例，在没有其他可运行进程时执行</li>
<li><code>clock</code>和<code>prev_clock_raw</code>用于实现就绪队列自身的时钟。每次调用周期性调度器时，都会更新clock的值。另外内核还提供了标准函数<code>updata_rq_clock</code>，可在操作调度器队列的调度器中多处使用。</li>
</ul>
<p>系统中所有就绪队列都在<code>runqueues</code>数组中，该数组每个元素分别对应于系统中的一个cpu。在单处理器系统中，由于只有一个cpu，因此数组只有一个元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(struct rq, runqueues)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="辅助函数-1"><a href="#辅助函数-1" class="headerlink" title="辅助函数"></a>辅助函数</h4><p>内核定义了一些就绪队列相关的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到指定cpu对应的rq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_rq(cpu)		(&amp;per_cpu(runqueues, (cpu)))</span></span><br><span class="line"><span class="comment">// 找到当前cpu对应的rq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> this_rq()		(&amp;__get_cpu_var(runqueues))</span></span><br><span class="line"><span class="comment">// 找到指定进程所在的rq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> task_rq(p)		cpu_rq(task_cpu(p))</span></span><br><span class="line"><span class="comment">// 找到指定cpu上正在运行的进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_curr(cpu)		(cpu_rq(cpu)-&gt;curr)</span></span><br></pre></td></tr></table></figure>

<h3 id="调度实体-1"><a href="#调度实体-1" class="headerlink" title="调度实体"></a>调度实体</h3><p>前面说过，当前版本的Linux能够调度实体，而进程也是通过内嵌调度实体的方式才能被调度器调度，下面就看一下调度实体数据结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>	<span class="title">load</span>;</span>		<span class="comment">/* for load-balancing */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>		<span class="title">run_node</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		on_rq;</span><br><span class="line"></span><br><span class="line">	u64			exec_start;</span><br><span class="line">	u64			sum_exec_runtime;</span><br><span class="line">	u64			vruntime;</span><br><span class="line">	u64			prev_sum_exec_runtime;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>load</code>：当前调度实体的权重，决定了调度器中各个实体占队列总负荷的比例。计算负荷权重是调度器的一项重任，因此CFS调度器所需要的虚拟时钟速度最终依赖于负荷，后面会详细介绍</li>
<li><code>run_node</code>：树节点，使得调度实体可以以红黑树的方式进行组织</li>
<li><code>on_rq</code>：表示该实体当前是否就在就绪队列上接受调度</li>
<li><code>time相关</code>：进程运行时，我们需要记录消耗的CPU时间，以用于完全公平调度器。sum_exec_runtime即用于该目的。跟踪运行时间是由<code>updata_curr</code>不断积累完成的。每次调用时，会计算当前时间和<code>exec_start</code>之间的差值，同时更新<code>exec_start</code>为当前时间。差值责备添加到<code>sum_exec_runtime</code>中</li>
<li><code>vruntime</code>：在进程执行期间虚拟时钟上流逝的时间数量由vruntime记载</li>
<li><code>prev_sum_exec_runtime</code>：在进程被撤销CPU时，会将<code>sum_exec_runtime</code>保存到<code>prev_sum_exec_runtime</code>中。周期性调度器会根据<code>sum_exec_runtime-prev_sum_exec_runtime</code>差值来判断当前进程是否已经占用CPU过久，如果超过某个限制，则强制进行进程切换。</li>
</ul>
<h3 id="优先级处理"><a href="#优先级处理" class="headerlink" title="优先级处理"></a>优先级处理</h3><p>从用户的角度来看，优先级非常简单，只是某个范围内的数字而已。但实际上，内核对优先级的处理远不止这么简单，相反，处理优先级还是比较复杂的。</p>
<h4 id="优先级内核表示"><a href="#优先级内核表示" class="headerlink" title="优先级内核表示"></a>优先级内核表示</h4><p>在用户空间可以通过<code>nice</code>调用设置进程的静态优先级，进程的nice值在[-20<del>19]之间。nice值越低，表明优先级越高。内核使用一个简单的数值范围，从[0</del>139]来表示内部优先级。优先级和数值关系相反，如图所示：<br><img src="3.png" alt><br>Linux提供了一些宏用于在不同表示形式之间转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通进程最小优先级数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USER_RT_PRIO	100</span></span><br><span class="line"><span class="comment">// 实时进程的最大优先级数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RT_PRIO		MAX_USER_RT_PRIO</span></span><br><span class="line"><span class="comment">// 普通进程的最大优先级数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PRIO		(MAX_RT_PRIO + 40)</span></span><br><span class="line"><span class="comment">// 普通进程默认优先级为120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PRIO		(MAX_RT_PRIO + 20)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将nice值转换为对应的优先级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NICE_TO_PRIO(nice)	(MAX_RT_PRIO + (nice) + 20)</span></span><br><span class="line"><span class="comment">// 将prio值转换为nice值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIO_TO_NICE(prio)	((prio) - MAX_RT_PRIO - 20)</span></span><br><span class="line"><span class="comment">// 获取指定进程的nice值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_NICE(p)		PRIO_TO_NICE((p)-&gt;static_prio)</span></span><br></pre></td></tr></table></figure>

<h4 id="计算优先级"><a href="#计算优先级" class="headerlink" title="计算优先级"></a>计算优先级</h4><p>Linux有三种优先级，分别是静态优先级、普通优先级、动态优先级，那么他们是如何计算的呢？static_prio是计算的起点，另外两种优先级都可以通过该优先级计算出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数同时修改了normal_prio和prio</span></span><br><span class="line">p-&gt;prio = effective_prio(p);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">effective_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计算normal_prio</span></span><br><span class="line">	p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are RT tasks or we were boosted to RT priority,</span></span><br><span class="line"><span class="comment">	 * keep the priority unchanged. Otherwise, update priority</span></span><br><span class="line"><span class="comment">	 * to the normal priority:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果该进程p的动态优先级</span></span><br><span class="line">    <span class="comment">// 数值上属于普通，那么返回normal_prio</span></span><br><span class="line">    <span class="comment">// 再结合外面的赋值操作，可以知道此时prio=normal_prio</span></span><br><span class="line">	<span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">		<span class="keyword">return</span> p-&gt;normal_prio;</span><br><span class="line">    <span class="comment">// 如果进程的动态优先级 &lt;= 100</span></span><br><span class="line">    <span class="comment">// 即属于实时进程，则prio不变</span></span><br><span class="line">	<span class="keyword">return</span> p-&gt;prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">normal_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果进程的调度策略为实时调度策略</span></span><br><span class="line">    <span class="comment">// 则普通优先级为100 - 1 - 实时优先级</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		prio = MAX_RT_PRIO<span class="number">-1</span> - p-&gt;rt_priority;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则普通优先级 = static_prio</span></span><br><span class="line">		prio = __normal_prio(p);</span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __normal_prio(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;static_prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道你有没有发现，在<code>efficative_prio</code>中检测实时进程是基于优先级数值，而不是基于进程的调度策略，这是为什么呢？这样做对于临时提高至实时优先级的非实时进程(在使用实时互斥量时)来说，是必要的。</p>
<p>进程分支出子进程时，子进程的静态优先级和普通优先级继承自父进程，子进程的动态优先级设置为父进程的普通优先级，这是为了防止父进程临时提高的实时优先级泄露给子进程。</p>
<h4 id="优先级作用"><a href="#优先级作用" class="headerlink" title="优先级作用"></a>优先级作用</h4><p>Linux为什么要设置三种优先级呢？三种优先级又各有什么作用呢？下面就来详细说一下，首先需要认识到一点，我们所说的实时优先级数值和非实时优先级数值(即0-99和100-139)，统统指的是prio，也就是动态优先级。因此下面如果不做特别说明，那么优先级指的就是动态优先级。</p>
<ol>
<li><code>静态优先级</code>：该优先级可以通过nice设置，主要用于CFS调度器调度的非实时进程，此类进程的权重就是通过静态优先级计算得出来的，而对于实时优先级进程，并没有用到静态优先级。</li>
<li><code>动态优先级</code>：动态优先级表示进程当前是实时进程还是非实时进程(prio &lt; 100则说明进程当前是实时进程，否则是非实时进程)，该类优先级只对实时进程有用，而对于非实时进程，它们被CFS调度器调度，他们具体的优先程度取决于他们的权重，也就是间接的取决于静态优先级</li>
<li><code>普通优先级</code>：说到这里你可能会疑惑，前面两个静态优先级和动态优先级一个影响非实时进程，一个影响实时进程，那么为什么还需要普通优先级呢？如果仅是这样，确实是不需要普通优先级。但是问题在于，Linux有时候需要将非进程优先级短暂的提高到实时优先级，而这个提高并不是长久的，因此需要额外用一个普通优先级来表示。</li>
<li><code>实时优先级</code>：实时优先级(rt_priority)，只会影响实时进程的普通优先级计算，从而进一步影响到动态优先级，非实时进程并不会用到这一优先级。</li>
</ol>
<p>对于非实时优先级，它并不考虑实时优先级，它的另外三种优先级总是想等，即总是等于静态优先级。<br>而对于实时进程，它并不考虑静态优先级，它的普通优先级为<code>MAX_RT_PRIO-1 - p-&gt;rt_priority</code>，即受到rt_priority的影响；而动态优先级，在创建时继承自父进程的普通优先级，当然也可以通过<code>sched_setscheduler</code>设置。该函数会修改实时优先级。如果sched_setscheduler希望将进程修改为实时进程，那么在同时也会修改静态优先级和动态优先级，如果希望将进程修改为普通进程，那么会将进程除了实时优先级之外的三种优先级都设置为静态优先级，而刚刚也说了，普通进程不使用实时优先级(set_scheduler做的工作当然不止这些，但是只需要涉及到优先级部分就够了)。</p>
<h4 id="计算权重负荷"><a href="#计算权重负荷" class="headerlink" title="计算权重负荷"></a>计算权重负荷</h4><p>前面说了，普通进程依赖静态优先级计算权重，权重对于CFS调度器来说非常重要，而对于实时进程来说，虽然也会计算权重，但是实际上实时调度器在调度实时进程时根本不会用到。因此下面介绍的权重负荷，实际上是针对CFS调度器调度的非实时进程。</p>
<p>需要注意的是，对于普通进程，创建时静态优先级是继承自父进程的，因此它的权重也和父进程一样，因此可以直接从父进程拷贝就好，不需要做改变。只有在静态优先级改变(比如nice系统调用)时，才需要对权重进行相应的修改。进程的权重保存在<code>task_struct.se.load</code>字段中，该字段是<code>load_weight</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> weight, inv_weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>weight</code>: 表示权重</li>
<li><code>inv_weight</code>: 标识被负荷权重除的结果，什么意思呢？这里都是用了普通的long类型，因此内核是无法直接存储<code>1/weight</code>的，而比需要借助乘法和移位来完成，所以就保存了<code>inv_weight</code>，inv_weight = 2^32 / weight。具体如何实现的这里就不展开了。</li>
</ul>
<p>Linux是这样设计的：进程每降低一个nice值，则多获得10%的CPU时间，相反的每升高一个nice值，则放弃10%的时间。为了实现这样的设计策略，内核将优先级转换为权重值，转换表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inverse (2^32/x) values of the prio_to_weight[] array, precalculated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In cases where the weight does not change often, we can use the</span></span><br><span class="line"><span class="comment"> * precalculated inverse to speed up arithmetics by turning divisions</span></span><br><span class="line"><span class="comment"> * into multiplications:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 prio_to_wmult[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">48388</span>,     <span class="number">59856</span>,     <span class="number">76040</span>,     <span class="number">92818</span>,    <span class="number">118348</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>    <span class="number">147320</span>,    <span class="number">184698</span>,    <span class="number">229616</span>,    <span class="number">287308</span>,    <span class="number">360437</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>    <span class="number">449829</span>,    <span class="number">563644</span>,    <span class="number">704093</span>,    <span class="number">875809</span>,   <span class="number">1099582</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>   <span class="number">1376151</span>,   <span class="number">1717300</span>,   <span class="number">2157191</span>,   <span class="number">2708050</span>,   <span class="number">3363326</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>   <span class="number">4194304</span>,   <span class="number">5237765</span>,   <span class="number">6557202</span>,   <span class="number">8165337</span>,  <span class="number">10153587</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>  <span class="number">12820798</span>,  <span class="number">15790321</span>,  <span class="number">19976592</span>,  <span class="number">24970740</span>,  <span class="number">31350126</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>  <span class="number">39045157</span>,  <span class="number">49367440</span>,  <span class="number">61356676</span>,  <span class="number">76695844</span>,  <span class="number">95443717</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span> <span class="number">119304647</span>, <span class="number">148102320</span>, <span class="number">186737708</span>, <span class="number">238609294</span>, <span class="number">286331153</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对内核使用的[0<del>39]范围中的每个nice(对应用户设置的[-20</del>19])，该数组都有一个对应项。各数组之间的乘数因子是<code>1.25</code>。为什么采用1.25这个因子呢？我们举个例子说明一下：假设进程A和B的nice值都是0，那么两个进程的权重都是1024，并且两个进程占用的CPU份额相等，各50%。即(1024+1024) / 1024 = 0.5。<br>如果进程B的nice增加1，那么B的CPU份额就需要减少10%，也就是说A得到CPU份额的55%，而B得到45%，这样的话就需要B的权重为1024 / 0.55 - 1024 = 820。此时B的CPU份额就是820 / (820 + 1024) = 0.45，因此乘数因子就应该是1024 / 820 = 1.25。</p>
<p>在执行静态优先级优先级到权重的转换时，也需要转换实时进程，虽然并没有用到(至少2.6.24没有用到)，内核通过<code>set_load_weight</code>进行静态优先级到权重的转换:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_load_weight</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是实时策略，那么由实时调度器调度，</span></span><br><span class="line">    <span class="comment">// 那么其权重是最高优先级(100)</span></span><br><span class="line">    <span class="comment">// 的普通进程权重的2倍</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_rt_policy(p)) &#123;</span><br><span class="line">		p-&gt;se.load.weight = prio_to_weight[<span class="number">0</span>] * <span class="number">2</span>;</span><br><span class="line">		p-&gt;se.load.inv_weight = prio_to_wmult[<span class="number">0</span>] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SCHED_IDLE tasks get minimal weight:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果是CFS调度器调度的进程，但是IDLE策略</span></span><br><span class="line">    <span class="comment">// 则将其权重设置的非常低，为2</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;policy == SCHED_IDLE) &#123;</span><br><span class="line">		p-&gt;se.load.weight = WEIGHT_IDLEPRIO;</span><br><span class="line">		p-&gt;se.load.inv_weight = WMULT_IDLEPRIO;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于调度器调度的除了IDLE的CFS的进程，根据静态优先级正常设置权重</span></span><br><span class="line">	p-&gt;se.load.weight = prio_to_weight[p-&gt;static_prio - MAX_RT_PRIO];</span><br><span class="line">	p-&gt;se.load.inv_weight = prio_to_wmult[p-&gt;static_prio - MAX_RT_PRIO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEIGHT_IDLEPRIO		2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WMULT_IDLEPRIO		(1 &lt;&lt; 31)</span></span><br></pre></td></tr></table></figure>

<p>如果你还有印象的话，就会发现属于每CPU的就绪队列中也关联到一个负荷权重。每次进程被添加到就绪队列中时，内核就会调用<code>inc_nr_running</code>函数，该函数增加就绪队列进程数以及就绪队列的权重</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc_nr_running</span><span class="params">(struct task_struct *p, struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rq-&gt;nr_running++;</span><br><span class="line">	inc_load(rq, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc_load</span><span class="params">(struct rq *rq, <span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	update_load_add(&amp;rq-&gt;load, p-&gt;se.load.weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_load_add</span><span class="params">(struct load_weight *lw, <span class="keyword">unsigned</span> <span class="keyword">long</span> inc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lw-&gt;weight += inc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用调度器"><a href="#通用调度器" class="headerlink" title="通用调度器"></a>通用调度器</h3><p>调度器的实现基于两个函数：周期性调度器和主调度器。这些函数根据进程的优先级分配CPU时间。下面将分别对周期性调度器和主调度器进行介绍</p>
<h4 id="周期性调度器"><a href="#周期性调度器" class="headerlink" title="周期性调度器"></a>周期性调度器</h4><p>周期性调度器由<code>scheduler_tick</code>实现。如果系统正在活动中，那么内核会按照频率HZ自动调用该函数(时钟中断)。如果没有进程在等待调度，那么在计算机电量不足的情况下，也可以关闭该调度器以减少耗电。该函数主要有两个任务</p>
<ol>
<li>管理内核中与整个系统和各个进程的调度相关的统计量，主要是对各种计数器加1</li>
<li>激活负责当前进程的调度器类的周期性调度方法</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler_tick</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前cpu的就绪队列</span></span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">    <span class="comment">// 获取当前就绪队列上正在运行的进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	u64 next_tick = rq-&gt;tick_timestamp + TICK_NSEC;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">    <span class="comment">// 主要工作就是更新当前队列的clock</span></span><br><span class="line">	__update_rq_clock(rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Let rq-&gt;clock advance by at least TICK_NSEC:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 这里可以理解为时钟偶尔出错时的一种保护工作</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rq-&gt;clock &lt; next_tick))</span><br><span class="line">		rq-&gt;clock = next_tick;</span><br><span class="line">	rq-&gt;tick_timestamp = rq-&gt;clock;</span><br><span class="line">    <span class="comment">// 更新cpu负载，其实就是利用就绪队列的负荷做一些计算，感兴趣</span></span><br><span class="line">    <span class="comment">// 可以自己看一下</span></span><br><span class="line">	update_cpu_load(rq);</span><br><span class="line">    <span class="comment">// 如果当前进程不是idle，那么调用指定调度器类的周期性方法</span></span><br><span class="line">	<span class="keyword">if</span> (curr != rq-&gt;idle) <span class="comment">/* <span class="doctag">FIXME:</span> needed? */</span></span><br><span class="line">		curr-&gt;sched_class-&gt;task_tick(rq, curr);</span><br><span class="line">	spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">// 多处理器下的负载均衡</span></span><br><span class="line">	rq-&gt;idle_at_tick = idle_cpu(cpu);</span><br><span class="line">	trigger_load_balance(rq, cpu);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_rq_clock(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 prev_raw = rq-&gt;prev_clock_raw;</span><br><span class="line">	u64 now = sched_clock();</span><br><span class="line">	s64 delta = now - prev_raw;</span><br><span class="line">	u64 clock = rq-&gt;clock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protect against sched_clock() occasionally going backwards:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 防止时钟向后跳，造成增长值为负数</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(delta &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		clock++;</span><br><span class="line">		rq-&gt;clock_warps++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Catch too large forward jumps too:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 防止时钟跳的太多...</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(clock + delta &gt; rq-&gt;tick_timestamp + TICK_NSEC)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (clock &lt; rq-&gt;tick_timestamp + TICK_NSEC)</span><br><span class="line">				clock = rq-&gt;tick_timestamp + TICK_NSEC;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				clock++;</span><br><span class="line">			rq-&gt;clock_overflows++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(delta &gt; rq-&gt;clock_max_delta))</span><br><span class="line">				rq-&gt;clock_max_delta = delta;</span><br><span class="line">			clock += delta;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 可以看到上面做了很多的预防工作，实际上就是把队列的时钟增加</span></span><br><span class="line">	rq-&gt;prev_clock_raw = now;</span><br><span class="line">	rq-&gt;clock = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到周期性调度器在时钟中断的触发下周期性执行，每次执行都会更新当前cpu就绪队列的时钟，当前cpu负载，然后调用当前进程所属的调度器类的周期性调度方法，(另外多说一句，多处理器下每个处理器都有自己的周期性时钟)。对于调度器类的周期性方法这里暂时不讨论，在后面的章节会着重介绍。</p>
<h4 id="主调度器"><a href="#主调度器" class="headerlink" title="主调度器"></a>主调度器</h4><p>在内核的许多地方，如果要讲CPU分配给与当前进程不同的另外一个进程，都会直接调用主调度器函数<code>schedule()</code>，在从系统调用返回之后(实际上不止于此，从中断、异常返回时也会检查)，内核也会检查当前进程是否设置了<code>TIF_NEED_RESCHED</code>，如果设置了该标志，那么就会调用scheduler()函数寻找一个新的可执行进程替换当前进程。下面就来着重看一下schedule()函数的内核实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="keyword">void</span> __<span class="function">sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">long</span> *switch_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">need_resched:</span><br><span class="line">    <span class="comment">// 禁止内核抢占</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">    <span class="comment">// 获取当前处理器及对应就绪队列</span></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">    <span class="comment">// 中心无关忽略之</span></span><br><span class="line">	rcu_qsctr_inc(cpu);</span><br><span class="line">    <span class="comment">// 获取当前运行进程</span></span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">    <span class="comment">// 释放当前进程的大内核锁(如果有的话)</span></span><br><span class="line">	release_kernel_lock(prev);</span><br><span class="line">need_resched_nonpreemptible:</span><br><span class="line">    <span class="comment">// debug信息，忽略之</span></span><br><span class="line">	schedule_debug(prev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do the rq-clock update outside the rq lock:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 关闭本地中断</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">    <span class="comment">// 更新一下子当前就绪队列的时钟</span></span><br><span class="line">	__update_rq_clock(rq);</span><br><span class="line">    <span class="comment">// 获取当前队列的自旋锁</span></span><br><span class="line">	spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">    <span class="comment">// 清除当前进程的`TIF_NEED_RESCHED`标志</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前进程不处于运行状态并且不属于内核态抢占</span></span><br><span class="line">    <span class="comment">// 这里主要作用是防止将非RUNNING状态的进程从就绪队列中移除</span></span><br><span class="line">    <span class="comment">// 可以参考下http://linuxperf.com/?p=38 讲的非常棒</span></span><br><span class="line">    <span class="comment">// 如果设置了PREEMPT\_ACTIVE，说明该进程是由于内核抢占而被调离CPU的，</span></span><br><span class="line">    <span class="comment">// 这时不把它从Run Queue里移除；如果PREEMPT\_ACTIVE没被设置</span></span><br><span class="line">    <span class="comment">//（进程不是由于内核抢占而被调离），还要看一下它有没有未处理的信号，</span></span><br><span class="line">    <span class="comment">// 如果有的话，也不把它从Run Queue移除。  总之，只要不是主动呼叫schedule()，</span></span><br><span class="line">    <span class="comment">// 而是因被抢占而调离CPU的，进程就还在运行队列中，还有机会运行。</span></span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前进程处于可中断睡眠状态并且有挂起的信号，那么修改</span></span><br><span class="line">        <span class="comment">// 当前进程状态为RUNNING</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely((prev-&gt;state &amp; TASK_INTERRUPTIBLE) &amp;&amp;</span><br><span class="line">				unlikely(signal_pending(prev)))) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则说明当前进程要么处于其他不可运行状态</span></span><br><span class="line">            <span class="comment">// 要么没有挂起的信号，则将当前进程从就绪队列中移除</span></span><br><span class="line">			deactivate_task(rq, prev, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 负载均衡</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!rq-&gt;nr_running))</span><br><span class="line">		idle_balance(cpu, rq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用指定调度器类的函数</span></span><br><span class="line">	prev-&gt;sched_class-&gt;put_prev_task(rq, prev);</span><br><span class="line">    <span class="comment">// 一会儿介绍</span></span><br><span class="line">	next = pick_next_task(rq, prev);</span><br><span class="line"></span><br><span class="line">	sched_info_switch(prev, next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果选出来的下一个进程和当前进程不是同一个进程</span></span><br><span class="line">    <span class="comment">// 那么说明即将执行进程切换</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">        <span class="comment">// 更新统计信息</span></span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">        <span class="comment">// 重新设置就绪队列的运行进程</span></span><br><span class="line">		rq-&gt;curr = next;</span><br><span class="line">        <span class="comment">// 增加进程切换次数</span></span><br><span class="line">		++*switch_count;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行进程切换</span></span><br><span class="line">		context_switch(rq, prev, next); <span class="comment">/* unlocks the rq */</span></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新进程在执行schedule前持有大内核锁，那么这里重新尝试获取</span></span><br><span class="line">    <span class="comment">// 如果获取失败则重新调度。因为进程上一次被切换出去时，如果占有了</span></span><br><span class="line">    <span class="comment">// 大内核锁，那么schedule会暂时释放掉，因此这里会重新获取</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(reacquire_kernel_lock(current) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		cpu = smp_processor_id();</span><br><span class="line">		rq = cpu_rq(cpu);</span><br><span class="line">		<span class="keyword">goto</span> need_resched_nonpreemptible;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 开中断，但是不再执行尝试调度逻辑</span></span><br><span class="line">	preempt_enable_no_resched();</span><br><span class="line">    <span class="comment">// 如果新的进程又被设置了TIF_NEED_RESCHED标志，那么</span></span><br><span class="line">    <span class="comment">// 重新选择进程</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED)))</span><br><span class="line">		<span class="keyword">goto</span> need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当前进程如果是因为被抢占而导致失去CPU，那么不会把当前进程从就绪队列中移除，而如果是主动让的CPU，说明此时进程正在某等待队列上等待指定条件，那么会将当前进程从就绪队列中删除</p>
<p>schedule函数主要工作为：调用当前进程所属调度器类方法<code>put_prev_task</code>，该方法不同的调度器类实现不同，主要工作就是在当前进程失去cpu之前做一些工作(例如对于CFS调度器，如果当前进程的on_rq==1，则会将当前进程重新放回队列中)；然后调用<code>pick_next_task</code>函数获取下一个合适的进程，该函数主要去调用调度器队列的相应函数，如果成功找到了合适的进程，并且和当前进程不相同，那么后面会执行<code>context_switch</code>进行实际的切换。</p>
<p>需要注意的是，如果进程的<code>on_rq==1</code>，那么表明当前进程属于某个队列管理，即使它目前不在该队列上。比如CFS调度器来说，在选择新的进程执行时，会把当前进程从CFS管理的红黑树上移除，也就是说正在运行的CFS调度器管理的进程实际上并不在队列中，但是该进程的<code>on_rq=1</code>。这里需要区分，<code>on_rq</code>表示一个进程是否属正在被某个调度器队列管理，这个管理由两层含义：</p>
<ol>
<li>该进程正在调度器队列中</li>
<li>该进程不在调度器队列中，但是正在使用CPU</li>
</ol>
<p>因此对于CFS调度器来说，如果进程在调度器队列中，那么<code>on_rq=1</code>恒成立，反过来却不然；因为被调度器选中占用CPU的进程虽然不在调度器队列中，但是它仍然属于调度器队列管理，因此<code>on_rq=1</code>。</p>
<p>下面将依次介绍<code>pick_next_task</code> 和<code>context_switch</code>函数，首先介绍<code>pick_next_task</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">pick_next_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Optimization: we know that if all tasks are in</span></span><br><span class="line"><span class="comment">	 * the fair class we can call that function directly:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 一个小优化，如果当前就绪队列活动进程数量等于cfs</span></span><br><span class="line">    <span class="comment">// 调度器队列的活动进程数量，那么可以直接调用cfs调度器</span></span><br><span class="line">    <span class="comment">// 相关函数寻找下一个进程</span></span><br><span class="line">	<span class="keyword">if</span> (likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)) &#123;</span><br><span class="line">        <span class="comment">// 调用cfs调度器队列的pick_next_task方法寻找合适进程</span></span><br><span class="line">		p = fair_sched_class.pick_next_task(rq);</span><br><span class="line">        <span class="comment">// 如果找到则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (likely(p))</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">class</span> = <span class="title">sched_class_highest</span>;</span></span><br><span class="line">    <span class="comment">// 遍历rt，cfs调度器队列，寻找合适进程</span></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Will never be NULL as the idle class always</span></span><br><span class="line"><span class="comment">		 * returns a non-NULL p:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> = <span class="title">class</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在选择合适进程时，实际上是先遍历<code>sched_class_highest</code>链表，中的调度器类，然后调用指定调度器类的<code>pick_next_task</code>函数选择合适的进程，而<code>sched_class_highest</code>链表中调度器类的数量就决定了调度器类的优先级，根据前面说的<code>rt_sched&gt;cfs&gt;idle</code></p>
<p>选择合适进程的逻辑其实非常简单，就是找到合适的调度器类，然后调用调度器类的方法从调度器队列中寻找合适的进程，下面我们来看看schedule函数的另一个重点，进程切换函数<code>context_switch</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">context_switch(struct rq *rq, struct task_struct *prev,</span><br><span class="line">	       struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要注意的是，schedule()函数的开头就禁止了抢占</span></span><br><span class="line">    <span class="comment">// 禁止了本地中断，并且获取了就绪队列的自旋锁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放schedule()函数中获取的就绪队列自旋锁</span></span><br><span class="line">    <span class="comment">// 并且根据编译内核时的配置决定是否允许本地中断</span></span><br><span class="line">	prepare_task_switch(rq, prev, next);</span><br><span class="line">	mm = next-&gt;mm;</span><br><span class="line">	oldmm = prev-&gt;active_mm;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For paravirt, this is coupled with an exit in switch_to to</span></span><br><span class="line"><span class="comment">	 * combine the page table reload and the switch backend into</span></span><br><span class="line"><span class="comment">	 * one hypercall.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 进入懒惰cpu模式</span></span><br><span class="line">	arch_enter_lazy_cpu_mode();</span><br><span class="line">    <span class="comment">// 如果即将占用cpu的进程mm为空</span></span><br><span class="line">    <span class="comment">// 说明该进程是内核线程，那么需要借用切换出去进程的</span></span><br><span class="line">    <span class="comment">// mm结构，并且增加引用计数，进入懒惰tlb模式</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!mm)) &#123;</span><br><span class="line">		next-&gt;active_mm = oldmm;</span><br><span class="line">		atomic_inc(&amp;oldmm-&gt;mm_count);</span><br><span class="line">		enter_lazy_tlb(oldmm, next);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则说明新运行进程是正常进程，这里</span></span><br><span class="line">        <span class="comment">// 包含一些硬件相关操作，其中就包括</span></span><br><span class="line">        <span class="comment">// 重新加载cr3寄存器，切换页表</span></span><br><span class="line">		switch_mm(oldmm, mm, next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果被切换出去的进程是内核线程</span></span><br><span class="line">    <span class="comment">// 那么清理内核线程临时占用的mm</span></span><br><span class="line">    <span class="comment">// 并且设置就绪队列的prev_mm</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!prev-&gt;mm)) &#123;</span><br><span class="line">		prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;prev_mm = oldmm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since the runqueue lock will be released by the next</span></span><br><span class="line"><span class="comment">	 * task (which is an invalid locking op but in the case</span></span><br><span class="line"><span class="comment">	 * of the scheduler it's an obvious special-case), so we</span></span><br><span class="line"><span class="comment">	 * do an early lockdep release here:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ARCH_WANT_UNLOCKED_CTXSW</span></span><br><span class="line">	spin_release(&amp;rq-&gt;lock.dep_map, <span class="number">1</span>, _THIS_IP_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Here we just switch the register state and the stack. */</span></span><br><span class="line">    <span class="comment">// 执行硬件切换</span></span><br><span class="line">	switch_to(prev, next, prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 屏障</span></span><br><span class="line">	barrier();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * this_rq must be evaluated again because prev may have moved</span></span><br><span class="line"><span class="comment">	 * CPUs since it called schedule(), thus the 'rq' on its stack</span></span><br><span class="line"><span class="comment">	 * frame will be invalid.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 这里已经属于切换后，因此执行这里逻辑的永远都是</span></span><br><span class="line">    <span class="comment">// 新切换进来的进程，对应prepare_task_switch，做一些收尾工作</span></span><br><span class="line">	finish_task_switch(this_rq(), prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，该函数有两个重要部分，分别是<code>switch_to</code>和<code>finish_task_switch</code>，首先介绍实际执行切换的函数<code>switch_to</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev,next,last) do &#123;					\</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> esi,edi;						\</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"pushfl\n\t"</span>		<span class="comment">/* Save flags */</span>	\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"pushl %%ebp\n\t"</span>					\ <span class="comment">// 将eflags和ebp压到prev内核栈</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"movl %%esp,%0\n\t"</span>	<span class="comment">/* save ESP */</span>		\ <span class="comment">// 将esp保存到prev-&gt;thread.esp</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"movl %5,%%esp\n\t"</span>	<span class="comment">/* restore ESP */</span>	\ <span class="comment">// 将next-&gt;thread.esp加载到esp</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                                        \ <span class="comment">//这两步实际上就是进行内核栈切换</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"movl $1f,%1\n\t"</span>		<span class="comment">/* save EIP */</span>		\ <span class="comment">// 将标号1初地址保存到prev-&gt;thread.eip中</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                                        \ <span class="comment">// 这样的话prev重新被调度执行时就会从1开始执行</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"pushl %6\n\t"</span>		<span class="comment">/* restore EIP */</span>	\    <span class="comment">// 加载next进程的eip，这两步实际上是切换ip</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"jmp __switch_to\n"</span>				\        <span class="comment">// 调用__switch_to函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"1:\t"</span>						\                <span class="comment">// 从__switch_to返回的实际上已经是next了</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"popl %%ebp\n\t"</span>					\        <span class="comment">// 此时next有两种情况，如果是之前被调度过，那么此时</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">"popfl"</span>						\            <span class="comment">// next的ip一定指向标号1，因此从1开始执行最后返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     :<span class="string">"=m"</span> (prev-&gt;thread.esp),<span class="string">"=m"</span> (prev-&gt;thread.eip),	\ <span class="comment">// 如果next是新进程，那么根据fork代码可以</span></span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="string">"=a"</span> (last),<span class="string">"=S"</span> (esi),<span class="string">"=D"</span> (edi)			\   <span class="comment">// 得知，此时next的ip指向ret_from_fork，因此next</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     :<span class="string">"m"</span> (next-&gt;thread.esp),<span class="string">"m"</span> (next-&gt;thread.eip),	\ <span class="comment">// 此时会跳转执行ret_from_fork函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="string">"2"</span> (prev), <span class="string">"d"</span> (next))</span></span>;				\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 参数为switch_to中的ax中的prev和dx中的next    </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">fastcall</span> * __<span class="title">switch_to</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> = &amp;<span class="title">prev_p</span>-&gt;<span class="title">thread</span>,</span></span><br><span class="line"><span class="class">				 *<span class="title">next</span> = &amp;<span class="title">next_p</span>-&gt;<span class="title">thread</span>;</span></span><br><span class="line">    <span class="comment">// 获取当前cpu</span></span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">// 获取当前cpu的tss段</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> = &amp;<span class="title">per_cpu</span>(<span class="title">init_tss</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></span><br><span class="line">   <span class="comment">// 进入懒惰fpu模式，前面介绍过(具体是本文的前面还是上一篇文章忘了)</span></span><br><span class="line">    <span class="comment">// 主要的做法就是，假设A为prev进程，B为next进程</span></span><br><span class="line">    <span class="comment">// 那么如果A使用了fpu寄存器，这里将fpu等寄存器内容保存A的thread_info中</span></span><br><span class="line">    <span class="comment">// 但是并不会加载B的fpu信息，二是设置cr0寄存器的TS标志</span></span><br><span class="line">    <span class="comment">// 只有等B使用fpu相关寄存器时时，如果TS置位那么会产生一个异常</span></span><br><span class="line">    <span class="comment">// 这时候内核捕捉到这个异常，才会记载B的fpu</span></span><br><span class="line">	__unlazy_fpu(prev_p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we're going to use this soon, after a few expensive things */</span></span><br><span class="line">    <span class="comment">// fpu相关的东西，不想深究</span></span><br><span class="line">	<span class="keyword">if</span> (next_p-&gt;fpu_counter &gt; <span class="number">5</span>)</span><br><span class="line">		prefetch(&amp;next-&gt;i387.fxsave);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reload esp0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 加载next的esp0寄存器，在进程创建时候有说过</span></span><br><span class="line">    <span class="comment">// 这里的esp0可以简单理解为进程内核栈基地址</span></span><br><span class="line">    <span class="comment">// (实际上有细微偏差，指向内核基地址靠下一点点，不过这里理解就行)</span></span><br><span class="line">    <span class="comment">// 这里实际上就是把next进程的内核堆栈加载到tss中</span></span><br><span class="line">    <span class="comment">// 这样当执行系统调用/中断异常时，cpu就能通过tss获取到</span></span><br><span class="line">    <span class="comment">// 进程内核栈的位置</span></span><br><span class="line">	load_esp0(tss, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Save away %gs. No need to save %fs, as it was saved on the</span></span><br><span class="line"><span class="comment">	 * stack on entry.  No need to save %es and %ds, as those are</span></span><br><span class="line"><span class="comment">	 * always kernel segments while inside the kernel.  Doing this</span></span><br><span class="line"><span class="comment">	 * before setting the new TLS descriptors avoids the situation</span></span><br><span class="line"><span class="comment">	 * where we temporarily have non-reloadable segments in %fs</span></span><br><span class="line"><span class="comment">	 * and %gs.  This could be an issue if the NMI handler ever</span></span><br><span class="line"><span class="comment">	 * used %fs or %gs (it does not today), or if the kernel is</span></span><br><span class="line"><span class="comment">	 * running inside of a hypervisor layer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 上面英文翻译:保存掉%gs。不需要保存%fs，因为它在进入时被保存在堆栈中。 </span></span><br><span class="line">    <span class="comment">// 不需要保存%es和%ds，因为这些都是在内核内的内核段。 在设置新的TLS描述符之前这样做，</span></span><br><span class="line">    <span class="comment">// 可以避免我们在%fs和%gs中暂时有不可重载的段的情况。 </span></span><br><span class="line">    <span class="comment">// 如果NMI处理程序曾经使用%fs或%gs（现在没有），或者如果内核在管理程序层内运行，这可能是一个问题。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Linux x86如何使用gs和fs: https://zhuanlan.zhihu.com/p/435518616</span></span><br><span class="line">    <span class="comment">// 需要注意这篇文章里说的是x86-64，实际上x86-32下内核使用fs记录per_cpu变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存prev的gs寄存器</span></span><br><span class="line">	savesegment(gs, prev-&gt;gs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Load the per-thread Thread-Local Storage descriptor.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 加载新进程的tls</span></span><br><span class="line">	load_TLS(next, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore IOPL if needed.  In normal use, the flags restore</span></span><br><span class="line"><span class="comment">	 * in the switch assembly will handle this.  But if the kernel</span></span><br><span class="line"><span class="comment">	 * is running virtualized at a non-zero CPL, the popf will</span></span><br><span class="line"><span class="comment">	 * not restore flags, so it must be done in a separate step.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// iopl相关的，暂时懒得看</span></span><br><span class="line">	<span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</span><br><span class="line">		set_iopl_mask(next-&gt;iopl);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now maybe handle debug registers and/or IO bitmaps</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// debug啥的东西，懒得看</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV ||</span><br><span class="line">		     task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT))</span><br><span class="line">		__switch_to_xtra(prev_p, next_p, tss);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Leave lazy mode, flushing any hypercalls made here.</span></span><br><span class="line"><span class="comment">	 * This must be done before restoring TLS segments so</span></span><br><span class="line"><span class="comment">	 * the GDT and LDT are properly updated, and must be</span></span><br><span class="line"><span class="comment">	 * done before math_state_restore, so the TS bit is up</span></span><br><span class="line"><span class="comment">	 * to date.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 和之前的进入懒惰cpu模式对应。hmm，只知道</span></span><br><span class="line">    <span class="comment">// 懒惰tlb和懒惰fpu，至于懒惰cpu，不太清楚..</span></span><br><span class="line">	arch_leave_lazy_cpu_mode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the task has used fpu the last 5 timeslices, just do a full</span></span><br><span class="line"><span class="comment">	 * restore of the math state immediately to avoid the trap; the</span></span><br><span class="line"><span class="comment">	 * chances of needing FPU soon are obviously high now</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// fpu，懒得深究</span></span><br><span class="line">	<span class="keyword">if</span> (next_p-&gt;fpu_counter &gt; <span class="number">5</span>)</span><br><span class="line">		math_state_restore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore %gs if needed (which is common)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果需要的话，加载新进程的gs寄存器</span></span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</span><br><span class="line">		loadsegment(gs, next-&gt;gs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将next写入每cpu变量中，后面通过current宏获取当前cpu</span></span><br><span class="line">    <span class="comment">// 的当前进程，就是这里的功劳</span></span><br><span class="line">    <span class="comment">// 传统的current红灯是根据内核sp获取到thread_info，然后根据</span></span><br><span class="line">    <span class="comment">// thread_info获取到task_struct</span></span><br><span class="line">    <span class="comment">// 不过x86平台上做了优化，通过没cpu变量实现</span></span><br><span class="line">    <span class="comment">// 每次进程切换时都会将当前运行的进程写入到当前cpu的每cpu</span></span><br><span class="line">    <span class="comment">// 变量中，通过current宏获取时也是从每cpu变量中获取</span></span><br><span class="line">	x86_write_percpu(current_task, next_p);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> prev_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于switch_to涉及到所谓的”三个”进程的问题，网上很多说明，其实也不难理解，这里就不说了(懒得再打字了..)</p>
<p>好了，到这里，让我们介绍<code>context_switch</code>的最后一个函数<code>finish_task_switch</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish_task_switch</span><span class="params">(struct rq *rq, struct task_struct *prev)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">rq</span>-&gt;<span class="title">prev_mm</span>;</span></span><br><span class="line">	<span class="keyword">long</span> prev_state;</span><br><span class="line">   </span><br><span class="line">	rq-&gt;prev_mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A task struct has one reference for the use as "current".</span></span><br><span class="line"><span class="comment">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls</span></span><br><span class="line"><span class="comment">	 * schedule one last time. The schedule call will never return, and</span></span><br><span class="line"><span class="comment">	 * the scheduled task must drop that reference.</span></span><br><span class="line"><span class="comment">	 * The test for TASK_DEAD must occur while the runqueue locks are</span></span><br><span class="line"><span class="comment">	 * still held, otherwise prev could be scheduled on another cpu, die</span></span><br><span class="line"><span class="comment">	 * there before we look at prev-&gt;state, and then the reference would</span></span><br><span class="line"><span class="comment">	 * be dropped twice.</span></span><br><span class="line"><span class="comment">	 *		Manfred Spraul &lt;manfred@colorfullife.com&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果被切换出去的进程状态为`DEAD`，则由新进程负责</span></span><br><span class="line">    <span class="comment">// 释放一次旧进程的结构</span></span><br><span class="line">	prev_state = prev-&gt;state;</span><br><span class="line">	finish_arch_switch(prev);</span><br><span class="line">    <span class="comment">// 如果prepare_task_switch中没有开中断</span></span><br><span class="line">    <span class="comment">// 那么这里打开中断，否则这里什么都不做</span></span><br><span class="line">	finish_lock_switch(rq, prev);</span><br><span class="line">	fire_sched_in_preempt_notifiers(current);</span><br><span class="line">	<span class="keyword">if</span> (mm)</span><br><span class="line">		mmdrop(mm);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(prev_state == TASK_DEAD)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Remove function-return probe instances associated with this</span></span><br><span class="line"><span class="comment">		 * task and put them back on the free list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kprobe_flush_task(prev);</span><br><span class="line">		put_task_struct(prev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CFS调度器"><a href="#CFS调度器" class="headerlink" title="CFS调度器"></a>CFS调度器</h2><p>通过前面的介绍可以看到，主调度器和周期性调度器主要调用进程所属的调度器类的相关方法。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先，我们需要介绍一下CFS就绪队列，我们回顾一下CPU就绪队列的内容，可以发现CPU就绪队列中嵌入了调度器队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">	 * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line">	<span class="comment">/* capture load from *all* tasks on this cpu: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span> <span class="comment">// cfs调度器队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span>   <span class="comment">// rt调度器队列</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>, *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	u64 clock, prev_clock_raw;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="CFS虚拟时钟"><a href="#CFS虚拟时钟" class="headerlink" title="CFS虚拟时钟"></a>CFS虚拟时钟</h3><p>下面主要看一下CFS如何实现虚拟时钟，前面说到过，CFS调度算法依赖于虚拟时钟，用来度量等待进程在完全公平系统中所能得到的CPU时间。但是到目前为止，我们并没有在介绍过的任何数据结构中发现虚拟时钟。这是因为虚拟时钟可以根据进程权重和物理时间直接推算出来。所有与虚拟时钟相关的计算都在<code>update_curr</code>中执行，该函数在系统中各个不同的地方调用，也包括周期性调度器之内，下面主要介绍一下该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_curr</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取就绪队列正在运行的进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">    <span class="comment">// 获取就绪队列当前时钟</span></span><br><span class="line">	u64 now = rq_of(cfs_rq)-&gt;clock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> delta_exec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果就绪队列中没有进程正在使用cpu，那么直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!curr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get the amount of time the current task was running</span></span><br><span class="line"><span class="comment">	 * since the last time we changed load (this cannot</span></span><br><span class="line"><span class="comment">	 * overflow on 32 bits):</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 计算两次更新的时间差</span></span><br><span class="line">	delta_exec = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(now - curr-&gt;exec_start);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要逻辑</span></span><br><span class="line">	__update_curr(cfs_rq, curr, delta_exec);</span><br><span class="line">    <span class="comment">// 更新exec_start，下次计算时使用</span></span><br><span class="line">	curr-&gt;exec_start = now;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前的调度实体是进程，那么做一些cpu统计信息</span></span><br><span class="line">	<span class="keyword">if</span> (entity_is_task(curr)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curtask</span> = <span class="title">task_of</span>(<span class="title">curr</span>);</span></span><br><span class="line"></span><br><span class="line">		cpuacct_charge(curtask, delta_exec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>update_curr</code>主要工作就是计算出两次统计时间的物理差值，该差值就是这段时间进程实际占用cpu的物理时间，然后调用<code>__update_curr</code>进行更新工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> delta_exec)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> delta_exec_weighted;</span><br><span class="line">	u64 vruntime;</span><br><span class="line">    <span class="comment">// 调度器统计信息，忽略</span></span><br><span class="line">	schedstat_set(curr-&gt;exec_max, max((u64)delta_exec, curr-&gt;exec_max));</span><br><span class="line">    <span class="comment">// 增加当前进程执行的物理时间总和</span></span><br><span class="line">	curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class="line">    <span class="comment">// 调度器统计信息，忽略</span></span><br><span class="line">	schedstat_add(cfs_rq, exec_clock, delta_exec);</span><br><span class="line">    <span class="comment">// 这里就是主要的步骤，根据进程运行的物理时间和进程权重信息</span></span><br><span class="line">    <span class="comment">// 计算进程运行的虚拟时间，一会儿单独介绍</span></span><br><span class="line">	delta_exec_weighted = delta_exec;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(curr-&gt;load.weight != NICE_0_LOAD)) &#123;</span><br><span class="line">		delta_exec_weighted = calc_delta_fair(delta_exec_weighted,</span><br><span class="line">							&amp;curr-&gt;load);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 更新进程的虚拟时间</span></span><br><span class="line">	curr-&gt;vruntime += delta_exec_weighted;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * maintain cfs_rq-&gt;min_vruntime to be a monotonic increasing</span></span><br><span class="line"><span class="comment">	 * value tracking the leftmost vruntime in the tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果当前cfs队列不为空</span></span><br><span class="line">	<span class="keyword">if</span> (first_fair(cfs_rq)) &#123;</span><br><span class="line">        <span class="comment">// 取当前进程的虚拟时间和cfs队列中虚拟时间最小的进程</span></span><br><span class="line">        <span class="comment">// 两者中小的那一个</span></span><br><span class="line">		vruntime = min_vruntime(curr-&gt;vruntime,</span><br><span class="line">				__pick_next_entity(cfs_rq)-&gt;vruntime);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		vruntime = curr-&gt;vruntime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新cfs队列的最小虚拟时间，注意这里使用max来保证</span></span><br><span class="line">    <span class="comment">// 最小虚拟时间一定是单调递增的</span></span><br><span class="line">	cfs_rq-&gt;min_vruntime =</span><br><span class="line">		max_vruntime(cfs_rq-&gt;min_vruntime, vruntime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到物理时间到进程虚拟时间的转换主要是以下代码段实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delta_exec_weighted = delta_exec;</span><br><span class="line"><span class="keyword">if</span> (unlikely(curr-&gt;load.weight != NICE_0_LOAD)) &#123;</span><br><span class="line">	delta_exec_weighted = calc_delta_fair(delta_exec_weighted,</span><br><span class="line">						&amp;curr-&gt;load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>calc_delta_fair()</code>该函数的主要作用就是根据当前进程的权重计算虚拟时间，由于涉及到出发，实现稍微复杂，但是实际上要做的事情非常简单：就是基于公式计算虚拟时间，对于该函数的实现就不赘述了，主要介绍一下公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delta_exec_weighted = delta_exec * NICE_0_LOAD / curr-&gt;load.weight</span><br><span class="line"></span><br><span class="line">NICE_0_LOAD = <span class="number">1024</span>， 就是nice值为<span class="number">0</span>进程的权重，本文的前面有介绍</span><br></pre></td></tr></table></figure>

<p>可以看到对于nice值为0的进程，它的物理时间和虚拟时间流速是一样的，而对于其他进程：<code>nice值越低，则虚拟时间增长越慢</code>，记住这点，这对于cfs调度器来说非常重要。为什么重要呢？cfs调度器队列是一个红黑树组织，cfs调度器会根据进程的虚拟时间进行排序，也就是说，虚拟时间越小的进程，越靠近红黑树的左边。并且cfs调度器在选择下一个合适进程时，总是选择红黑树最左边的进程，也就是虚拟时间最小的进程，因为cfs调度器只看虚拟时间，虚拟时间小的进程在cfs看来占用cpu少，受到了不公平的对待，因此cfs总是会选择虚拟时间小的进程来执行。</p>
<p>但实际上却并非如此，我们可以看到，两个权重不同的进程，它们运行相同的时间，权重大(nice值小)的进程虚拟时间增长的更慢，因此在红黑树中向右移动的速度就慢(随着进程的运行，虚拟时间增大，在红黑树中的位置会逐渐向右移)，因此被cfs调度器选中执行的次数就多一下，这样一来，进程实际占用cpu的时间(物理时间)就多一些。通过这种方式，权重大的进程占用的cpu物理时间更多，实现了我们希望的：重要的进程能够更多的使用cpu。</p>
<h3 id="延迟跟踪"><a href="#延迟跟踪" class="headerlink" title="延迟跟踪"></a>延迟跟踪</h3><p>Linux内核有个良好的概念被称为<code>调度延迟</code>，可以理解为每个可运行进程都应该至少执行一次的某个时间间隔值。该部分和几个内核变量给出</p>
<ol>
<li><code>sysctl_sched_latency</code>，表明每个可运行进程至少运行一次的时间间隔，默认为20毫秒</li>
<li><code>sysctl_sched_min_granularity</code>：进程最短占用cpu时间，默认为4毫秒，主要是用来辅助计算<code>sched_nr_latency</code></li>
<li><code>sched_nr_latency</code>：控制一个延迟周期中处理的最大活动进程数量，变相的由上面两个值控制。并且和<code>sysctl_sched_latency</code>以及活动进程数量计算延迟周期(调度周期)。</li>
</ol>
<p>当<code>sysctl_sched_latency</code>和<code>sysctl_sched_min_granularity</code>任意一个改变时，都会重新计算<code>sched_nr_latency</code>。但是如果就绪队列中有过多的可运行进程，那么也会调用<code>sched_period</code>对<code>sysctl_sched_latency</code>进行调整：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u64 __sched_period(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running)</span><br><span class="line">&#123;</span><br><span class="line">	u64 period = sysctl_sched_latency;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_latency = sched_nr_latency;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (unlikely(nr_running &gt; nr_latency)) &#123;</span><br><span class="line">		period *= nr_running;</span><br><span class="line">		do_div(period, nr_latency);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> period;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>sysctl_sched_latency</code> = <code>sysctl_sched_latency</code>*<code>nr_running</code> / <code>sched_nr_latency</code>.</p>
<p>上面介绍了延迟周期的计算和默认值，那么对于一个延迟周期内的活动进程，调度器如何将这些时间分配给每个进程呢？每个进程又能够得到多少呢？内核通过<code>sched_slice</code>根据就绪队列的权重和进程的权重，将延迟周期分配给队列中每个进程一定的份额：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">sched_slice</span><span class="params">(struct cfs_rq *cfs_rq, struct sched_entity *se)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据就绪队列的活动进程数计算延迟周期</span></span><br><span class="line">	u64 slice = __sched_period(cfs_rq-&gt;nr_running);</span><br><span class="line">    <span class="comment">// 根据当前进程的权重和就绪队列的权重，计算当前进程应该分配到的虚拟时间</span></span><br><span class="line">	slice *= se-&gt;load.weight;</span><br><span class="line">	do_div(slice, cfs_rq-&gt;load.weight);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数等价于该公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = cfs_queue_time * curr_weight / cfs_queue_weight</span><br></pre></td></tr></table></figure>

<p>前面说过，就绪队列的权重是就绪队列所有活动进程权重的累加。内核获取进程调度周期内应该分配的物理时间主要目的是防止进程运行时间过长，周期性调度器每次执行时都会计算当前进程占用cpu的实际物理时间delta，如果该delta超过了进程被分配的物理时间，那么就执行抢占。</p>
<p>上面介绍了如何获取就绪队列中的进程应该分配到的物理时间，内核有时也需要知道该物理时间等价的虚拟时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u64 __sched_vslice(<span class="keyword">unsigned</span> <span class="keyword">long</span> rq_weight, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算就绪队列的延迟周期(调度周期)</span></span><br><span class="line">	u64 vslice = __sched_period(nr_running);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算该进程应该被分配到的虚拟时间</span></span><br><span class="line">	vslice *= NICE_0_LOAD;</span><br><span class="line">	do_div(vslice, rq_weight);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vslice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到计算公式如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vtime = cfs_queue_time * NICE_0_LOAD / cfs_queue_weight</span><br></pre></td></tr></table></figure>

<p>前面说到过，物理时间到虚拟时间的转换公式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vtime = time * NICE_0_LOAD / weight</span><br></pre></td></tr></table></figure>

<p>然后对比上面两个获取time和vtime的公式可以看到，这两个公式结合化简后就上物理时间到虚拟时间的公式</p>
<h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><p>前面说过，每个调度器类都包含入队/出队函数，这里主要介绍cfs调度器的队列操作函数：<code>enqueue_task_fair</code>和<code>dequeue_task_fair</code>。</p>
<h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enqueue_task_fair</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> wakeup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>;</span></span><br><span class="line">    <span class="comment">// 可能是组调度，但是这里可以忽略，简单的认为</span></span><br><span class="line">    <span class="comment">// se只有一个，只循环一次，调度进程</span></span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">        <span class="comment">// 如果on_rq为1，那么说明已经被就绪队列管理</span></span><br><span class="line">        <span class="comment">// 前面说过，此时可能在队列中，也可能不在</span></span><br><span class="line">        <span class="comment">// 但无论如何是属于队列管理的，因此这里不做任何操作</span></span><br><span class="line">		<span class="keyword">if</span> (se-&gt;on_rq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取调度实体所属的cfs就绪队列</span></span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">        <span class="comment">// 调用该函数， wakeup表示进程是否最近才被唤醒</span></span><br><span class="line">        <span class="comment">// 并转为运行状态，此时wake_up = 1</span></span><br><span class="line">        <span class="comment">// 如果此前就是可运行进程，那么wakeup = 0</span></span><br><span class="line">		enqueue_entity(cfs_rq, se, wakeup);</span><br><span class="line">		wakeup = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看一下<code>enqueue_entity</code>逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, <span class="keyword">int</span> wakeup)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update run-time statistics of the 'current'.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 更新调度器队列最小运行虚拟时间和一些统计信息</span></span><br><span class="line">    <span class="comment">// 以及当前进行虚拟运行时间，前面说过</span></span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果进程是最近才被唤醒而加入到就绪队列中</span></span><br><span class="line">    <span class="comment">// 那么需要一些额外操作，一会儿说</span></span><br><span class="line">	<span class="keyword">if</span> (wakeup) &#123;</span><br><span class="line">		place_entity(cfs_rq, se, <span class="number">0</span>);</span><br><span class="line">		enqueue_sleeper(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 统计信息，忽略</span></span><br><span class="line">	update_stats_enqueue(cfs_rq, se);</span><br><span class="line">	check_spread(cfs_rq, se);</span><br><span class="line">    <span class="comment">// 如果进程正在运行，那么不加入到就绪队列中</span></span><br><span class="line">    <span class="comment">// 前面说过，正在运行的进程on_rq=1，但是</span></span><br><span class="line">    <span class="comment">// 实际上并不在队列上</span></span><br><span class="line">	<span class="keyword">if</span> (se != cfs_rq-&gt;curr)</span><br><span class="line">		__enqueue_entity(cfs_rq, se);</span><br><span class="line">    <span class="comment">// 修改进程on_rq，增加就绪队列活动进程数量以及更新权重</span></span><br><span class="line">	account_entity_enqueue(cfs_rq, se);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">account_entity_enqueue(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	update_load_add(&amp;cfs_rq-&gt;load, se-&gt;load.weight);</span><br><span class="line">	cfs_rq-&gt;nr_running++;</span><br><span class="line">	se-&gt;on_rq = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果进程刚被唤醒然后加入到就绪队列，那么此时进程可能睡眠了很久，即它的虚拟时间已经很久没有增加了，可能落后就绪队列的最小虚拟时间很多，积累了很大的不公平值，如果我们不加处理，直接添加到就绪队列上，那么该进程在接下来可能会长久的占用cpu，导致其他进程饥饿(因为它的虚拟时间落后就绪队列最小虚拟时间很多，因此执行若干次后，可能仍然位于红黑树最左边)，因此需要额外的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, <span class="keyword">int</span> initial)</span><br><span class="line">&#123;</span><br><span class="line">	u64 vruntime;</span><br><span class="line"></span><br><span class="line">	vruntime = cfs_rq-&gt;min_vruntime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果设置了TREE_AVG调度器特性(实际上这只是特性的后缀名，忽略细节)</span></span><br><span class="line">    <span class="comment">// 并且就绪队列红黑树中存在最右边节点</span></span><br><span class="line">    <span class="comment">// 那么计算红黑树中最大虚拟时间和最小虚拟时间的平均值</span></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(TREE_AVG)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">last</span> = __<span class="title">pick_last_entity</span>(<span class="title">cfs_rq</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (last) &#123;</span><br><span class="line">			vruntime += last-&gt;vruntime;</span><br><span class="line">			vruntime &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="comment">// 否则如果设置了APPROX_AVG标志，那么计算</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sched_feat(APPROX_AVG) &amp;&amp; cfs_rq-&gt;nr_running)</span><br><span class="line">        <span class="comment">// sched_vslice(cfs_rq)/2计算当前就绪队列虚拟时间一半</span></span><br><span class="line">        <span class="comment">// 添加到vruntime上</span></span><br><span class="line">		vruntime += sched_vslice(cfs_rq)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要注意的是，上面对vruntime的增加，可能会导致刚唤醒的进程</span></span><br><span class="line">    <span class="comment">// 向红黑树右边偏移，因此这是一种惩罚措施</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The 'current' period is already promised to the current tasks,</span></span><br><span class="line"><span class="comment">	 * however the extra weight of the new task will slow them down a</span></span><br><span class="line"><span class="comment">	 * little, place the new task so that it fits in the slot that</span></span><br><span class="line"><span class="comment">	 * stays open at the end.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// initial表示当前进程是否是刚刚创建的</span></span><br><span class="line">    <span class="comment">// 进程创建需要时间，这段时间可以理解为是子进程</span></span><br><span class="line">    <span class="comment">// 向父进程借的时间，因此如果START_DEBIT如果被设置，</span></span><br><span class="line">    <span class="comment">// 那么需要适当增大子进程的虚拟时间</span></span><br><span class="line">	<span class="keyword">if</span> (initial &amp;&amp; sched_feat(START_DEBIT))</span><br><span class="line">		vruntime += sched_vslice_add(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果initial没有置位，说明当前进程是刚被唤醒而加入</span></span><br><span class="line">    <span class="comment">// 就绪队列的进程</span></span><br><span class="line">	<span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">		<span class="comment">/* sleeps upto a single latency don't count. */</span></span><br><span class="line">        <span class="comment">// 这里考虑到进程睡眠了一段时间，因此做一些奖励措施</span></span><br><span class="line">		<span class="keyword">if</span> (sched_feat(NEW_FAIR_SLEEPERS) &amp;&amp; entity_is_task(se))</span><br><span class="line">			vruntime -= sysctl_sched_latency;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ensure we never gain time by being placed backwards. */</span></span><br><span class="line">        <span class="comment">// 比较进程当前虚拟时间和上面计算的时间，去最大值</span></span><br><span class="line">        <span class="comment">// 避免这样一种情况：进程睡眠了1ms，但是通过上面的计算</span></span><br><span class="line">        <span class="comment">// 进程反而vruntime减少了3ms，因此进程实际上赚了</span></span><br><span class="line">        <span class="comment">// 通过睡眠获得了更多的运行时间，这是不允许的，因此</span></span><br><span class="line">        <span class="comment">// 保证了进程无论睡眠多久，奖励后的vruntime都不可能</span></span><br><span class="line">        <span class="comment">// 比原来的vruntime更小</span></span><br><span class="line">		vruntime = max_vruntime(se-&gt;vruntime, vruntime);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程的vruntime</span></span><br><span class="line">	se-&gt;vruntime = vruntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数实际上对进程的虚拟时间进行调整</p>
<ol>
<li>对于刚创建的进程，如果没有开启任何调度器特性，那么新进程的虚拟时间就是队列的最小时间，因此新进程会尽快的得到调度，如果设置了一些调度器特性，那么会根据这些特性对新进程的虚拟时间进行调整(一般是增大)，这样可以防止父进程通过创建新进程来不断获取CPU时间(这里计算出来的新进程的虚拟时间可能会大于父进程的虚拟时间，这样的话按照之前的说法，那新进程就不能够保证在父进程之前执行，因此实际上如果设置了标志要求子进程必须先执行，那么内核会通过交换父子进程的虚拟时间来保证子进程一定先于父进程，后面会说到)</li>
<li>对于刚唤醒的进程，它可能睡眠了很久，也可能只是睡眠了一会儿，那么我们需要对睡眠进程进行奖励，该奖励措施要符合这样的原则：对于睡眠很久的进程，不能够奖励太多，否则将会导致队列中的其他进程饥饿；对于短时间睡眠的进程，奖励的时间不能比它睡眠的时间还要长，防止进程通过短睡眠获取更多的CPU时间。</li>
</ol>
<p>对于CFS调度器的入队操作，就介绍完了，这里总结一下整体流程(只针对调度实体为进程)</p>
<ol>
<li>如果进程<code>on_rq=1</code>，说明进程已经被当前调度器队列管理，直接返回</li>
<li>调用<code>enqueue_entity</code>将进程入队</li>
<li>更新当前cfs队列最小虚拟时间，更新调度器统计量，更新该队列正在运行进程虚拟运行时间</li>
<li>如果进程是刚刚被唤醒，那么对进程的虚拟运行时间进行调整，对其进行一定程度的奖励</li>
<li>更新调度器统计信息</li>
<li>如果进程不是cfs队列上正在运行的进程，那么说明该进程确实不被队列管理，因此把进程添加到cfs队列中(红黑树中)</li>
<li>更新队列和进程相关信息：<code>nr_running++</code>、<code>cfs_rq.load.weight增大</code>、<code>进程on_rq置1</code></li>
</ol>
<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><p>介绍完出队操作，下面来介绍入队操作，cfs调度器的入队操作主要是<code>dequeue_task_fair</code>完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dequeue_task_fair</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> sleep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>;</span></span><br><span class="line">    <span class="comment">// 和前面一样，我们忽略这样一个for循环</span></span><br><span class="line">    <span class="comment">// 假设只循环一次</span></span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">        <span class="comment">// 核心逻辑</span></span><br><span class="line">		dequeue_entity(cfs_rq, se, sleep);</span><br><span class="line">		<span class="comment">/* Don't dequeue parent if it has other entities besides us */</span></span><br><span class="line">		<span class="keyword">if</span> (cfs_rq-&gt;load.weight)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		sleep = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, <span class="keyword">int</span> sleep)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update run-time statistics of the 'current'.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 更新cfs队列最小虚拟时间，更新统计信息</span></span><br><span class="line">    <span class="comment">// 更新该队列正在运行进程的虚拟运行时间</span></span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">  </span><br><span class="line">	update_stats_dequeue(cfs_rq, se);</span><br><span class="line">    <span class="comment">// 统计信息，忽略</span></span><br><span class="line">	<span class="keyword">if</span> (sleep) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">		<span class="keyword">if</span> (entity_is_task(se)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">task_of</span>(<span class="title">se</span>);</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tsk-&gt;state &amp; TASK_INTERRUPTIBLE)</span><br><span class="line">				se-&gt;sleep_start = rq_of(cfs_rq)-&gt;clock;</span><br><span class="line">			<span class="keyword">if</span> (tsk-&gt;state &amp; TASK_UNINTERRUPTIBLE)</span><br><span class="line">				se-&gt;block_start = rq_of(cfs_rq)-&gt;clock;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该进程不是队列正在运行进程，那么从队列(红黑树)中</span></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">	<span class="keyword">if</span> (se != cfs_rq-&gt;curr)</span><br><span class="line">		__dequeue_entity(cfs_rq, se);</span><br><span class="line">    <span class="comment">// 和入队操作相反：nr_running--, cfs_rq.load.weight减少</span></span><br><span class="line">    <span class="comment">// 进程的on_eq置0</span></span><br><span class="line">	account_entity_dequeue(cfs_rq, se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到出队操作完全和入队操作相反，逻辑也不复杂。</p>
<h3 id="放回和选择"><a href="#放回和选择" class="headerlink" title="放回和选择"></a>放回和选择</h3><h4 id="放回正在运行进程"><a href="#放回正在运行进程" class="headerlink" title="放回正在运行进程"></a>放回正在运行进程</h4><p>回忆一下schedule函数，在调用<code>pick_next_task</code>之前，会先调用<code>put_prev_task</code>用于将正在运行的进程放回到就绪队列中，我们来看一下cfs调度器是如何实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_prev_task_fair</span><span class="params">(struct rq *rq, struct task_struct *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = &amp;<span class="title">prev</span>-&gt;<span class="title">se</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">// 同样的，假设只循环一次</span></span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">        <span class="comment">// 核心逻辑</span></span><br><span class="line">		put_prev_entity(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_prev_entity</span><span class="params">(struct cfs_rq *cfs_rq, struct sched_entity *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If still on the runqueue then deactivate_task()</span></span><br><span class="line"><span class="comment">	 * was not called and update_curr() has to be done:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 对进程来说调度实体都on_rq=1</span></span><br><span class="line">    <span class="comment">// 因此和前面一样，更新调度器最小虚拟时间</span></span><br><span class="line">    <span class="comment">// 调度器统计信息，进程虚拟运行时间</span></span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;on_rq)</span><br><span class="line">		update_curr(cfs_rq);</span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">	check_spread(cfs_rq, prev);</span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;on_rq) &#123;</span><br><span class="line">        <span class="comment">// hmm又是统计信息，不看</span></span><br><span class="line">		update_stats_wait_start(cfs_rq, prev);</span><br><span class="line">		<span class="comment">/* Put 'current' back into the tree. */</span></span><br><span class="line">        <span class="comment">// 把进程放到红黑树上</span></span><br><span class="line">		__enqueue_entity(cfs_rq, prev);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一般调用该函数发生在进程切换时，把正在占用cpu的就列当前进程</span></span><br><span class="line">    <span class="comment">// 放回队列中，然后选择下一个进程</span></span><br><span class="line">    <span class="comment">// 因此对于进程来说，这里curr指向的就是将要放回队列的实体</span></span><br><span class="line">	cfs_rq-&gt;curr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像schedule函数看到的那样，在将正在运行的进程切换下来之前，需要先调用<code>put_prev_task</code>函数做一些处理工作，主要是继续调用<code>update_curr</code>进行万年不变的更新，然后将进程放回到队列(红黑树)中，然后将cfs队列的curr置空(在选择下一个进程时会重新设置)。</p>
<h4 id="选择下一个进程"><a href="#选择下一个进程" class="headerlink" title="选择下一个进程"></a>选择下一个进程</h4><p>还是schedule函数中的逻辑，将正在运行的进程放回到就绪队列中后，接着调用<code>pick_next_task_fair</code>(我们现在假设没有实时进程，因此一定会调用cfs调度器的pick_next_task，也就是该函数)选择下一个合适进程执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">pick_next_task_fair</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">cfs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">    <span class="comment">// 如果没有合适进程，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!cfs_rq-&gt;nr_running))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 核心逻辑</span></span><br><span class="line">		se = pick_next_entity(cfs_rq);</span><br><span class="line">        <span class="comment">// 组调度相关的，不用理会</span></span><br><span class="line">		cfs_rq = group_cfs_rq(se);</span><br><span class="line">	&#125; <span class="keyword">while</span> (cfs_rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task_of(se);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct sched_entity *<span class="title">pick_next_entity</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 如果就绪队列存在最左节点，即不为空</span></span><br><span class="line">	<span class="keyword">if</span> (first_fair(cfs_rq)) &#123;</span><br><span class="line">        <span class="comment">// 从队列中拿出最左节点，此时并没有</span></span><br><span class="line">        <span class="comment">// 把进程从树中删除</span></span><br><span class="line">		se = __pick_next_entity(cfs_rq);</span><br><span class="line">        <span class="comment">// 核心逻辑</span></span><br><span class="line">		set_next_entity(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">set_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 'current' is not kept within the tree. */</span></span><br><span class="line">	<span class="keyword">if</span> (se-&gt;on_rq) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Any task has to be enqueued before it get to execute on</span></span><br><span class="line"><span class="comment">		 * a CPU. So account for the time it spent waiting on the</span></span><br><span class="line"><span class="comment">		 * runqueue.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		update_stats_wait_end(cfs_rq, se);</span><br><span class="line">        <span class="comment">// 这里把将要运行的进程出队，因此可以看到</span></span><br><span class="line">        <span class="comment">// cfs队列curr指向的进程是正在占用cpu执行的进程</span></span><br><span class="line">        <span class="comment">// 是不在红黑树中的</span></span><br><span class="line">		__dequeue_entity(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">	update_stats_curr_start(cfs_rq, se);</span><br><span class="line">    <span class="comment">// 和前面的put_prev_task_fair对应，重新设置curr</span></span><br><span class="line">	cfs_rq-&gt;curr = se;</span><br><span class="line">    <span class="comment">// 统计信息，忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Track our maximum slice length, if the CPU's load is at</span></span><br><span class="line"><span class="comment">	 * least twice that of our own weight (i.e. dont track it</span></span><br><span class="line"><span class="comment">	 * when there are only lesser-weight tasks around):</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq_of(cfs_rq)-&gt;load.weight &gt;= <span class="number">2</span>*se-&gt;load.weight) &#123;</span><br><span class="line">		se-&gt;slice_max = max(se-&gt;slice_max,</span><br><span class="line">			se-&gt;sum_exec_runtime - se-&gt;prev_sum_exec_runtime);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 前面说过的，周期性调度器计算这两个字段的差值，获取</span></span><br><span class="line">    <span class="comment">// 进程此次移动执行了多久(物理时间)，然后进程最大能够</span></span><br><span class="line">    <span class="comment">// 使用的CPU份额做比较，如果超出则执行抢占</span></span><br><span class="line">    <span class="comment">// 进程执行过程中通过update_curr不断记录总的物理时间</span></span><br><span class="line">    <span class="comment">// 然后在被选中时将其赋值给prev_sum_exec_runtime</span></span><br><span class="line">	se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到这里为止<code>schedule</code>函数中没有介绍的调度器类相关的部分已经介绍完了，可以回顾一下schedule函数，看看基于cfs调度器的进程是如何执行schedule函数的。需要注意的是，在上面的介绍中，为了方便起见，直接把调度实体等价为进程，但是实际上这是不准确的，进程是调度实体，反过来则不一定！！</p>
<h3 id="周期性调度器-1"><a href="#周期性调度器-1" class="headerlink" title="周期性调度器"></a>周期性调度器</h3><p>前面实际上已经介绍了<code>scheduler_tick</code>函数，该函数由本地时钟周期性触发执行，主要工作是更新该cpu就绪队列的clock时钟，然后就绪队列curr指向进程所属的调度器类的<code>task_tick</code>函数，下面就看一下cfs调度器的周期性函数<code>task_tick_fair</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_tick_fair</span><span class="params">(struct rq *rq, struct task_struct *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = &amp;<span class="title">curr</span>-&gt;<span class="title">se</span>;</span></span><br><span class="line">    <span class="comment">// 忽略循环</span></span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		cfs_rq = cfs_rq_of(se);</span><br><span class="line">        <span class="comment">// 核心逻辑</span></span><br><span class="line">		entity_tick(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entity_tick</span><span class="params">(struct cfs_rq *cfs_rq, struct sched_entity *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update run-time statistics of the 'current'.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 更新最小虚拟时间，统计信息，进程此次执行cpu时间和，进程虚拟时间</span></span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果cfs队列中有除了当前进程之外的其他活动进程</span></span><br><span class="line">    <span class="comment">// 或者没有设置抢占唤醒特性，调用check_preempt_tick</span></span><br><span class="line">	<span class="keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="number">1</span> || !sched_feat(WAKEUP_PREEMPT))</span><br><span class="line">		check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个刚从睡眠状态唤醒的进程来说，它的虚拟运行时间一般比较小，可能会抢占当前正在运行的进程，这有时候并不是一件好事，因此调度器支持禁用唤醒抢占，通过禁用<code>WAKEUP_PREEMPT</code>，那么进程被唤醒时会执行<code>check_preempt_wakeup</code>函数，该函数如果检测到<code>WAKEUP_PREEMPT</code>被禁用，则什么也不做直接返回。</p>
<p>但如果你觉得这个特性太过激进，也可以设置<code>sysctl_sched_min_wakeup_latency</code>，在唤醒抢占函数中，会根据该参数以及被抢占进程的权重，计算出一个虚拟时间，只有被唤醒进程的虚拟时间加上这个值大于等于被抢占进程的虚拟时间时，才会执行抢占，这样相当于增加了抢占的难度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gran = sysctl_sched_wakeup_granularity;</span><br><span class="line"><span class="keyword">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">	gran = calc_delta_fair(gran, &amp;se-&gt;load);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pse-&gt;vruntime + gran &lt; se-&gt;vruntime)</span><br><span class="line">	resched_task(curr);</span><br></pre></td></tr></table></figure>

<p>好了让我们继续介绍cfs周期性调度的核心逻辑<code>check_preempt_tick</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ideal_runtime, delta_exec;</span><br><span class="line">    <span class="comment">// 计算当前进程应该占有的cpu物理时间份额</span></span><br><span class="line">	ideal_runtime = sched_slice(cfs_rq, curr);</span><br><span class="line">    <span class="comment">// 计算进程占用cpu以来执行的物理时间</span></span><br><span class="line">	delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span><br><span class="line">    <span class="comment">// 如果超过份额，则执行抢占</span></span><br><span class="line">	<span class="keyword">if</span> (delta_exec &gt; ideal_runtime)</span><br><span class="line">        <span class="comment">// 主要是设置TIF_NEED_SCHED标志，然后在适当的时机执行调度</span></span><br><span class="line">        <span class="comment">// 在smp系统下可能会执行一些负载均衡</span></span><br><span class="line">		resched_task(rq_of(cfs_rq)-&gt;curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到cfs对于周期性调度的处理非常简单，首先调用<code>update_curr</code>更新队列最小虚拟时间，统计信息，进程此次被调度执行以来使用cpu时间总和以及进程虚拟时间。然后判断当前进程是否运行的物理时间超过了它被分配的份额，如果超过则设置进程的<code>TIF_NEED_SCHED</code>标志执行抢占，否则什么也不做。</p>
<h3 id="唤醒抢占"><a href="#唤醒抢占" class="headerlink" title="唤醒抢占"></a>唤醒抢占</h3><p>当调用<code>try_to_wake_up</code>和<code>wake_up_new_task</code>函数尝试唤醒进程时，会调用<code>check_preempt_curr</code>查看是否新进程可以抢占当前进程，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check_preempt_curr</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该函数主要调用调度器类的<code>check_preempt_curr</code>函数，cfs调度器通过<code>check_preempt_wakeup</code>实现该动能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_preempt_wakeup</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> = <span class="title">task_cfs_rq</span>(<span class="title">curr</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = &amp;<span class="title">curr</span>-&gt;<span class="title">se</span>, *<span class="title">pse</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> gran;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新进程动态优先级数值上属于实时进程</span></span><br><span class="line">    <span class="comment">// 那么一定会抢占当前进程，此时只需要调用update_curr</span></span><br><span class="line">    <span class="comment">// 再做一次更新统计，然后设置当前进程的TIF_NEED_SCHED标志</span></span><br><span class="line">    <span class="comment">// 抢占当前进程</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rt_prio(p-&gt;prio))) &#123;</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line">		update_curr(cfs_rq);</span><br><span class="line">		resched_task(curr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Batch tasks do not preempt (their preemption is driven by</span></span><br><span class="line"><span class="comment">	 * the tick):</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果被唤醒的进程调度策略为SCHED_BATCH</span></span><br><span class="line">    <span class="comment">// 那么不会执行抢占</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(p-&gt;policy == SCHED_BATCH))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调度器没有开启唤醒抢占特性</span></span><br><span class="line">    <span class="comment">// 那么也不会执行抢占</span></span><br><span class="line">	<span class="keyword">if</span> (!sched_feat(WAKEUP_PREEMPT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">	<span class="keyword">while</span> (!is_same_group(se, pse)) &#123;</span><br><span class="line">		se = parent_entity(se);</span><br><span class="line">		pse = parent_entity(pse);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这就是前面说的，避免抢占太过频繁</span></span><br><span class="line">	gran = sysctl_sched_wakeup_granularity;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">		gran = calc_delta_fair(gran, &amp;se-&gt;load);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pse-&gt;vruntime + gran &lt; se-&gt;vruntime)</span><br><span class="line">        <span class="comment">// 如果最终还是需要执行抢占，则设置当前进程的TIF_NEED_SCHED标志</span></span><br><span class="line">		resched_task(curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到cfs的唤醒抢占逻辑也并不复杂。但是需要注意的是，我们回顾<code>do_fork</code>函数，<code>do_fork</code>会调用<code>wake_up_new_task</code>函数，如果新进程属于cfs调度器，那么最终会调用<code>check_preempt_wakeup</code>检查新进程是否需要抢占父进程，一般来说我们时希望子进程先于父进程执行的，因为这样能够更好利用写时复制避免很多无效的拷贝操作。但是从这里可以看到，如果关闭了唤醒抢占调度器特性，或者sysctl_sched_wakeup_granularity设置的过大，那么子进程很有可能不会抢占父进程，看起来这是个issue，高版本应该会修复。</p>
<h3 id="处理新进程"><a href="#处理新进程" class="headerlink" title="处理新进程"></a>处理新进程</h3><p>回顾前面的<code>sched_class</code>类，还有一个函数我们需要考虑的就是<code>task_new_fair</code>，该函数调用过程<code>do_fork --&gt; wake_up_new_task --&gt; task_new --&gt; task_new_fair</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_new_fair</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> = <span class="title">task_cfs_rq</span>(<span class="title">p</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>, *<span class="title">curr</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> this_cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	sched_info_queued(p);</span><br><span class="line">    <span class="comment">// 万年不变，更新统计信息</span></span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">    <span class="comment">// 前面介绍过，调整新进程的虚拟时间</span></span><br><span class="line">	place_entity(cfs_rq, se, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 'curr' will be NULL if the child belongs to a different group */</span></span><br><span class="line">    <span class="comment">// 如果设置了sysctl_sched_child_runs_first表明希望子进程能够先执行</span></span><br><span class="line">    <span class="comment">// 如果子进程和父进程将要运行在同一个cpu上但是子进程计算出来的</span></span><br><span class="line">    <span class="comment">// 虚拟时间大于父进程，那么这里需要交换虚拟时间来保证子进程先执行</span></span><br><span class="line">	<span class="keyword">if</span> (sysctl_sched_child_runs_first &amp;&amp; this_cpu == task_cpu(p) &amp;&amp;</span><br><span class="line">			curr &amp;&amp; curr-&gt;vruntime &lt; se-&gt;vruntime) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Upon rescheduling, sched_class::put_prev_task() will place</span></span><br><span class="line"><span class="comment">		 * 'current' within the tree based on its new key value.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		swap(curr-&gt;vruntime, se-&gt;vruntime);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将子进程添加到cfs队列中，前面介绍过</span></span><br><span class="line">    <span class="comment">// 主要是添加到红黑树中，然后增加nr_running</span></span><br><span class="line">    <span class="comment">// load.weight以及进程的on_rq置1</span></span><br><span class="line">	enqueue_task_fair(rq, p, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置当前进程(一般是父进程)的TIF_NEED_SCHED标志</span></span><br><span class="line">    <span class="comment">// 表明执行抢占</span></span><br><span class="line">	resched_task(rq-&gt;curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，cfs对新进程的处理逻辑也是比较清晰的。</p>
<p>到目前为止，除了多处理器下的负载均衡相关部分，cfs调度器类的所有功能就已经介绍完毕了，接下来让我们来看一下<code>wake_up_new_task</code>函数，该函数在<code>do_fork</code>中被调用，但是在介绍<code>fork</code>时并没有深入介绍该函数，通过前面的介绍可以发现该函数涉及到两个调度器函数，分别是<code>check_preempt_wakeup</code>和<code>task_new_fair</code>，我们来看一下该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">wake_up_new_task</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;flags);</span><br><span class="line">	BUG_ON(p-&gt;state != TASK_RUNNING);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新进程p的动态优先级</span></span><br><span class="line">	p-&gt;prio = effective_prio(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新进程所属的调度器类实现了task_new并且父进程</span></span><br><span class="line">    <span class="comment">// 不属于调度器管理，由于新进程是拷贝自父进程</span></span><br><span class="line">    <span class="comment">// 那么此时新进程on_eq也为0，也不属于调度器管理，那么</span></span><br><span class="line">    <span class="comment">// 需要把新进程添加到调度器队列中</span></span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;sched_class-&gt;task_new || !current-&gt;se.on_rq) &#123;</span><br><span class="line">        <span class="comment">// 其实就是对入队操作的一个封装</span></span><br><span class="line">        <span class="comment">// 对于cfs来说，就是加入到队列中，更新调度器信息</span></span><br><span class="line">        <span class="comment">// 然后增加nr_running，load_weight,on_rq=1</span></span><br><span class="line">		activate_task(rq, p, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Let the scheduling class do new task startup</span></span><br><span class="line"><span class="comment">		 * management (if any):</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 否则只需要调用task_new(对cfs来说就是task_new_fair)</span></span><br><span class="line">		p-&gt;sched_class-&gt;task_new(rq, p);</span><br><span class="line">        <span class="comment">// 然后增加nr_running和load.weight</span></span><br><span class="line">		inc_nr_running(p, rq);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 检查是否进行抢占</span></span><br><span class="line">	check_preempt_curr(rq, p);</span><br><span class="line">	task_rq_unlock(rq, &amp;flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，除了smp系统下的相关处理，cfs调度器的所有功能都已经介绍完毕了。下面将从具体案例出发，说明调度器是如何工作的：</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="新进程启动"><a href="#新进程启动" class="headerlink" title="新进程启动"></a>新进程启动</h4><p>让我们回顾一下<code>do_fork</code>的过程，<code>do_fork --&gt; copy_process --&gt; sched_fork</code>最终调用<code>sched_fork</code>和调度器建立联系。<code>sched_fork</code>主要是初始化进程的调度器类和调度实体，然后在多处理器系统下进行处理器间负载均衡，把新进程绑定到合适的cpu上；</p>
<p>接着<code>do_fork --&gt; wake_up_new_task</code>，该函数的作用已经介绍过了，主要是计算新进程的动态优先级，将进程添加到进程所属调度器的调度器队列中(这里假设是cfs调度器)，这个过程还会调用<code>update_curr</code>更新调度器最小虚拟时间、进程自占用cpu以来的cpu物理时间总和，进程虚拟时间，并且增加cfs队列的nr_running和load.weight；</p>
<p>然后会调整新进程的初始虚拟时间，并且在必要时可能会和父进程交换虚拟时间保证子进程先于父进程执行，然后判断是否需要抢占当前进程，如果需要抢占则设置当前运行进程的TIF_NEED_SCHED。</p>
<h4 id="睡眠进程唤醒"><a href="#睡眠进程唤醒" class="headerlink" title="睡眠进程唤醒"></a>睡眠进程唤醒</h4><p>当一个进程从睡眠状态被唤醒时，内核一般调用<code>try_to_wake_up</code>来唤醒睡眠进程，该函数会调用<code>check_preemt_curr</code>，<code>check_preempt_curr</code>是调度器类函数，不同的调度器类实现不同，cfs调度器的实现函数为<code>check_preemt_wakeup</code>函数，该函数判断被唤醒进程和正在运行进程的虚拟时间来判断是否需要执行抢占(当然这里说的很简单，省略了很多过程，可以回顾前面看详细过程)；如果需要执行抢占，则设置当前进程的TIF_NEED_SCHED标志。</p>
<h4 id="周期性调度抢占"><a href="#周期性调度抢占" class="headerlink" title="周期性调度抢占"></a>周期性调度抢占</h4><p>周期性调度由cpu本地定时时钟周期性触发执行，周期新函数就是<code>scheduler_tick</code>，该函数首先会更新就绪队列的时钟(是就绪队列而不是调度器队列，注意区分)，然后会调用调度器类的<code>task_tick</code>函数，cfs的实现函数是<code>task_tick_fair</code>函数，该函数主要是先调用<code>update_curr</code>更新一些量，然后调用<code>check_preempt_tick</code>比较进程自占用cpu以来使用的cpu物理时间和该进程被分配到的最大cpu份额，如果超过该份额，那么设置该进程的<code>TIF_NEED_SCHED</code>标志。</p>
<h2 id="实时调度器"><a href="#实时调度器" class="headerlink" title="实时调度器"></a>实时调度器</h2><p>Linux目前版本的实时调度器有两种策略，一种是轮转时间，一种是先进先出。这两种策略实现比较简单，就不过多介绍了，感兴趣可以直接看源码。</p>
<h2 id="SMP增强"><a href="#SMP增强" class="headerlink" title="SMP增强"></a>SMP增强</h2><p>到目前为止，和CFS调度器相关的功能都已经介绍完了，但实际上Linux做的更多，尤其是对于SMP系统。下面就来具体看一看：</p>
<h3 id="多处理器负载均衡"><a href="#多处理器负载均衡" class="headerlink" title="多处理器负载均衡"></a>多处理器负载均衡</h3><p>多处理器上，内核需要考虑几个额外的问题，以确保良好的调度：</p>
<ol>
<li>CPU负荷必须尽可能公平地在所有处理器上共享，如果某个处理器非常繁忙而另外的处理器非常空闲，这样肯定是不合理的</li>
<li>进程与某些CPU的亲和性必须是可设置的。例如在4个CPU系统中，可以将计算密集型程序绑定到前3个CPU，而剩余的交互式进程则运行在第四个CPU上。</li>
<li>内核必须能够讲进程从一个CPU迁移到另外一个。但是这不能随意使用，因为这会严重影响性能。例如缓存失效。而在大型系统上，CPU与迁移进程此前使用的物理内存距离可能有若干米，因此这样一来进程对内存的访问代价很高</li>
</ol>
<p>进程对于特定CPU的亲和性，定义在<code>task_struct</code>的<code>cpus_allowed</code>成员中，Linux提供了<code>sched_setaffinity</code>系统调用，可以修改进程与CPU的现有分配关系。</p>
<p>负载均衡简单的说就是：检查各个cpu之间的负载，如果发现某个cpu负载过高，则在处理器之间进行负载均衡，将高负载处理器上的进程向低负载处理器上迁移。</p>
<p>周期性调度器<code>scheduler_tick</code>的末尾会触发软中断，该软中断在合适的时候进行负载均衡。具体更加详细的东西，暂时不想看了，以后再说吧。</p>
<p>另外可能聪明的读者已经想到了，一个进程可能在不同的处理器上执行，那么如果不同处理器就绪队列的cfs调度器队列虚拟运行时间不同，那么进程可能会吃亏或者占便宜。举个例子：进程先在队列A上，队列A的最小虚拟时间为1000，此时进程的虚拟时间为1500，不久后进程被迁移到队列B上，而队列B的最小虚拟时间为1800，那么一旦进程被迁移到队列B，那么进程会立刻被执行，因为两个队列的最小虚拟时间不同，进程在两个队列红黑树上的位置也不同。</p>
<p>目前2.6版本还是存在这个bug的，但是高版本实际上已经解决了，如何解决这个问题呢？其实也非常简单，进程在添加到队列中时，将进程的虚拟运行时间修改为<code>vruntime - 该队列的最小虚拟时间</code>，也就是这里只存储了差值，当进程从调度队列上拿出来执行时，再加上队列的最小虚拟时间。这样一来即使进程在不同队列上迁移，那么进程也不太会占便宜。</p>
<p>有一篇文章挺不错的，贴一下：<a href="https://www.jianshu.com/p/673c9e4817a8" target="_blank" rel="noopener">文章</a></p>
<h3 id="内核抢占和低延迟相关"><a href="#内核抢占和低延迟相关" class="headerlink" title="内核抢占和低延迟相关"></a>内核抢占和低延迟相关</h3><h4 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h4><p>对于不支持内核抢占的内核，在系统调用后返回用户状态之前，或在内核中某些指定的点上，会调用调度器；而在除了这些情况之外，内核是无法抢占的。如果内核处于相对较长的操作中，比如文件系统和内存管理相关的任务，这样可能会带来一些问题。内核代表特定的进程执行相当长的时间，其他进程则无法运行。这样可能会导致系统延迟增加，给用户体验到差劲儿的响应。如果多媒体应用长时间无法得到CPU，可能会发生视频和音频漏失现象。</p>
<p>为了解决这种问题，Linux退出了内核抢占，如果在编译内核时启用对内核抢占的支持，那么高优先级的进程如果有事情需要完成，那么不仅用户应用程序可以被抢占，内核也可以被抢占。内核抢占是2.5版本添加的，尽管使内核可抢占所需要的改动非常少，但该机制不像抢占用户空间进程那样容易实现。如果内核无法一次性完成某些操作(例如对数据结构的操作)，那么可能会出现竞态条件而使系统不一致。</p>
<p>因此内核不能再任意点上被中断抢占。不过幸好，大多数不能中断的点已经被SMP实现标识出来了，并且在实现内核抢占时可以重用这些信息。内核的某些易于出现问题的部分每次只能由一个处理器访问，这些部分使用自旋锁保护：到达临界区的第一个处理器会获得锁，而其他想要访问的处理器会一直等待知道第一个处理器释放锁。</p>
<p>如果内核可以被抢占，即使单处理器系统也会像SMP系统。考虑正在临界区内部工作的内核被抢占的情况。下一个进程也在内核态工作，凑巧也要访问同一个临界区，这样就会出现问题。因此每次内核进入临界区时，都必须禁止内核抢占。</p>
<p>内核如何确定此时能否被抢占呢？回想一下系统中每个进程都有一个特定于体系结构的<code>thread_info</code>结构，该结构包含了一个<code>抢占计数器</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> preempt_count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该字段确定了内核当前是否处于一个可以被抢占的位置。如果<code>preempt_count==0</code>那么内核可以被抢占，否则不行。该值不能直接操作，一般通过<code>dec_preempt_count</code>和<code>inc_preempt_count</code>。这两个分别对<code>preempt_count</code>加1减1。每次内核进入重要区域，需要禁止抢占时，都会调用<code>inc_preempt_count</code>。在退出该区域时，就会调用<code>dec_preempt_count</code>将抢占计数器减1。由于内核可能通过不同的路线进入某些重要的区域，特别是嵌套路线，因此<code>preempt_count</code>不能使用简单的布尔变量。</p>
<p>除此之外，内核还提供了更多的函数用于抢占处理：</p>
<h5 id="preempt-disable"><a href="#preempt-disable" class="headerlink" title="preempt_disable"></a>preempt_disable</h5><p>通过调用<code>inc_preempt_count</code>来停止抢占：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_disable() \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">	preempt_count_inc(); \</span><br><span class="line">	barrier(); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="preempt-check-resched"><a href="#preempt-check-resched" class="headerlink" title="preempt_check_resched"></a>preempt_check_resched</h5><p>会检测是否有必要进行调度，如果有必要则进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_check_resched() \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">    <span class="comment">// 如果当前进程设置了TIF_NEED_SCHED标志，则执行内核抢占</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \</span><br><span class="line">		preempt_schedule(); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asmlinkage <span class="keyword">void</span> __<span class="function">sched <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> = <span class="title">current_thread_info</span>();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_BKL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="keyword">int</span> saved_lock_depth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is a non-zero preempt_count or interrupts are disabled,</span></span><br><span class="line"><span class="comment">	 * we do not want to preempt the current task. Just return..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果抢占计数器不为0，或者中断被禁止，则不执行抢占直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (likely(ti-&gt;preempt_count || irqs_disabled()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 设置PREEMPT_ACTIVE，实际上PREEMPT_ACTIVE是</span></span><br><span class="line">        <span class="comment">// preempt_count计数器最高位</span></span><br><span class="line">		add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We keep the big kernel semaphore locked, but we</span></span><br><span class="line"><span class="comment">		 * clear -&gt;lock_depth so that schedule() doesnt</span></span><br><span class="line"><span class="comment">		 * auto-release the semaphore:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">       <span class="comment">// 大内核锁相关，忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_BKL</span></span><br><span class="line">		saved_lock_depth = task-&gt;lock_depth;</span><br><span class="line">		task-&gt;lock_depth = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 执行调度</span></span><br><span class="line">		schedule();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_BKL</span></span><br><span class="line">		task-&gt;lock_depth = saved_lock_depth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 复位PREEMPT_ACTIVE</span></span><br><span class="line">		sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 内存屏障</span></span><br><span class="line">		barrier();</span><br><span class="line">        <span class="comment">// 当该进程下次被恢复执行时又被设置了TIF_NEED_RESCHED标志</span></span><br><span class="line">        <span class="comment">// 则再次执行调度</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PREEMPT_ACTIVE</code>是一个很大的值，主要用来告诉<code>schedule</code>函数，此次调度由内核抢占出发，这样能避免一种特殊情况(前文有说到)。</p>
<h5 id="preempt-enable"><a href="#preempt-enable" class="headerlink" title="preempt_enable"></a>preempt_enable</h5><p>该函数和上面的<code>preempt_disable</code>相反，递减<code>preempt_count</code>计数器以允许内核抢占，并且检查是否需要执行抢占：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_enable() \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">    <span class="comment">// 递减抢占计数器</span></span><br><span class="line">	preempt_enable_no_resched(); \</span><br><span class="line">	barrier(); \</span><br><span class="line">    <span class="comment">// 检测是否需要执行调度，如需要则执行调度</span></span><br><span class="line">	preempt_check_resched(); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="preempt-enable-no-resched"><a href="#preempt-enable-no-resched" class="headerlink" title="preempt_enable_no_resched"></a>preempt_enable_no_resched</h5><p>递减抢占计数器以允许内核抢占，但是不进行重新调度。</p>
<h4 id="低延迟"><a href="#低延迟" class="headerlink" title="低延迟"></a>低延迟</h4><p>上面说的都是通过开启内核抢占来避免高延迟，但是如果没有开启内核抢占，内核也需要尽可能的提供良好的延迟时间。例如对于网络服务器很重要。如果一个网络请求到达，需要守护进程处理，那么该请求不应该被执行繁重IO操作的数据库过度延迟。也就是说，即使没有开启内核抢占，内核中耗时长的操作不应该完全占据整个系统。相反，这中耗时长的操作需要时不时的检测是否有另外一个进程变为可运行，并在必要的情况喜爱调用<code>schedule</code>选择相应的进程执行。该机制在内核抢占关闭时也能生效。</p>
<p>发起有条件重调度的函数时<code>cond_resched</code>，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">sched <span class="title">cond_resched</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前进程的TIF_NEED_SCHED标志和抢占计数器</span></span><br><span class="line">	<span class="keyword">if</span> (need_resched() &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">		__cond_resched();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __cond_resched(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK_SLEEP</span></span><br><span class="line">	__might_sleep(__FILE__, __LINE__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The BKS might be reacquired before we have dropped</span></span><br><span class="line"><span class="comment">	 * PREEMPT_ACTIVE, which could trigger a second</span></span><br><span class="line"><span class="comment">	 * cond_resched() call.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 设置内核抢占标志</span></span><br><span class="line">		add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">        <span class="comment">// 执行调度</span></span><br><span class="line">		schedule();</span><br><span class="line">        <span class="comment">// 复位内核抢占标志</span></span><br><span class="line">		sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">        <span class="comment">// 进程重新执行时再次检查</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用<code>cond_resched</code>函数呢？举例来说，内核可能会在无限循环中反复读取数据直到数据读取完毕：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">if</span> (exit_condition)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要大量的读取草嘴，可能会耗时很长，而如果没有开启内核抢占，那么进程在内核空间中无法被抢占。此时可以在无限循环中插入<code>cond_resched</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    cond_resched();</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">if</span> (exit_condition)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核代码已经仔细核查过，以找出长时间运行的函数，并在适当的地方插入该函数，这样即使内核没有开启内核抢占，也能够保证较高的响应速度。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Linux 2.6.24采用了大名鼎鼎的CFS调度器，在实际应用时候表现很不错，并且相对于O(1)调度器，也没有各种启发式规则，表现也相对稳定。在实现时也比O(1)调度器要简单很多。另外，2.6内核也支持内核抢占，从而提供更好的响应时间，另外即使没有开启内核抢占，内核也会在内核耗时较长的函数中插入<code>cond_resched</code>函数检查是否需要调度，这样能够避免由于进程在内核执行时间过长而导致无法被抢占，进一步响应时间变长。</p>

    </div>

    
    
    
	<div>
	
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------</div>
    
</div>

	
	</div>
	<div>
      
        
      
	</div>
        
      
        <div id="reward-container">
  <div>如果你喜欢，请我喝杯茶呗...</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="郭源潮 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/SourceCode/" rel="tag"><i class="fa fa-tag"></i>SourceCode</a>
            
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i>Linux</a>
            
              <a href="/tags/2-6-24/" rel="tag"><i class="fa fa-tag"></i>2.6.24</a>
            
              <a href="/tags/2-6-11/" rel="tag"><i class="fa fa-tag"></i>2.6.11</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2022/02/13/Linux内核之进程管理与调度(一)/" rel="next" title="Linux内核之进程管理与调度(一)">
                  <i class="fa fa-chevron-left"></i> Linux内核之进程管理与调度(一)
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#调度时机"><span class="nav-number">1.</span> <span class="nav-text">调度时机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内核实现"><span class="nav-number">2.</span> <span class="nav-text">内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">2.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#task-struct中调度相关字段"><span class="nav-number">2.1.1.</span> <span class="nav-text">task_struct中调度相关字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时优先级"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">实时优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度类"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">调度类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度实体"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">调度实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度策略"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">调度策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU控制位"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">CPU控制位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环调度器相关"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">循环调度器相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#辅助函数-标志"><span class="nav-number">2.1.2.</span> <span class="nav-text">辅助函数/标志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助标志"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">辅助标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助函数"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">辅助函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器类"><span class="nav-number">2.1.3.</span> <span class="nav-text">调度器类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#就绪队列"><span class="nav-number">2.1.4.</span> <span class="nav-text">就绪队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助函数-1"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">辅助函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度实体-1"><span class="nav-number">2.1.5.</span> <span class="nav-text">调度实体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级处理"><span class="nav-number">2.1.6.</span> <span class="nav-text">优先级处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级内核表示"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">优先级内核表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算优先级"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">计算优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级作用"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">优先级作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算权重负荷"><span class="nav-number">2.1.6.4.</span> <span class="nav-text">计算权重负荷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用调度器"><span class="nav-number">2.1.7.</span> <span class="nav-text">通用调度器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#周期性调度器"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">周期性调度器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主调度器"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">主调度器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFS调度器"><span class="nav-number">2.2.</span> <span class="nav-text">CFS调度器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFS虚拟时钟"><span class="nav-number">2.2.2.</span> <span class="nav-text">CFS虚拟时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟跟踪"><span class="nav-number">2.2.3.</span> <span class="nav-text">延迟跟踪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列操作"><span class="nav-number">2.2.4.</span> <span class="nav-text">队列操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入队操作"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">入队操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出队操作"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">出队操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#放回和选择"><span class="nav-number">2.2.5.</span> <span class="nav-text">放回和选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#放回正在运行进程"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">放回正在运行进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择下一个进程"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">选择下一个进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#周期性调度器-1"><span class="nav-number">2.2.6.</span> <span class="nav-text">周期性调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唤醒抢占"><span class="nav-number">2.2.7.</span> <span class="nav-text">唤醒抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理新进程"><span class="nav-number">2.2.8.</span> <span class="nav-text">处理新进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-number">2.2.9.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新进程启动"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">新进程启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#睡眠进程唤醒"><span class="nav-number">2.2.9.2.</span> <span class="nav-text">睡眠进程唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#周期性调度抢占"><span class="nav-number">2.2.9.3.</span> <span class="nav-text">周期性调度抢占</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实时调度器"><span class="nav-number">2.3.</span> <span class="nav-text">实时调度器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SMP增强"><span class="nav-number">2.4.</span> <span class="nav-text">SMP增强</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理器负载均衡"><span class="nav-number">2.4.1.</span> <span class="nav-text">多处理器负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核抢占和低延迟相关"><span class="nav-number">2.4.2.</span> <span class="nav-text">内核抢占和低延迟相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内核抢占"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">内核抢占</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#preempt-disable"><span class="nav-number">2.4.2.1.1.</span> <span class="nav-text">preempt_disable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preempt-check-resched"><span class="nav-number">2.4.2.1.2.</span> <span class="nav-text">preempt_check_resched</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preempt-enable"><span class="nav-number">2.4.2.1.3.</span> <span class="nav-text">preempt_enable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preempt-enable-no-resched"><span class="nav-number">2.4.2.1.4.</span> <span class="nav-text">preempt_enable_no_resched</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#低延迟"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">低延迟</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/images.png"
      alt="郭源潮">
  <p class="site-author-name" itemprop="name">郭源潮</p>
  <div class="site-description" itemprop="description">时间在无声的诉说着一切</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/guoyuanchao1202" title="GitHub &rarr; https://github.com/guoyuanchao1202" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:932552424@qq.com" title="E-Mail &rarr; mailto:932552424@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/6273792268?is_all=1" title="Weibo &rarr; https://weibo.com/u/6273792268?is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.w3school.com.cn/tags/tag_ul.asp" title="https://www.w3school.com.cn/tags/tag_ul.asp" rel="noopener" target="_blank">w3school</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭源潮</span>
</div>
	<div class="powered-by">
	<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
	  本站访客数:<span id="busuanzi_value_site_uv"></span>
	  <span id="busuanzi_container_site_pv">
	  本站总访问量<span id="busuanzi_value_site_pv"></span>次
	  </span>
	</span>
	</div>
<!--

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.0</div>
-->

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='96,96,96' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

 
  <script type = "text/javascript"  src ="dist/canvas-nest.js"> </script>
 
</body>
</html>
