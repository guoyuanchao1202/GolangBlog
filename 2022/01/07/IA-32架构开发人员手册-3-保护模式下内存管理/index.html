<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="上一篇文章介绍了Intel IA-32架构的整体架构，从本节开始，将会逐一对前面涉及到的每一个部分进行详细介绍，本节要介绍的就是硬件架构下的内存管理。">
<meta name="keywords" content="IA-32,OS,系统编程指南">
<meta property="og:type" content="article">
<meta property="og:title" content="IA-32架构开发人员手册-3-保护模式下内存管理">
<meta property="og:url" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/index.html">
<meta property="og:site_name" content="CommonGuy">
<meta property="og:description" content="上一篇文章介绍了Intel IA-32架构的整体架构，从本节开始，将会逐一对前面涉及到的每一个部分进行详细介绍，本节要介绍的就是硬件架构下的内存管理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/1.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/2.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/3.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/4.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/5.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/6.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/7.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/8.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/9.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/10.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/11.png">
<meta property="og:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/12.png">
<meta property="og:updated_time" content="2022-01-15T12:09:51.175Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IA-32架构开发人员手册-3-保护模式下内存管理">
<meta name="twitter:description" content="上一篇文章介绍了Intel IA-32架构的整体架构，从本节开始，将会逐一对前面涉及到的每一个部分进行详细介绍，本节要介绍的就是硬件架构下的内存管理。">
<meta name="twitter:image" content="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/1.png">
  <link rel="canonical" href="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>IA-32架构开发人员手册-3-保护模式下内存管理 | CommonGuy</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/HoA-W" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CommonGuy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://guoyuanchao1202/GolangBlog.github.io/2022/01/07/IA-32架构开发人员手册-3-保护模式下内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭源潮">
      <meta itemprop="description" content="时间在无声的诉说着一切">
      <meta itemprop="image" content="/images/images.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CommonGuy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">IA-32架构开发人员手册-3-保护模式下内存管理

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-01-07 21:55:53" itemprop="dateCreated datePublished" datetime="2022-01-07T21:55:53+08:00">2022-01-07</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-15 20:09:51" itemprop="dateModified" datetime="2022-01-15T20:09:51+08:00">2022-01-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/System-Programming-Guide/" itemprop="url" rel="index"><span itemprop="name">System Programming Guide</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上一篇文章介绍了Intel IA-32架构的整体架构，从本节开始，将会逐一对前面涉及到的每一个部分进行详细介绍，本节要介绍的就是硬件架构下的内存管理。</p>
<hr>
<a id="more"></a>

<h1 id="概览-MEMORY-MANAGEMENT-OVERVIEW"><a href="#概览-MEMORY-MANAGEMENT-OVERVIEW" class="headerlink" title="概览(MEMORY MANAGEMENT OVERVIEW)"></a>概览(MEMORY MANAGEMENT OVERVIEW)</h1><p>IA-32架构下的内存管理被分为两部分：分段和分页。分段机制为每个任务提供了提供了单独隔离的代码段、数据段和堆栈段，这样多个任务之间的执行就能够做到互不影响；分页机制实现了传统的按需分页、虚拟内存系统，该系统能够将程序执行过程中需要的部分加载到物理内存中，分页机制同样能实现多任务之间的隔离。在保护模式下，分段式必须使用的，但是分页是可选的(CR0.PG)。</p>
<p>上述两种机制(分页/分段)能够通过配置从而实现单任务系统、多任务一同以及使用共享内存的多处理器系统。如下图所示</p>
<p><img src="1.png" alt></p>
<p>分段机制能够将处理器可寻址的线性地址空间分割成被称为段的更小的受保护的地址空间。段可以用来保存程序代码、数据、程序需要的堆栈或者系统数据结构(如LDT、TSS)，如果一个处理器上有多个任务在运行，那么每个任务都能被分配到它专属的这样一组段。并且处理器限制这些段之间的边界，并确保一个程序不会因为写进另一个程序的段而干扰另一个程序的执行。分段机制也可以对段进行分类从而限制对特定类型的段进行操作(如限制写入代码段)。</p>
<p>系统中的所有段都位于处理器的线性地址空间中。如果想要寻址某个段中的一个字节，那么需要提供一个逻辑地址。一个逻辑地址由段选择子和偏移两部分组成。段选择子是段的唯一标识符，通过段选择子可以在(GDT/LDT)中找到段对应的段描述符，段描述符中记录了段的基线性地址、段限长、访问权限、特权级别、段类型等信息。通过段描述符中的基线性地址和逻辑地址中提供的偏移址，就能够确定一个字节在段中的位置。</p>
<p>如果没有开启分页，那么线性地址就是处理器的物理地址。物理地址范围就是处理器在总线上生成的地址范围。因为多任务系统通常会定义一个比实际物理地址空间大很多的线性地址空间，因此就需要使用虚拟内存技术，线性地址空间的虚拟化由处理器的分页机制处理。分页机制支持一个由较小的物理内存(RAM/ROM)和磁盘存储虚拟出的一个较大的虚拟的地址空间。当开启分页时，每一个段被分割成若干个页(通常每个页4KB)，这些页内存储在内存或者磁盘中。当应用程序尝试访问一个线性地址空间的地址时，处理器会使用分页机制将线性地址转换为物理地址，然后对其执行相应的请求操作(读写)。</p>
<p>如果要访问的页当前不在内存中，那么处理器会中断当前正在执行的程序(通过产生一个缺页异常来中断程序)。接着操作系统会将要访问的页从磁盘加载进内存然后继续执行应用程序。</p>
<p>一个正常的使用了分页机制的操作系统，页在磁盘和物理内存之间的交换对应用程序是透明的。甚至是16为的IA-32程序在虚拟8086模式下也能够被透明的分页</p>
<h1 id="分段机制-USING-SEGMENTS"><a href="#分段机制-USING-SEGMENTS" class="headerlink" title="分段机制(USING SEGMENTS)"></a>分段机制(USING SEGMENTS)</h1><p>IA-32架构支持的分段机制可用于实现各种系统设计，这些设计可以是平坦模型，即仅仅利用分段来保护程序，也可以是充分利用分段机制构建一个健壮的系统，让多个任务可以可靠地执行。下面几节将举例说明如何在系统中采用分段来提高内存管理的性能和可靠性。</p>
<h2 id="基础平坦模型-Basic-Flat-Model"><a href="#基础平坦模型-Basic-Flat-Model" class="headerlink" title="基础平坦模型(Basic Flat Model)"></a>基础平坦模型(Basic Flat Model)</h2><p>最简单的系统内存模型就是基础平坦模型，在基础平坦模型中，操作系统和程序可以访问一个连续的、没有分段的地址空间。无论是对系统设计者还是程序开发人员，基础平坦模型最大程度上隐藏了架构的分段机制。</p>
<p>在IA-32架构下实现一个基础平坦模型，至少需要创建两个段描述符：一个指向代码段，另外一个执行数据段。然而这两个段被映射到整个线性地址空间，也就是说，这两个段的基地址和限长相同，分别是0和4G。通过设置4GB的段限长，分段机制就不会因为超过段限长的线性地址而产生(GP)异常，即使指定底下下没有物理内存。</p>
<p>ROM一般位于地址空间的顶部，因为处理器从FFFFFFF0H开始执行(硬件设计)，RAM位于地址空间底部，因为刚通电或者复位初始化后，DS寄存器值被初始化为0。</p>
<p><img src="2.png" alt></p>
<h2 id="保护平坦模型"><a href="#保护平坦模型" class="headerlink" title="保护平坦模型"></a>保护平坦模型</h2><p>保护平坦模型与基础平坦模型类似，区别在于保护平坦模型的段限长被设定为指定物理内存范围内，如果试图访问物理内存之外的不存在的内存，则会产生一个通用保护异常(GP)。</p>
<p><img src="3.png" alt></p>
<p>可以使保护平坦模型更加复杂从而支持更多的保护功能。例如：为了能在分页机制中分离普通用户和超级用户的代码和数据，需要定义4个段：特权级为3的代码段和数据段、特权级为0的代码段和数据段。通常这些段是相互覆盖的并且基地址都是线性地址空间的0地址。这种平坦分段模型能够在操作系统和应用程序之间起到保护作用，并且通过为每个任务提供一个分页结构(页表)，能够在应用程序之间提供保护作用。一些流行的多任务操作系统使用了类似的设计。</p>
<h2 id="多段模型"><a href="#多段模型" class="headerlink" title="多段模型"></a>多段模型</h2><p>一个多段模型充分利用了分段机制，提供了对代码、数据以及程序任务的硬件级强制保护。在该模式下，每个任务都有各自的段描述符和段，程序可以完全独享这些段，也可以与其他进程共享这些段。对所有段的访问以及对系统上运行的各执行程序的访问由硬件控制。</p>
<p>分段机制不仅可以拒绝访问一个超过段限长的地址，还可以阻止一些在段中不允许执行的操作。例如：代码段是只读的，因此硬件能够阻止任何尝试写代码段的操作。为段产生的权限信息也可以用来设置特权级别，特权级别能够用来保护操作系统被未授权的应用程序访问。</p>
<p><img src="4.png" alt></p>
<h2 id="IA-32e模式下分段-Segmentation-in-IA-32e-Mode"><a href="#IA-32e模式下分段-Segmentation-in-IA-32e-Mode" class="headerlink" title="IA-32e模式下分段(Segmentation in IA-32e Mode)"></a>IA-32e模式下分段(Segmentation in IA-32e Mode)</h2><p>在IA-32e模式下，分段的区别取决于是在兼容性模式下还是在64位模式下。在兼容模式下，分段模式和传统的32位、16位下一样。</p>
<p>在64位模式下，分段通常是(但不是完全)被禁用的，取而代之的是一个平坦的64位的线性地址空间。处理器默认CS、DS、ES、SS这些段的段基地址为0，这时逻辑地址就是线性地址，因为不再需要通过段基地址 + 偏移地址来将逻辑地址转换成线性地址了。FS和GS段寄存器除外，这两个基地址可以用作寄存器间接寻址使用。需要注意的是，64位模式下处理器不会进行段限长检查(因为64位模式下实际上不使用段)</p>
<h2 id="分页与分段-Paging-and-Segmentation"><a href="#分页与分段-Paging-and-Segmentation" class="headerlink" title="分页与分段(Paging and Segmentation)"></a>分页与分段(Paging and Segmentation)</h2><p>在上述的三种分段模型中，都可以使用分页。处理器把线性地址空间分割成许多的页，这些页再被映射到实际的物理地址空间。分页机制提供了一些页级别的保护措施，这些保护措施可以和段保护措施搭配或者取代段的保护措施。例如：它可以对每个页实行读写保护。另外，分页机制同样能够对每个页实现用户-管理员两级别保护。</p>
<h1 id="物理地址空间-PHYSICAL-ADDRESS-SPACE"><a href="#物理地址空间-PHYSICAL-ADDRESS-SPACE" class="headerlink" title="物理地址空间(PHYSICAL ADDRESS SPACE)"></a>物理地址空间(PHYSICAL ADDRESS SPACE)</h1><p>在保护模式下，IA-32架构提供了最大4GB的物理地址空间(2的32次方)，这些地址是处理器能够在地址总线上的寻址范围。这些地址空间是平坦的(未分段的)、连续的从0x0H-0xFFFFFFFFH的所有地址。物理地址空间同样可以被映射到读写内存、只读内存、I/O内存。本节描述的内存映射功能能够将物理内存分割成段和(或)页。</p>
<p>从奔腾pro处理器开始，IA-32支持将物理地址空间扩展到64GB，此时最大物理地址为0xFFFFFFFFFH，该扩展通过一下两种方式实现：</p>
<ul>
<li>开启CR4的第5个控制位，PAE位</li>
<li>开启PSE功能(奔腾三处理器引入)</li>
</ul>
<p>物理地址后来已经支持扩展到36位以上</p>
<h2 id="Intel64处理器和物理地址空间-Intel®-64-Processors-and-Physical-Address-Space"><a href="#Intel64处理器和物理地址空间-Intel®-64-Processors-and-Physical-Address-Space" class="headerlink" title="Intel64处理器和物理地址空间(Intel® 64 Processors and Physical Address Space)"></a>Intel64处理器和物理地址空间(Intel® 64 Processors and Physical Address Space)</h2><p>目前64位模式下开放了48位的物理内存地址，最多可以支持256TB的物理内存(这句话不是指南上的，是查阅资料得来)</p>
<h1 id="逻辑地址与线性地址-LOGICAL-AND-LINEAR-ADDRESSES"><a href="#逻辑地址与线性地址-LOGICAL-AND-LINEAR-ADDRESSES" class="headerlink" title="逻辑地址与线性地址(LOGICAL AND LINEAR ADDRESSES)"></a>逻辑地址与线性地址(LOGICAL AND LINEAR ADDRESSES)</h1><p>保护模式下，处理器会经过两步骤转换最终得到物理地址，逻辑地址转换机制与线性地址的分页机制。</p>
<p>即使最小程度的段机制的使用，处理器地址空间内的每个字节都是通过逻辑地址访问的。一个逻辑地址包含16位的段选择符和32位的段内偏移两个部分。段选择子用于从GDT/LDT中确定指定的段描述符，通过段描述符可以确定段基地址、段限长、段访问权限信息等，从而可以在线性地址空间中确定一个段，通过32位的的段内偏移值，可以确定该字节在段内的位置。</p>
<p>处理器会将每一个逻辑地址转换为线性地址，线性地址是处理器32位线性地址空间中的一个地址。就像物理地址一样，线性地址空间是平坦的、从0x0H到0xFFFFFFFFH的连续的地址空间。线性地址空间包含了系统定义的所有段和数据结构。逻辑地址到线性地址的转换如下所示：</p>
<p><img src="5.png" alt></p>
<p>如果没有开启分页，处理器会直接将线性地址当作物理地址送到地址总线，如果开启了分页，那么需要将线性地址进一步通过分页机制转换成物理地址。</p>
<h2 id="IA-32e模式下的逻辑地址转换-Logical-Address-Translation-in-IA-32e-Mode"><a href="#IA-32e模式下的逻辑地址转换-Logical-Address-Translation-in-IA-32e-Mode" class="headerlink" title="IA-32e模式下的逻辑地址转换(Logical Address Translation in IA-32e Mode)"></a>IA-32e模式下的逻辑地址转换(Logical Address Translation in IA-32e Mode)</h2><p>在IA-32e模式下，64位处理器使用上述步骤将逻辑地址转换为线性地址。在64位模式下，段的偏移量和基地址是64位而不是32位。线性地址格式也是64位宽。每个代码段描述符都提供一个L位。这个位允许一个代码段按代码段执行64位代码或传统的32位代码。</p>
<h2 id="段选择子-Segment-Selectors"><a href="#段选择子-Segment-Selectors" class="headerlink" title="段选择子(Segment Selectors)"></a>段选择子(Segment Selectors)</h2><p>段选择子是一个16bit位的段标志符，它不直接指向段，而是指向GDT/LDT中的段描述符。通过段描述符确定段在线性地址空间中的位置。一个段选择子包含以下几个部分：</p>
<p><img src="6.png" alt></p>
<h3 id="Index-3-15bit"><a href="#Index-3-15bit" class="headerlink" title="Index(3-15bit)"></a>Index(3-15bit)</h3><p>用于从GDT/LDT的8192个段描述符项中确定指定的段描述符，由于每个段描述符是8字节长度，因此Index * 8就得到了GDT/LDT中指定段描述符的位置。</p>
<h3 id="TI-table-indicator-bit2"><a href="#TI-table-indicator-bit2" class="headerlink" title="TI(table indicator, bit2)"></a>TI(table indicator, bit2)</h3><p>用于指定GDT/LDT表，如果TI置1，那么从LDT表中寻找，如果TI置0，那么从GDT中寻找</p>
<h3 id="RPL-Requested-Privilege-Level-bit0-1"><a href="#RPL-Requested-Privilege-Level-bit0-1" class="headerlink" title="RPL(Requested Privilege Level bit0-1)"></a>RPL(Requested Privilege Level bit0-1)</h3><p>指定了段选择子的特权级。特权级从0到3，0特权级有对系统最高的特权，操作系统就是处于该优先级，特权级3一般是应用程序。</p>
<p>处理器不会使用GDT表的第一个段描述符，一个段选择子可以通过指向该描述符表明选择子是一个空段选择子。当像段寄存器(除了CS和SS)加载空选择子时处理器不会产生异常，但是如果尝试使用该空选择子，那么处理器会产生一个通用保护异常。需要注意的是，向CS和SS加载空选择子会导致一个通用保护异常的产生。</p>
<p>段选择符作为指针变量，可以被引用程序查看，但是由链接程序设置和修改，应用程序无法更改。</p>
<h2 id="段寄存器-Segment-Registers"><a href="#段寄存器-Segment-Registers" class="headerlink" title="段寄存器(Segment Registers)"></a>段寄存器(Segment Registers)</h2><p>为了减少地址转换的开销和代码复杂性，处理器提供了6个段寄存器去存储段选择子。每个段寄存器都支持特定类型的内存寻址(代码段、数据段、堆栈段等)。实际上对于任何一个程序而言，执行之前必须要将代码段寄存器(CS)、数据段寄存器(DS)以及堆栈段寄存器(SS)赋予有效的段选择子。处理器同时提供了三个额外的段寄存器(ES、FS以及GS)为当前执行程序提供额外的段。</p>
<p>程序如果试图访问某个段，那么这个段的段选择子必须要被加载到这些段寄存器之一。因此，尽管一个系统可以定义很多的段，但是只有6个段能够被立刻使用(因为只有6个段寄存器)。其他的段只有在程序执行过程中将其段选择符加载进段寄存器时才能被程序使用。</p>
<p><img src="7.png" alt></p>
<p>每个段寄存器都有两个部分：可见部分和隐藏部分(隐藏部分由北称为描述符缓存或者阴影寄存器)。当一个段选择子被加载到段寄存器的可见部分时，处理器会将段选择子对应段描述符的段基地址、段限长、访问控制信息等加载到段寄存器的隐藏部分。这样能够允许处理器在进行地址转换时不必花费额外的总线周期去段描述符中查询，直接使用段寄存器的隐藏部分即可。</p>
<p>在多处理器可以访问同一个描述符表的系统中，软件必须负责在处理器修改描述符表时重新加载段寄存器；否则段寄存器的描述符缓存中仍然缓存着旧的描述符信息，这样可能会造成问题。</p>
<p>有两种方式可以加载段寄存器</p>
<ul>
<li>直接加载指令，比如MOV、POP、LES、LSS、LGS以及LFS指令，这些指令明确的引用段寄存器</li>
<li>隐含加载指令，比如如CALL、JMP以及RET指令的远指针版本，SYSENTER和SYSEXIT指令，以及IRET、INT n、INTO、INT3和INT1指令。这些寄存器会默认修改CS段寄存器(有时可能会同时修改其他段寄存器)作为其指令操作的一部分</li>
</ul>
<p>MOV指令同样能够将段寄存器的可见部分加载到通用寄存器中</p>
<h2 id="IA-32e模式下的段加载指令-Segment-Loading-Instructions-in-IA-32e-Mode"><a href="#IA-32e模式下的段加载指令-Segment-Loading-Instructions-in-IA-32e-Mode" class="headerlink" title="IA-32e模式下的段加载指令(Segment Loading Instructions in IA-32e Mode)"></a>IA-32e模式下的段加载指令(Segment Loading Instructions in IA-32e Mode)</h2><p>因为ES、DS、SS寄存器在64位模式下不再使用，因此寄存器中段描述符部分被忽略。一些段加载指令仍然有效(例如：POP ES)。但是在进行地址转换时会把ES、DS、SS段的基地址当作0来看待(即逻辑地址等于线性地址)</p>
<p>处理器会检查线性地址是否是<a href="https://en.wikipedia.org/wiki/X86-64#Canonical_form_addresses" target="_blank" rel="noopener">典型地址</a>，但是不会检查段限长。模式切换不会更改段寄存器，这些段寄存器在64位模式执行时同样不会被改变，除非明确的使用指令加载新的值。</p>
<p>为了使应用程序保持兼容，段加载指令同样能够在64位模式下正常工作，GDT/LDT中的段描述符同样会被自动加载到段寄存器的隐藏部分，然而，在64位模式下这些内容将被忽略，因为64位模式采用平坦模型，将出了FS/GS之外的段的基地址默认为0。FS和GS用来支持寄存器间接寻址。</p>
<p>在64位模式下，使用FS段和GS段覆盖的内存访问不会被检查段限长，也不会被检查属性。正常的段加载(MOV to Sreg和POP Sreg)到FS和GS，在段寄存器的隐藏部分加载一个标准的32位基础值。标准32位以上的基址位被清除为0，以允许使用少于64位的实现方式的一致性。</p>
<p>当在兼容模式下，FS和GS覆盖的操作是由32位模式行为定义的，不管加载到隐藏描述符寄存器基字段的前32位线性地址的值是什么。兼容性模式在计算有效地址时，会忽略上面的32位。</p>
<h2 id="段描述符-Segment-Descriptors"><a href="#段描述符-Segment-Descriptors" class="headerlink" title="段描述符(Segment Descriptors)"></a>段描述符(Segment Descriptors)</h2><p>段描述符是GDT/LDT数组中的每一个数组项，定义了段的地址、段的大小、访问控制信息以及状态信息。段描述符通常是由编译器、连接器、加载器或者操作系统程序创建，应用程序不允许创建段描述符。如下图为段描述符的通用结构：</p>
<p><img src="8.png" alt></p>
<h3 id="段限长-Segment-limit-field"><a href="#段限长-Segment-limit-field" class="headerlink" title="段限长(Segment limit field)"></a>段限长(Segment limit field)</h3><p>该字段表明了段的大小。处理器有两种方式使用该限长，这取决于段描述符中G标志</p>
<ul>
<li>G标志被清空时，段的大小在1B - 1MB之间(以Byte为单位)。</li>
<li>G标志置位时，段的大小在4KB - 4GB之间(以4KB为单位)。</li>
</ul>
<p>处理器有两种方式使用段限长，这取决于段是向上扩展还是向下扩展。</p>
<ul>
<li>对于向上扩展的段，段内的偏移从0到段限长，超过段限长的偏移值将会导致处理器产生通用保护异常。</li>
<li>对于乡下扩展的段，段内偏移从段限长+1到0xFFFFH或者0xFFFFFFFFH(取决于B标志)，小于等于段限长的偏移值偏移值将会导致处理器产生通用保护异常。减小段限长能够增加段的长度，一般情况下栈段都是向下扩展的段，这样有利于栈的增长。</li>
</ul>
<h3 id="基地址-Base-address-fields"><a href="#基地址-Base-address-fields" class="headerlink" title="基地址(Base address fields)"></a>基地址(Base address fields)</h3><p>该字段定义了段在4GB线性地址空间中的起始位置，段的起始位置最好是16字节对齐的，尽管没有硬性要求，但是16字节对齐的代码和数据能够使得处理器性能达到最佳(这是由于CPU的访问机制导致的，<a href="https://yangwang.hk/?p=773" target="_blank" rel="noopener">CPU为什么需要对齐访问</a>，如果数据不在内存对齐的地方，那么CPU就有可能需要读取两次才能取出一个完成的数据)。</p>
<h3 id="段描述符类型-Type-field"><a href="#段描述符类型-Type-field" class="headerlink" title="段描述符类型(Type field)"></a>段描述符类型(Type field)</h3><p>表明段或门的类型，并指定可进入段的种类和增长方向。这个字段的解释取决于描述符类型标志是指定一个应用(代码或数据)描述符还是系统描述符。类型字段的编码对于代码、数据和系统描述符是不同的。</p>
<h3 id="S标志-descriptor-type"><a href="#S标志-descriptor-type" class="headerlink" title="S标志(descriptor type)"></a>S标志(descriptor type)</h3><p>表明一个段是系统段还是应用程序段</p>
<ul>
<li>当S置位时，表明该段是应用程序段(代码、数据)</li>
<li>当S置0时，表明该段是系统段</li>
</ul>
<h3 id="DPL-descriptor-privilege-level"><a href="#DPL-descriptor-privilege-level" class="headerlink" title="DPL(descriptor privilege level)"></a>DPL(descriptor privilege level)</h3><p>指明了段的特权级，特权级从0到3，数字越大，特权越小。DPL用于控制对段的访问权限(后续介绍)。</p>
<h3 id="P标志-segment-present"><a href="#P标志-segment-present" class="headerlink" title="P标志(segment-present)"></a>P标志(segment-present)</h3><p>表明当前段是在内存中还是不在内存中。如果P置0，当指向段描述符的段选择子被加载进段寄存器时，处理器会产生一个NP异常(segment-not-present)。内存管理软件可以通过该标志来控制在某个特定时间有哪些段是被加载进内存的。该标志提供了一个除了分页之外的用于管理虚拟内存的方法。</p>
<p>当 P标志被置0时。操作系统或执行者可以自由地使用该段描述符中标记为 “可用”的位置来存储它自己的数据，例如关于失踪段位置的信息。如图：</p>
<p><img src="9.png" alt></p>
<h3 id="D-B标志-default-operation-size-default-stack-pointer-size-and-or-upper-bound"><a href="#D-B标志-default-operation-size-default-stack-pointer-size-and-or-upper-bound" class="headerlink" title="D/B标志(default operation size/default stack pointer size and/or upper bound)"></a>D/B标志(default operation size/default stack pointer size and/or upper bound)</h3><p>根据段描述符是可执行代码段、向下扩展的数据段还是堆栈段，该字段有不同的作用。(对于32位的代码和数据段，这个标志应该总是设置为1，对于16位的代码和数据段，应该设置为0)。</p>
<h4 id="可执行代码段"><a href="#可执行代码段" class="headerlink" title="可执行代码段"></a>可执行代码段</h4><p>对于可执行代码段，该标志被称为D标志，它表示段中指令所引用的有效地址和操作数的默认长度。如果置位，默认32位地址以及32位操作码或8位操作码；如果置0，默认16位地址以及16位操作码或8位操作码。另外，指令前缀66H可以指定操作符的长度而不使用默认长度，指令前缀67H可以指定地址值长度。</p>
<h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>对于栈段，该标志被称为B标志。它指定了用于隐式堆栈操作(如PUSH、POP和CALL)的堆栈指针的大小。如果置位，默认32位栈指针；将该指针放在32位的ESP寄存器中；如果置0，默认16位栈指针，将该指针放在16位的SP寄存器中。如果该栈段是向下扩展的段，那么该字段同样表明了段地址的上界(见下一节)。</p>
<h4 id="向下扩展的段"><a href="#向下扩展的段" class="headerlink" title="向下扩展的段"></a>向下扩展的段</h4><p>如果B置位，那么段的上界为0xFFFFFFFFH(4GB)；如果B置0，那么段的上界为0xFFFFH(1MB)。</p>
<h3 id="G标志-granularity"><a href="#G标志-granularity" class="headerlink" title="G标志(granularity)"></a>G标志(granularity)</h3><p>该字段用于确认段限长字段的单位，如果置0，那么段限长的单位就是Byte；如果置位，那么段限长的单位就是4KB。这个标志不影响段基地址的颗粒度，基地址的颗粒度总是字节单位。若设置了G标志，那么当使用段限长来检查偏移值时，并不会去检查偏移值的12位最低有效位。例如，当G=1时，段限长为0表明有效偏移值为0～4095。</p>
<p>需要注意的是，G标志和B/D标志两者其实并没有任何关系。例如：对于堆栈段，D置0，那么段的限长就是0xFFFFH(1MB)，此时如果G为1，那么说明粒度为4KB，这样检查段限长时，会忽略掉低12位，使用段限长的高4位。</p>
<h3 id="L标志-64-bit-code-segment"><a href="#L标志-64-bit-code-segment" class="headerlink" title="L标志(64-bit code segment)"></a>L标志(64-bit code segment)</h3><p>在IA-32e模式下，段描述符的第二个双字的第21位表明一个代码段是否包含本地64位代码。值为1表示该代码段中的指令是以64位模式执行的。值为0表示这个代码段中的指令是以兼容模式执行的。如果L位被设置，那么D位必须被清除(这是因为D标志是用来选择16位或32位，当L设置时表明是64位，此时D没有意义，即L=1/D=1组合没有意义)。</p>
<p>当不在IA-32e模式下或者对于非代码段，第21位是保留的，应该总是设置为0。</p>
<h3 id="代码段-数据段描述符类型-Code-and-Data-Segment-Descriptor-Types"><a href="#代码段-数据段描述符类型-Code-and-Data-Segment-Descriptor-Types" class="headerlink" title="代码段/数据段描述符类型(Code- and Data-Segment Descriptor Types)"></a>代码段/数据段描述符类型(Code- and Data-Segment Descriptor Types)</h3><p>段描述符的第二个双字的[8-11]四个bit表明了段的类型。当段描述符中的S置位时，说明该描述符是代码或者数据段。此时第11个bit位决定了当前段是代码段还是数据段：0 - 数据段，1 - 代码段。如图所示</p>
<ul>
<li>对于数据段，[8-10]分别表示访问标志(A)、写标志(W)、扩展方向(E)。注意，堆栈段也属于数据段，不过堆栈段必须是可读写的。尝试向SS段寄存器中加载一个不可写段的段选择子会导致处理器产生GP异常。如果堆栈大小会动态变化，那么可以将E置位，此时堆栈向下扩展，便于增长。访问位表示自上次操作系统或执行人员清除该位后，该段是否被访问过。假设包含段描述符的内存类型支持处理器写入，每当处理器将段的选择器加载到段寄存器时，就会设置这个位。该位一直被设置，直到明确地被清除。这个位既可以用于虚拟内存管理，也可以用于调试。</li>
<li>对于代码段，[8-10]分别表示访问标志(A)、可读标志(R)、一致性标志(C)。代码段可以为只执行、可读可执行。当有常量或者其他静态数据和代码一起在ROM时，必须要设置R位。要从代码段读取数据，可以通过代码CS前缀的指令或者将代码段选择符置入段寄存器(DS、ES、FS或GS)。在保护模式下，代码段不可写。代码段可以是一执性代码段，也可以是非一致性的。进程跳转到特权级更高的一致性代码段时，程序的当前特权级保持不变。进程跳转到不同特权级别的非一致性代码段会导致通用保护异常(#GP)，除非使用了调用门或任务门(后续介绍)。不访问受保护程序或者某些异常处理程序(例如，除法错误或溢出)的系统程序可以被加载进一致性代码段。而那些需要被保护程序应该被加载到非一致性代码段中。(至于为什么设置了一致性代码段，我想可能是为了使得应用程序在访问内核某些不需要保护的功能时不用进行特权级切换，毕竟用户态到内核态的切换开销也不低)。需要注意的是：程序不能通过call或jump转移到权限较低的代码段，无论目标段是一致性代码段还是非一致性代码段。试图进行这样的执行转移将导致一般保护异常。(因为搞特权级不信任低特权级代码)。</li>
<li>所有的数据段都是非一致性的，这也就意味着低特权级的程序不能访问高特权级的数据。和数据段相反，数据段可以被更高特权级的程序访问而不需要使用特别的访问门。</li>
<li>需要注意的是：如果GDT/LDT段描述符位于ROM中，当程序或处理器试图更改在ROM中的段描述符时，处理器会进入一个不确定的循环(硬件设计如此，不必使用软件思维纠结原因)。为了阻止这种情况，需要将位于ROM上的段描述符的A位置1，并且保证操作系统不会对这些段描述符进行修改。</li>
</ul>
<p><img src="10.png" alt></p>
<h1 id="系统段类型-SYSTEM-DESCRIPTOR-TYPES"><a href="#系统段类型-SYSTEM-DESCRIPTOR-TYPES" class="headerlink" title="系统段类型(SYSTEM DESCRIPTOR TYPES)"></a>系统段类型(SYSTEM DESCRIPTOR TYPES)</h1><p>当段描述符的S标志置0时，表明段描述符是一个系统段的段描述符，处理器能够识别以下几种类型的系统段描述符</p>
<ul>
<li>LDT段描述符</li>
<li>TSS段描述符</li>
<li>调用门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
<li>任务门描述符</li>
</ul>
<p>这些段描述符分为两大类：系统段描述符和门描述符，系统段描述符指向系统段；门描述符自身就是门，它们或者指向目标代码段的入口指针，或者持有TSS段的段描述符。系统段描述符和门描述符种类如下图所示：</p>
<p><img src="11.png" alt></p>
<h2 id="段描述符表-Segment-Descriptor-Tables"><a href="#段描述符表-Segment-Descriptor-Tables" class="headerlink" title="段描述符表(Segment Descriptor Tables)"></a>段描述符表(Segment Descriptor Tables)</h2><p>段描述符表就是一个段描述符的数组，一个表中最多可以容纳8192(2的13次方)个段描述符(因为每个段描述符占8个字节，段选择子16位，因此最多可以有2的16-3次方，也就是8192个段描述符)。系统中一共有两种类型的段描述符表</p>
<ul>
<li>GDT(global descriptor table)：全局表述符表</li>
<li>LDT(local descriptor table)：本地描述符表</li>
</ul>
<p>每个系统必须定义一个全局表述符表(GDT)，该描述符表被系统的所有进程和任务使用；也可以定义一个或多个LDT供任务使用。例如：可以为每一个任务定义一个独享的LDT，也可以为所有的任务定义一个共享的LDT。</p>
<p>GDT本身并不是一个段，它是线性地址空间的一个数据结构。GDT的线性基地址和限长必须被加载到GDTR寄存器中。并且GDT的地址应当8字节对齐从而获得更佳的处理器性能(因为GDT数据的每个段描述符占8字节)。GDT的限长单位是Byte。因为段描述符总是8字节长，因此GDT的限长应该总是8*N - 1。</p>
<p>处理器并不会GDT的第一个段描述符项，一个指向该空段描述符的段选择子被加载进数据段寄存器(DS/ES/FS/GS)时处理器并不会产生异常，但是当程序试图通过该空段描述符访问数据时，处理器会产生一个GP异常。使用该空段描述符初始化段寄存器，这样可以防止程序不经意间使用未加载有效段描述符的寄存器。</p>
<p>LDT段在GDT中有一个类型为LDT系统段描述符的段描述符。GDT必须包含指向LDT段的段描述符，如果系统有多个LDT段，那么每个LDT段在GDT中都有各自的LDT段描述符。LDT段的访问是通过段选择子进行的，同样的，为了节省地址转换的时间，当加载段寄存器时，LDT段的段描述符也会被加载到LDTR的隐藏部分。</p>
<p>当使用SGDT将GDTR寄存器中的内容加载到内存中时，应该将GDTR中的内容加载到一个奇数字地址(16 * (2n + 1))，因为GDTR中的内容长48字节，如果起始地址是奇字地址，那么GDTR中的内容最终就是双字对齐的。用户程序通常不存储GDTR的内容，但通过这样的对齐方式，可以避免产生对齐检查故障的可能性。同样的SIDT加载IDTR内容到内存时也应该这么做。但是对于LDTR和和TR的隐藏部分时，则需要偶数字地址(因为LDTR和TR的段描述符长度为64字节)</p>
<p>如图则是32位和64位下GDTR和IDTR中的内容</p>
<p><img src="12.png" alt></p>
<h2 id="IA-32e模式下的段描述符表-Segment-Descriptor-Tables-in-IA-32e-Mode"><a href="#IA-32e模式下的段描述符表-Segment-Descriptor-Tables-in-IA-32e-Mode" class="headerlink" title="IA-32e模式下的段描述符表(Segment Descriptor Tables in IA-32e Mode)"></a>IA-32e模式下的段描述符表(Segment Descriptor Tables in IA-32e Mode)</h2><p>在IA-32e模式下，一个段描述符表可以包含多达8192个8字节的描述符。段描述符表中的一个条目可以是8字节。系统描述符被扩展到16字节(占据两个条目的空间)。GDTR和LDTR寄存器被扩展为容纳64位基址。相应的伪描述符为80位，如上图。下面一些系统段描述符被扩展到16字节</p>
<ul>
<li>调用门描述符</li>
<li>IDT门描述符</li>
<li>LDT和TSS段描述符</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于分段机制的介绍到这里就告一段落了。回顾本文，对分段机制不同程度的使用，使得系统可以采用不同的内存模型，主要分为基础平坦模型、保护平坦模型、多段模型。<a href="https://www.wanweibaike.net/wiki-%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5" target="_blank" rel="noopener">历史参考</a>早期的分段模型主要是为了管理更大的物理内存，通过段寄存器指向段描述符，通过段描述符管理访问更大的内存地址空间，但是随着64位系统的推出，最多可以访问2的64次方的地址空间(目前只开放了48个地址总线，即最多可以管理156TB的内存，但是这也足够了)，已经逐渐不再使用分段，转而使用平坦内存模型。实际上linux无论是在32位还是64位的Intel架构上，都会通过将段基地址设为0来实现平坦内存模型(intel由于历史包袱不得不保留分段模型，但是实际上有的cpu并没有对分段提供很好的支持，linux通过这种方式提升了平台移植性)。</p>
<p>更多有关intel分段机制的历史：<a href="https://zhuanlan.zhihu.com/p/341861276" target="_blank" rel="noopener">参考1</a>，<a href="https://zhuanlan.zhihu.com/p/324210723" target="_blank" rel="noopener">参考2</a></p>

    </div>

    
    
    
	<div>
	
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------</div>
    
</div>

	
	</div>
	<div>
      
        
      
	</div>
        
      
        <div id="reward-container">
  <div>如果你喜欢，请我喝杯茶呗...</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="郭源潮 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/IA-32/" rel="tag"><i class="fa fa-tag"></i>IA-32</a>
            
              <a href="/tags/OS/" rel="tag"><i class="fa fa-tag"></i>OS</a>
            
              <a href="/tags/系统编程指南/" rel="tag"><i class="fa fa-tag"></i>系统编程指南</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2022/01/02/IA-32架构开发人员手册-3-系统架构概述/" rel="next" title="IA-32架构开发人员手册-3-系统架构概述">
                  <i class="fa fa-chevron-left"></i> IA-32架构开发人员手册-3-系统架构概述
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2022/01/15/IA-32架构开发人员手册-3-分页/" rel="prev" title="IA-32架构开发人员手册-3-分页">
                  IA-32架构开发人员手册-3-分页 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概览-MEMORY-MANAGEMENT-OVERVIEW"><span class="nav-number">1.</span> <span class="nav-text">概览(MEMORY MANAGEMENT OVERVIEW)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分段机制-USING-SEGMENTS"><span class="nav-number">2.</span> <span class="nav-text">分段机制(USING SEGMENTS)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础平坦模型-Basic-Flat-Model"><span class="nav-number">2.1.</span> <span class="nav-text">基础平坦模型(Basic Flat Model)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保护平坦模型"><span class="nav-number">2.2.</span> <span class="nav-text">保护平坦模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多段模型"><span class="nav-number">2.3.</span> <span class="nav-text">多段模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IA-32e模式下分段-Segmentation-in-IA-32e-Mode"><span class="nav-number">2.4.</span> <span class="nav-text">IA-32e模式下分段(Segmentation in IA-32e Mode)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页与分段-Paging-and-Segmentation"><span class="nav-number">2.5.</span> <span class="nav-text">分页与分段(Paging and Segmentation)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#物理地址空间-PHYSICAL-ADDRESS-SPACE"><span class="nav-number">3.</span> <span class="nav-text">物理地址空间(PHYSICAL ADDRESS SPACE)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Intel64处理器和物理地址空间-Intel®-64-Processors-and-Physical-Address-Space"><span class="nav-number">3.1.</span> <span class="nav-text">Intel64处理器和物理地址空间(Intel® 64 Processors and Physical Address Space)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#逻辑地址与线性地址-LOGICAL-AND-LINEAR-ADDRESSES"><span class="nav-number">4.</span> <span class="nav-text">逻辑地址与线性地址(LOGICAL AND LINEAR ADDRESSES)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IA-32e模式下的逻辑地址转换-Logical-Address-Translation-in-IA-32e-Mode"><span class="nav-number">4.1.</span> <span class="nav-text">IA-32e模式下的逻辑地址转换(Logical Address Translation in IA-32e Mode)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段选择子-Segment-Selectors"><span class="nav-number">4.2.</span> <span class="nav-text">段选择子(Segment Selectors)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Index-3-15bit"><span class="nav-number">4.2.1.</span> <span class="nav-text">Index(3-15bit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TI-table-indicator-bit2"><span class="nav-number">4.2.2.</span> <span class="nav-text">TI(table indicator, bit2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPL-Requested-Privilege-Level-bit0-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">RPL(Requested Privilege Level bit0-1)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段寄存器-Segment-Registers"><span class="nav-number">4.3.</span> <span class="nav-text">段寄存器(Segment Registers)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IA-32e模式下的段加载指令-Segment-Loading-Instructions-in-IA-32e-Mode"><span class="nav-number">4.4.</span> <span class="nav-text">IA-32e模式下的段加载指令(Segment Loading Instructions in IA-32e Mode)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段描述符-Segment-Descriptors"><span class="nav-number">4.5.</span> <span class="nav-text">段描述符(Segment Descriptors)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#段限长-Segment-limit-field"><span class="nav-number">4.5.1.</span> <span class="nav-text">段限长(Segment limit field)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基地址-Base-address-fields"><span class="nav-number">4.5.2.</span> <span class="nav-text">基地址(Base address fields)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段描述符类型-Type-field"><span class="nav-number">4.5.3.</span> <span class="nav-text">段描述符类型(Type field)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#S标志-descriptor-type"><span class="nav-number">4.5.4.</span> <span class="nav-text">S标志(descriptor type)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DPL-descriptor-privilege-level"><span class="nav-number">4.5.5.</span> <span class="nav-text">DPL(descriptor privilege level)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P标志-segment-present"><span class="nav-number">4.5.6.</span> <span class="nav-text">P标志(segment-present)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-B标志-default-operation-size-default-stack-pointer-size-and-or-upper-bound"><span class="nav-number">4.5.7.</span> <span class="nav-text">D/B标志(default operation size/default stack pointer size and/or upper bound)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可执行代码段"><span class="nav-number">4.5.7.1.</span> <span class="nav-text">可执行代码段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈段"><span class="nav-number">4.5.7.2.</span> <span class="nav-text">栈段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向下扩展的段"><span class="nav-number">4.5.7.3.</span> <span class="nav-text">向下扩展的段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G标志-granularity"><span class="nav-number">4.5.8.</span> <span class="nav-text">G标志(granularity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L标志-64-bit-code-segment"><span class="nav-number">4.5.9.</span> <span class="nav-text">L标志(64-bit code segment)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码段-数据段描述符类型-Code-and-Data-Segment-Descriptor-Types"><span class="nav-number">4.5.10.</span> <span class="nav-text">代码段/数据段描述符类型(Code- and Data-Segment Descriptor Types)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#系统段类型-SYSTEM-DESCRIPTOR-TYPES"><span class="nav-number">5.</span> <span class="nav-text">系统段类型(SYSTEM DESCRIPTOR TYPES)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#段描述符表-Segment-Descriptor-Tables"><span class="nav-number">5.1.</span> <span class="nav-text">段描述符表(Segment Descriptor Tables)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IA-32e模式下的段描述符表-Segment-Descriptor-Tables-in-IA-32e-Mode"><span class="nav-number">5.2.</span> <span class="nav-text">IA-32e模式下的段描述符表(Segment Descriptor Tables in IA-32e Mode)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/images.png"
      alt="郭源潮">
  <p class="site-author-name" itemprop="name">郭源潮</p>
  <div class="site-description" itemprop="description">时间在无声的诉说着一切</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/guoyuanchao1202" title="GitHub &rarr; https://github.com/guoyuanchao1202" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:932552424@qq.com" title="E-Mail &rarr; mailto:932552424@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/6273792268?is_all=1" title="Weibo &rarr; https://weibo.com/u/6273792268?is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.w3school.com.cn/tags/tag_ul.asp" title="https://www.w3school.com.cn/tags/tag_ul.asp" rel="noopener" target="_blank">w3school</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭源潮</span>
</div>
	<div class="powered-by">
	<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
	  本站访客数:<span id="busuanzi_value_site_uv"></span>
	  <span id="busuanzi_container_site_pv">
	  本站总访问量<span id="busuanzi_value_site_pv"></span>次
	  </span>
	</span>
	</div>
<!--

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.0</div>
-->

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='96,96,96' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

 
  <script type = "text/javascript"  src ="dist/canvas-nest.js"> </script>
 
</body>
</html>
